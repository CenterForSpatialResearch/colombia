'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lib = require('../../../lib');

var _shaderUtils = require('../../../shader-utils');

var _luma = require('luma.gl');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var glslify = require('glslify');

var DEFAULT_COLOR = [0, 0, 255, 255];

var defaultGetSourcePosition = function defaultGetSourcePosition(x) {
  return x.sourcePosition;
};
var defaultGetTargetPosition = function defaultGetTargetPosition(x) {
  return x.targetPosition;
};
var defaultGetColor = function defaultGetColor(x) {
  return x.color;
};

var ArcLayer = function (_Layer) {
  _inherits(ArcLayer, _Layer);

  /**
   * @classdesc
   * ArcLayer
   *
   * @class
   * @param {object} props
   */
  function ArcLayer() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$strokeWidth = _ref.strokeWidth,
        strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,
        _ref$getSourcePositio = _ref.getSourcePosition,
        getSourcePosition = _ref$getSourcePositio === undefined ? defaultGetSourcePosition : _ref$getSourcePositio,
        _ref$getTargetPositio = _ref.getTargetPosition,
        getTargetPosition = _ref$getTargetPositio === undefined ? defaultGetTargetPosition : _ref$getTargetPositio,
        _ref$getSourceColor = _ref.getSourceColor,
        getSourceColor = _ref$getSourceColor === undefined ? defaultGetColor : _ref$getSourceColor,
        _ref$getTargetColor = _ref.getTargetColor,
        getTargetColor = _ref$getTargetColor === undefined ? defaultGetColor : _ref$getTargetColor,
        props = _objectWithoutProperties(_ref, ['strokeWidth', 'getSourcePosition', 'getTargetPosition', 'getSourceColor', 'getTargetColor']);

    _classCallCheck(this, ArcLayer);

    return _possibleConstructorReturn(this, (ArcLayer.__proto__ || Object.getPrototypeOf(ArcLayer)).call(this, _extends({
      strokeWidth: strokeWidth,
      getSourcePosition: getSourcePosition,
      getTargetPosition: getTargetPosition,
      getSourceColor: getSourceColor,
      getTargetColor: getTargetColor
    }, props)));
  }

  _createClass(ArcLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this._createModel(gl) });

      var attributeManager = this.state.attributeManager;

      attributeManager.addInstanced({
        instancePositions: { size: 4, update: this.calculateInstancePositions },
        instanceSourceColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 4,
          update: this.calculateInstanceSourceColors
        },
        instanceTargetColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 4,
          update: this.calculateInstanceTargetColors
        }
      });
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var gl = this.context.gl;

      var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);
      gl.lineWidth(lineWidth);
      this.state.model.render(uniforms);
      // Setting line width back to 1 is here to workaround a Google Chrome bug
      // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with
      // correct parameter
      // This is not happening on Safari and Firefox
      gl.lineWidth(1.0);
    }
  }, {
    key: '_createModel',
    value: function _createModel(gl) {
      var positions = [];
      var NUM_SEGMENTS = 50;
      for (var i = 0; i < NUM_SEGMENTS; i++) {
        positions = [].concat(_toConsumableArray(positions), [i, i, i]);
      }

      return new _luma.Model(_extends({
        gl: gl
      }, (0, _shaderUtils.assembleShaders)(gl, {
        vs: '#define GLSLIFY 1\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n#define SHADER_NAME arc-layer-vertex-shader\n\n// #pragma glslify: preproject = require(../../../../shaderlib/preproject)\n// #pragma glslify: scale = require(../../../../shaderlib/scale)\n// #pragma glslify: project = require(../../../../shaderlib/project)\n\nconst float N = 49.0;\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvoid main(void) {\n  vec2 source = preproject(instancePositions.xy);\n  vec2 target = preproject(instancePositions.zw);\n\n  float segmentRatio = smoothstep(0.0, 1.0, positions.x / N);\n\n  float vertex_height = paraboloid(source, target, segmentRatio);\n  if (vertex_height < 0.0) vertex_height = 0.0;\n  vec3 p = vec3(\n    // xy: linear interpolation of source & target\n    mix(source, target, segmentRatio),\n    // z: paraboloid interpolate of source & target\n    sqrt(vertex_height)\n  );\n\n  gl_Position = project(vec4(p, 1.0));\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n\n  vColor = mix(\n    vec4(color.rgb, color.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n}\n',
        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n#define SHADER_NAME arc-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n'
      }), {
        geometry: new _luma.Geometry({
          drawMode: _luma.GL.LINE_STRIP,
          positions: new Float32Array(positions)
        }),
        isInstanced: true
      }));
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props = this.props,
          data = _props.data,
          getSourcePosition = _props.getSourcePosition,
          getTargetPosition = _props.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var sourcePosition = getSourcePosition(object);
          var targetPosition = getTargetPosition(object);
          value[i + 0] = sourcePosition[0];
          value[i + 1] = sourcePosition[1];
          value[i + 2] = targetPosition[0];
          value[i + 3] = targetPosition[1];
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceSourceColors',
    value: function calculateInstanceSourceColors(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getSourceColor = _props2.getSourceColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          var color = getSourceColor(object) || DEFAULT_COLOR;
          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceTargetColors',
    value: function calculateInstanceTargetColors(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getTargetColor = _props3.getTargetColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var object = _step3.value;

          var color = getTargetColor(object) || DEFAULT_COLOR;
          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }]);

  return ArcLayer;
}(_lib.Layer);

ArcLayer.layerName = 'ArcLayer';
exports.default = ArcLayer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvYXJjLWxheWVyLmpzIl0sIm5hbWVzIjpbImdsc2xpZnkiLCJyZXF1aXJlIiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRHZXRTb3VyY2VQb3NpdGlvbiIsIngiLCJzb3VyY2VQb3NpdGlvbiIsImRlZmF1bHRHZXRUYXJnZXRQb3NpdGlvbiIsInRhcmdldFBvc2l0aW9uIiwiZGVmYXVsdEdldENvbG9yIiwiY29sb3IiLCJBcmNMYXllciIsInN0cm9rZVdpZHRoIiwiZ2V0U291cmNlUG9zaXRpb24iLCJnZXRUYXJnZXRQb3NpdGlvbiIsImdldFNvdXJjZUNvbG9yIiwiZ2V0VGFyZ2V0Q29sb3IiLCJwcm9wcyIsImdsIiwiY29udGV4dCIsInNldFN0YXRlIiwibW9kZWwiLCJfY3JlYXRlTW9kZWwiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwic3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBvc2l0aW9ucyIsInNpemUiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyIsImluc3RhbmNlU291cmNlQ29sb3JzIiwidHlwZSIsIlVOU0lHTkVEX0JZVEUiLCJjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZUNvbG9ycyIsImluc3RhbmNlVGFyZ2V0Q29sb3JzIiwiY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRDb2xvcnMiLCJ1bmlmb3JtcyIsImxpbmVXaWR0aCIsInNjcmVlblRvRGV2aWNlUGl4ZWxzIiwicmVuZGVyIiwicG9zaXRpb25zIiwiTlVNX1NFR01FTlRTIiwiaSIsInZzIiwiZnMiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiTElORV9TVFJJUCIsIkZsb2F0MzJBcnJheSIsImlzSW5zdGFuY2VkIiwiYXR0cmlidXRlIiwiZGF0YSIsInZhbHVlIiwib2JqZWN0IiwiaXNOYU4iLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOzs7Ozs7Ozs7OytlQXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFNQSxJQUFNQSxVQUFVQyxRQUFRLFNBQVIsQ0FBaEI7O0FBRUEsSUFBTUMsZ0JBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxHQUFQLEVBQVksR0FBWixDQUF0Qjs7QUFFQSxJQUFNQywyQkFBMkIsU0FBM0JBLHdCQUEyQjtBQUFBLFNBQUtDLEVBQUVDLGNBQVA7QUFBQSxDQUFqQztBQUNBLElBQU1DLDJCQUEyQixTQUEzQkEsd0JBQTJCO0FBQUEsU0FBS0YsRUFBRUcsY0FBUDtBQUFBLENBQWpDO0FBQ0EsSUFBTUMsa0JBQWtCLFNBQWxCQSxlQUFrQjtBQUFBLFNBQUtKLEVBQUVLLEtBQVA7QUFBQSxDQUF4Qjs7SUFFcUJDLFE7OztBQUluQjs7Ozs7OztBQU9BLHNCQU9RO0FBQUEsbUZBQUosRUFBSTtBQUFBLGdDQU5OQyxXQU1NO0FBQUEsUUFOTkEsV0FNTSxvQ0FOUSxDQU1SO0FBQUEscUNBTE5DLGlCQUtNO0FBQUEsUUFMTkEsaUJBS00seUNBTGNULHdCQUtkO0FBQUEscUNBSk5VLGlCQUlNO0FBQUEsUUFKTkEsaUJBSU0seUNBSmNQLHdCQUlkO0FBQUEsbUNBSE5RLGNBR007QUFBQSxRQUhOQSxjQUdNLHVDQUhXTixlQUdYO0FBQUEsbUNBRk5PLGNBRU07QUFBQSxRQUZOQSxjQUVNLHVDQUZXUCxlQUVYO0FBQUEsUUFESFEsS0FDRzs7QUFBQTs7QUFBQTtBQUVKTCw4QkFGSTtBQUdKQywwQ0FISTtBQUlKQywwQ0FKSTtBQUtKQyxvQ0FMSTtBQU1KQztBQU5JLE9BT0RDLEtBUEM7QUFTUDs7OztzQ0FFaUI7QUFBQSxVQUNUQyxFQURTLEdBQ0gsS0FBS0MsT0FERixDQUNURCxFQURTOztBQUVoQixXQUFLRSxRQUFMLENBQWMsRUFBQ0MsT0FBTyxLQUFLQyxZQUFMLENBQWtCSixFQUFsQixDQUFSLEVBQWQ7O0FBRmdCLFVBSVRLLGdCQUpTLEdBSVcsS0FBS0MsS0FKaEIsQ0FJVEQsZ0JBSlM7O0FBS2hCQSx1QkFBaUJFLFlBQWpCLENBQThCO0FBQzVCQywyQkFBbUIsRUFBQ0MsTUFBTSxDQUFQLEVBQVVDLFFBQVEsS0FBS0MsMEJBQXZCLEVBRFM7QUFFNUJDLDhCQUFzQjtBQUNwQkMsZ0JBQU0sU0FBR0MsYUFEVztBQUVwQkwsZ0JBQU0sQ0FGYztBQUdwQkMsa0JBQVEsS0FBS0s7QUFITyxTQUZNO0FBTzVCQyw4QkFBc0I7QUFDcEJILGdCQUFNLFNBQUdDLGFBRFc7QUFFcEJMLGdCQUFNLENBRmM7QUFHcEJDLGtCQUFRLEtBQUtPO0FBSE87QUFQTSxPQUE5QjtBQWFEOzs7Z0NBRWdCO0FBQUEsVUFBWEMsUUFBVyxTQUFYQSxRQUFXO0FBQUEsVUFDUmxCLEVBRFEsR0FDRixLQUFLQyxPQURILENBQ1JELEVBRFE7O0FBRWYsVUFBTW1CLFlBQVksS0FBS0Msb0JBQUwsQ0FBMEIsS0FBS3JCLEtBQUwsQ0FBV0wsV0FBckMsQ0FBbEI7QUFDQU0sU0FBR21CLFNBQUgsQ0FBYUEsU0FBYjtBQUNBLFdBQUtiLEtBQUwsQ0FBV0gsS0FBWCxDQUFpQmtCLE1BQWpCLENBQXdCSCxRQUF4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FsQixTQUFHbUIsU0FBSCxDQUFhLEdBQWI7QUFDRDs7O2lDQUVZbkIsRSxFQUFJO0FBQ2YsVUFBSXNCLFlBQVksRUFBaEI7QUFDQSxVQUFNQyxlQUFlLEVBQXJCO0FBQ0EsV0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFlBQXBCLEVBQWtDQyxHQUFsQyxFQUF1QztBQUNyQ0YsaURBQWdCQSxTQUFoQixJQUEyQkUsQ0FBM0IsRUFBOEJBLENBQTlCLEVBQWlDQSxDQUFqQztBQUNEOztBQUVELGFBQU87QUFDTHhCO0FBREssU0FFRixrQ0FBZ0JBLEVBQWhCLEVBQW9CO0FBQ3JCeUIsaXZGQURxQjtBQUVyQkM7QUFGcUIsT0FBcEIsQ0FGRTtBQU1MQyxrQkFBVSxtQkFBYTtBQUNyQkMsb0JBQVUsU0FBR0MsVUFEUTtBQUVyQlAscUJBQVcsSUFBSVEsWUFBSixDQUFpQlIsU0FBakI7QUFGVSxTQUFiLENBTkw7QUFVTFMscUJBQWE7QUFWUixTQUFQO0FBWUQ7OzsrQ0FFMEJDLFMsRUFBVztBQUFBLG1CQUNpQixLQUFLakMsS0FEdEI7QUFBQSxVQUM3QmtDLElBRDZCLFVBQzdCQSxJQUQ2QjtBQUFBLFVBQ3ZCdEMsaUJBRHVCLFVBQ3ZCQSxpQkFEdUI7QUFBQSxVQUNKQyxpQkFESSxVQUNKQSxpQkFESTtBQUFBLFVBRTdCc0MsS0FGNkIsR0FFZEYsU0FGYyxDQUU3QkUsS0FGNkI7QUFBQSxVQUV0QnpCLElBRnNCLEdBRWR1QixTQUZjLENBRXRCdkIsSUFGc0I7O0FBR3BDLFVBQUllLElBQUksQ0FBUjtBQUhvQztBQUFBO0FBQUE7O0FBQUE7QUFJcEMsNkJBQXFCUyxJQUFyQiw4SEFBMkI7QUFBQSxjQUFoQkUsTUFBZ0I7O0FBQ3pCLGNBQU0vQyxpQkFBaUJPLGtCQUFrQndDLE1BQWxCLENBQXZCO0FBQ0EsY0FBTTdDLGlCQUFpQk0sa0JBQWtCdUMsTUFBbEIsQ0FBdkI7QUFDQUQsZ0JBQU1WLElBQUksQ0FBVixJQUFlcEMsZUFBZSxDQUFmLENBQWY7QUFDQThDLGdCQUFNVixJQUFJLENBQVYsSUFBZXBDLGVBQWUsQ0FBZixDQUFmO0FBQ0E4QyxnQkFBTVYsSUFBSSxDQUFWLElBQWVsQyxlQUFlLENBQWYsQ0FBZjtBQUNBNEMsZ0JBQU1WLElBQUksQ0FBVixJQUFlbEMsZUFBZSxDQUFmLENBQWY7QUFDQWtDLGVBQUtmLElBQUw7QUFDRDtBQVptQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYXJDOzs7a0RBRTZCdUIsUyxFQUFXO0FBQUEsb0JBQ1IsS0FBS2pDLEtBREc7QUFBQSxVQUNoQ2tDLElBRGdDLFdBQ2hDQSxJQURnQztBQUFBLFVBQzFCcEMsY0FEMEIsV0FDMUJBLGNBRDBCO0FBQUEsVUFFaENxQyxLQUZnQyxHQUVqQkYsU0FGaUIsQ0FFaENFLEtBRmdDO0FBQUEsVUFFekJ6QixJQUZ5QixHQUVqQnVCLFNBRmlCLENBRXpCdkIsSUFGeUI7O0FBR3ZDLFVBQUllLElBQUksQ0FBUjtBQUh1QztBQUFBO0FBQUE7O0FBQUE7QUFJdkMsOEJBQXFCUyxJQUFyQixtSUFBMkI7QUFBQSxjQUFoQkUsTUFBZ0I7O0FBQ3pCLGNBQU0zQyxRQUFRSyxlQUFlc0MsTUFBZixLQUEwQmxELGFBQXhDO0FBQ0FpRCxnQkFBTVYsSUFBSSxDQUFWLElBQWVoQyxNQUFNLENBQU4sQ0FBZjtBQUNBMEMsZ0JBQU1WLElBQUksQ0FBVixJQUFlaEMsTUFBTSxDQUFOLENBQWY7QUFDQTBDLGdCQUFNVixJQUFJLENBQVYsSUFBZWhDLE1BQU0sQ0FBTixDQUFmO0FBQ0EwQyxnQkFBTVYsSUFBSSxDQUFWLElBQWVZLE1BQU01QyxNQUFNLENBQU4sQ0FBTixJQUFrQlAsY0FBYyxDQUFkLENBQWxCLEdBQXFDTyxNQUFNLENBQU4sQ0FBcEQ7QUFDQWdDLGVBQUtmLElBQUw7QUFDRDtBQVhzQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWXhDOzs7a0RBRTZCdUIsUyxFQUFXO0FBQUEsb0JBQ1IsS0FBS2pDLEtBREc7QUFBQSxVQUNoQ2tDLElBRGdDLFdBQ2hDQSxJQURnQztBQUFBLFVBQzFCbkMsY0FEMEIsV0FDMUJBLGNBRDBCO0FBQUEsVUFFaENvQyxLQUZnQyxHQUVqQkYsU0FGaUIsQ0FFaENFLEtBRmdDO0FBQUEsVUFFekJ6QixJQUZ5QixHQUVqQnVCLFNBRmlCLENBRXpCdkIsSUFGeUI7O0FBR3ZDLFVBQUllLElBQUksQ0FBUjtBQUh1QztBQUFBO0FBQUE7O0FBQUE7QUFJdkMsOEJBQXFCUyxJQUFyQixtSUFBMkI7QUFBQSxjQUFoQkUsTUFBZ0I7O0FBQ3pCLGNBQU0zQyxRQUFRTSxlQUFlcUMsTUFBZixLQUEwQmxELGFBQXhDO0FBQ0FpRCxnQkFBTVYsSUFBSSxDQUFWLElBQWVoQyxNQUFNLENBQU4sQ0FBZjtBQUNBMEMsZ0JBQU1WLElBQUksQ0FBVixJQUFlaEMsTUFBTSxDQUFOLENBQWY7QUFDQTBDLGdCQUFNVixJQUFJLENBQVYsSUFBZWhDLE1BQU0sQ0FBTixDQUFmO0FBQ0EwQyxnQkFBTVYsSUFBSSxDQUFWLElBQWVZLE1BQU01QyxNQUFNLENBQU4sQ0FBTixJQUFrQlAsY0FBYyxDQUFkLENBQWxCLEdBQXFDTyxNQUFNLENBQU4sQ0FBcEQ7QUFDQWdDLGVBQUtmLElBQUw7QUFDRDtBQVhzQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWXhDOzs7Ozs7QUEzSGtCaEIsUSxDQUVaNEMsUyxHQUFZLFU7a0JBRkE1QyxRIiwiZmlsZSI6ImFyYy1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5cbmNvbnN0IGdsc2xpZnkgPSByZXF1aXJlKCdnbHNsaWZ5Jyk7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMjU1LCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0R2V0U291cmNlUG9zaXRpb24gPSB4ID0+IHguc291cmNlUG9zaXRpb247XG5jb25zdCBkZWZhdWx0R2V0VGFyZ2V0UG9zaXRpb24gPSB4ID0+IHgudGFyZ2V0UG9zaXRpb247XG5jb25zdCBkZWZhdWx0R2V0Q29sb3IgPSB4ID0+IHguY29sb3I7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0xheWVyIGV4dGVuZHMgTGF5ZXIge1xuXG4gIHN0YXRpYyBsYXllck5hbWUgPSAnQXJjTGF5ZXInO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEFyY0xheWVyXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJva2VXaWR0aCA9IDEsXG4gICAgZ2V0U291cmNlUG9zaXRpb24gPSBkZWZhdWx0R2V0U291cmNlUG9zaXRpb24sXG4gICAgZ2V0VGFyZ2V0UG9zaXRpb24gPSBkZWZhdWx0R2V0VGFyZ2V0UG9zaXRpb24sXG4gICAgZ2V0U291cmNlQ29sb3IgPSBkZWZhdWx0R2V0Q29sb3IsXG4gICAgZ2V0VGFyZ2V0Q29sb3IgPSBkZWZhdWx0R2V0Q29sb3IsXG4gICAgLi4ucHJvcHNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBnZXRTb3VyY2VQb3NpdGlvbixcbiAgICAgIGdldFRhcmdldFBvc2l0aW9uLFxuICAgICAgZ2V0U291cmNlQ29sb3IsXG4gICAgICBnZXRUYXJnZXRDb2xvcixcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fY3JlYXRlTW9kZWwoZ2wpfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7c2l6ZTogNCwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zfSxcbiAgICAgIGluc3RhbmNlU291cmNlQ29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVNvdXJjZUNvbG9yc1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlVGFyZ2V0Q29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVRhcmdldENvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLnNjcmVlblRvRGV2aWNlUGl4ZWxzKHRoaXMucHJvcHMuc3Ryb2tlV2lkdGgpO1xuICAgIGdsLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICAvLyBTZXR0aW5nIGxpbmUgd2lkdGggYmFjayB0byAxIGlzIGhlcmUgdG8gd29ya2Fyb3VuZCBhIEdvb2dsZSBDaHJvbWUgYnVnXG4gICAgLy8gZ2wuY2xlYXIoKSBhbmQgZ2wuaXNFbmFibGVkKCkgd2lsbCByZXR1cm4gR0xfSU5WQUxJRF9WQUxVRSBldmVuIHdpdGhcbiAgICAvLyBjb3JyZWN0IHBhcmFtZXRlclxuICAgIC8vIFRoaXMgaXMgbm90IGhhcHBlbmluZyBvbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICBnbC5saW5lV2lkdGgoMS4wKTtcbiAgfVxuXG4gIF9jcmVhdGVNb2RlbChnbCkge1xuICAgIGxldCBwb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBOVU1fU0VHTUVOVFMgPSA1MDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5VTV9TRUdNRU5UUzsgaSsrKSB7XG4gICAgICBwb3NpdGlvbnMgPSBbLi4ucG9zaXRpb25zLCBpLCBpLCBpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgLi4uYXNzZW1ibGVTaGFkZXJzKGdsLCB7XG4gICAgICAgIHZzOiBnbHNsaWZ5KCcuL2FyYy1sYXllci12ZXJ0ZXguZ2xzbCcpLFxuICAgICAgICBmczogZ2xzbGlmeSgnLi9hcmMtbGF5ZXItZnJhZ21lbnQuZ2xzbCcpXG4gICAgICB9KSxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuTElORV9TVFJJUCxcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRTb3VyY2VQb3NpdGlvbiwgZ2V0VGFyZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGdldFNvdXJjZVBvc2l0aW9uKG9iamVjdCk7XG4gICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFRhcmdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBzb3VyY2VQb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHNvdXJjZVBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gdGFyZ2V0UG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpICsgM10gPSB0YXJnZXRQb3NpdGlvblsxXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0U291cmNlQ29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldFNvdXJjZUNvbG9yKG9iamVjdCkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IERFRkFVTFRfQ09MT1JbM10gOiBjb2xvclszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVRhcmdldENvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0VGFyZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldFRhcmdldENvbG9yKG9iamVjdCkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IERFRkFVTFRfQ09MT1JbM10gOiBjb2xvclszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==