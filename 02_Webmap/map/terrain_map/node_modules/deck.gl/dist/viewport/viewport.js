'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.COORDINATE_SYSTEM = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class; // View and Projection Matrix calculations for mapbox-js style
// map view properties
//
// ATTRIBUTION:
// Projection matrix creation are intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl.
// See: transform.js in https://github.com/mapbox/mapbox-gl-js

var _perspective = require('viewport-mercator-project/perspective');

Object.defineProperty(exports, 'COORDINATE_SYSTEM', {
  enumerable: true,
  get: function get() {
    return _perspective.COORDINATE_SYSTEM;
  }
});

var _perspective2 = _interopRequireDefault(_perspective);

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _glMatrix = require('gl-matrix');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - Math.fround(a);
  return [hiPart, loPart];
}

var WebGLViewport = (_class = function (_Viewport) {
  _inherits(WebGLViewport, _Viewport);

  function WebGLViewport(options) {
    _classCallCheck(this, WebGLViewport);

    var _this = _possibleConstructorReturn(this, (WebGLViewport.__proto__ || Object.getPrototypeOf(WebGLViewport)).call(this, options));

    _this._calculateWebGLMatrices();
    return _this;
  }

  /**
   * Returns a projection matrix suitable for shaders
   * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
   */


  _createClass(WebGLViewport, [{
    key: 'getProjectionMatrix',
    value: function getProjectionMatrix() {
      return this.glProjectionMatrix;
    }
  }, {
    key: 'getProjectionMatrixFP64',
    value: function getProjectionMatrixFP64() {
      return this.glProjectionMatrixFP64;
    }
  }, {
    key: 'getProjectionMatrixUncentered',
    value: function getProjectionMatrixUncentered() {
      return this.glProjectionMatrixUncentered;
    }
  }, {
    key: 'getWebGLMatrices',
    value: function getWebGLMatrices() {
      return {
        projectionMatrix: this.glProjectionMatrix,
        projectionFP64: this.glProjectionMatrixFP64
      };
    }
  }, {
    key: 'getUniforms',
    value: function getUniforms() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$projectionMode = _ref.projectionMode,
          projectionMode = _ref$projectionMode === undefined ? _perspective.COORDINATE_SYSTEM.LNGLAT : _ref$projectionMode,
          _ref$positionOrigin = _ref.positionOrigin,
          positionOrigin = _ref$positionOrigin === undefined ? [0, 0] : _ref$positionOrigin,
          _ref$modelMatrix = _ref.modelMatrix,
          modelMatrix = _ref$modelMatrix === undefined ? null : _ref$modelMatrix;

      // TODO: move the following line to initialization so that it's done only once
      var positionOriginPixels = this.projectFlat(positionOrigin);

      var projectedPositionOrigin = [positionOriginPixels[0], positionOriginPixels[1], 0.0, 1.0];
      var projections = this.getProjections();
      var viewProjectionMatrix = projections.viewProjectionMatrix;


      var projectionCenter = _glMatrix.vec4.transformMat4([], projectedPositionOrigin, viewProjectionMatrix);

      // If necessary add modelMatrix to clipSpace projection
      if (modelMatrix) {
        _glMatrix.mat4.multiply(viewProjectionMatrix, viewProjectionMatrix, modelMatrix);
      }

      return {
        // Projection mode values
        projectionMode: projectionMode,
        projectionCenter: projectionCenter,

        // Main projection matrices
        projectionMatrix: this.glProjectionMatrix,
        projectionFP64: this.glProjectionMatrixFP64,
        projectionPixelsPerUnit: this.pixelsPerMeter,
        projectionScale: this.scale,
        projectionScaleFP64: fp64ify(this.scale),

        // TODO - deprecated, remove
        mercatorScale: Math.pow(2, this.zoom),
        mercatorCenter: this.center
        // projectionMatrixCentered: this.glProjectionMatrix,
        // projectionMatrixUncentered: this.glProjectionMatrixUncentered
        // _ONE uniform is hack: make tan_fp64() callable in existing 32bit layers
      };
    }
  }, {
    key: '_calculateWebGLMatrices',
    value: function _calculateWebGLMatrices() {
      this.glProjectionMatrix = new Float32Array(this.viewProjectionMatrix);
      this.glProjectionMatrixFP64 = new Float32Array(32);
      this._dy64ifyProjectionMatrix();
    }
  }, {
    key: '_dy64ifyProjectionMatrix',
    value: function _dy64ifyProjectionMatrix() {
      // Transpose the projection matrix to column major for GLSL.
      for (var i = 0; i < 4; ++i) {
        for (var j = 0; j < 4; ++j) {
          var _fp64ify = fp64ify(this.viewProjectionMatrix[j * 4 + i]);

          var _fp64ify2 = _slicedToArray(_fp64ify, 2);

          this.glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
          this.glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
        }
      }
    }
  }]);

  return WebGLViewport;
}(_perspective2.default), (_applyDecoratedDescriptor(_class.prototype, 'getProjectionMatrix', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getProjectionMatrix'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'getProjectionMatrixFP64', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getProjectionMatrixFP64'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'getProjectionMatrixUncentered', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getProjectionMatrixUncentered'), _class.prototype)), _class);
exports.default = WebGLViewport;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92aWV3cG9ydC92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJDT09SRElOQVRFX1NZU1RFTSIsImZwNjRpZnkiLCJhIiwiaGlQYXJ0IiwiTWF0aCIsImZyb3VuZCIsImxvUGFydCIsIldlYkdMVmlld3BvcnQiLCJvcHRpb25zIiwiX2NhbGN1bGF0ZVdlYkdMTWF0cmljZXMiLCJnbFByb2plY3Rpb25NYXRyaXgiLCJnbFByb2plY3Rpb25NYXRyaXhGUDY0IiwiZ2xQcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZCIsInByb2plY3Rpb25NYXRyaXgiLCJwcm9qZWN0aW9uRlA2NCIsInByb2plY3Rpb25Nb2RlIiwiTE5HTEFUIiwicG9zaXRpb25PcmlnaW4iLCJtb2RlbE1hdHJpeCIsInBvc2l0aW9uT3JpZ2luUGl4ZWxzIiwicHJvamVjdEZsYXQiLCJwcm9qZWN0ZWRQb3NpdGlvbk9yaWdpbiIsInByb2plY3Rpb25zIiwiZ2V0UHJvamVjdGlvbnMiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsInByb2plY3Rpb25DZW50ZXIiLCJ0cmFuc2Zvcm1NYXQ0IiwibXVsdGlwbHkiLCJwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCIsInBpeGVsc1Blck1ldGVyIiwicHJvamVjdGlvblNjYWxlIiwic2NhbGUiLCJwcm9qZWN0aW9uU2NhbGVGUDY0IiwibWVyY2F0b3JTY2FsZSIsInBvdyIsInpvb20iLCJtZXJjYXRvckNlbnRlciIsImNlbnRlciIsIkZsb2F0MzJBcnJheSIsIl9keTY0aWZ5UHJvamVjdGlvbk1hdHJpeCIsImkiLCJqIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OzsyQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozt3QkFLUUEsaUI7Ozs7OztBQUhSOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLFNBQVNDLE9BQVQsQ0FBaUJDLENBQWpCLEVBQW9CO0FBQ2xCLE1B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SUFBYyxDQUFkLEdBQWtCLENBQTlDLENBSHdCO0FBSzNCO0FBQ0Y7QUFDRjs7Ozs7a0JBNUZrQmxDLGEiLCJmaWxlIjoidmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuLy9cbi8vIEFUVFJJQlVUSU9OOlxuLy8gUHJvamVjdGlvbiBtYXRyaXggY3JlYXRpb24gYXJlIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLlxuLy8gU2VlOiB0cmFuc2Zvcm0uanMgaW4gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanNcblxuaW1wb3J0IFZpZXdwb3J0LCB7Q09PUkRJTkFURV9TWVNURU19XG4gIGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QvcGVyc3BlY3RpdmUnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJ2F1dG9iaW5kLWRlY29yYXRvcic7XG5pbXBvcnQge21hdDQsIHZlYzR9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmV4cG9ydCB7Q09PUkRJTkFURV9TWVNURU19XG4gIGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QvcGVyc3BlY3RpdmUnO1xuXG5mdW5jdGlvbiBmcDY0aWZ5KGEpIHtcbiAgY29uc3QgaGlQYXJ0ID0gTWF0aC5mcm91bmQoYSk7XG4gIGNvbnN0IGxvUGFydCA9IGEgLSBNYXRoLmZyb3VuZChhKTtcbiAgcmV0dXJuIFtoaVBhcnQsIGxvUGFydF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMVmlld3BvcnQgZXh0ZW5kcyBWaWV3cG9ydCB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZVdlYkdMTWF0cmljZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvamVjdGlvbiBtYXRyaXggc3VpdGFibGUgZm9yIHNoYWRlcnNcbiAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAtIDR4NCBwcm9qZWN0aW9uIG1hdHJpeCB0aGF0IGNhbiBiZSB1c2VkIGluIHNoYWRlcnNcbiAgICovXG4gIEBhdXRvYmluZFxuICBnZXRQcm9qZWN0aW9uTWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLmdsUHJvamVjdGlvbk1hdHJpeDtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBnZXRQcm9qZWN0aW9uTWF0cml4RlA2NCgpIHtcbiAgICByZXR1cm4gdGhpcy5nbFByb2plY3Rpb25NYXRyaXhGUDY0O1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIGdldFByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmdsUHJvamVjdGlvbk1hdHJpeFVuY2VudGVyZWQ7XG4gIH1cblxuICBnZXRXZWJHTE1hdHJpY2VzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiB0aGlzLmdsUHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHByb2plY3Rpb25GUDY0OiB0aGlzLmdsUHJvamVjdGlvbk1hdHJpeEZQNjRcbiAgICB9O1xuICB9XG5cbiAgZ2V0VW5pZm9ybXMoe1xuICAgIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICAgIHBvc2l0aW9uT3JpZ2luID0gWzAsIDBdLFxuICAgIG1vZGVsTWF0cml4ID0gbnVsbFxuICB9ID0ge30pIHtcbiAgICAvLyBUT0RPOiBtb3ZlIHRoZSBmb2xsb3dpbmcgbGluZSB0byBpbml0aWFsaXphdGlvbiBzbyB0aGF0IGl0J3MgZG9uZSBvbmx5IG9uY2VcbiAgICBjb25zdCBwb3NpdGlvbk9yaWdpblBpeGVscyA9IHRoaXMucHJvamVjdEZsYXQocG9zaXRpb25PcmlnaW4pO1xuXG4gICAgY29uc3QgcHJvamVjdGVkUG9zaXRpb25PcmlnaW4gPVxuICAgICAgW3Bvc2l0aW9uT3JpZ2luUGl4ZWxzWzBdLCBwb3NpdGlvbk9yaWdpblBpeGVsc1sxXSwgMC4wLCAxLjBdO1xuICAgIGNvbnN0IHByb2plY3Rpb25zID0gdGhpcy5nZXRQcm9qZWN0aW9ucygpO1xuICAgIGNvbnN0IHt2aWV3UHJvamVjdGlvbk1hdHJpeH0gPSBwcm9qZWN0aW9ucztcblxuICAgIGNvbnN0IHByb2plY3Rpb25DZW50ZXIgPVxuICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLCBwcm9qZWN0ZWRQb3NpdGlvbk9yaWdpbiwgdmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgLy8gSWYgbmVjZXNzYXJ5IGFkZCBtb2RlbE1hdHJpeCB0byBjbGlwU3BhY2UgcHJvamVjdGlvblxuICAgIGlmIChtb2RlbE1hdHJpeCkge1xuICAgICAgbWF0NC5tdWx0aXBseSh2aWV3UHJvamVjdGlvbk1hdHJpeCwgdmlld1Byb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gUHJvamVjdGlvbiBtb2RlIHZhbHVlc1xuICAgICAgcHJvamVjdGlvbk1vZGUsXG4gICAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgICAvLyBNYWluIHByb2plY3Rpb24gbWF0cmljZXNcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHRoaXMuZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgcHJvamVjdGlvbkZQNjQ6IHRoaXMuZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCxcbiAgICAgIHByb2plY3Rpb25QaXhlbHNQZXJVbml0OiB0aGlzLnBpeGVsc1Blck1ldGVyLFxuICAgICAgcHJvamVjdGlvblNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgcHJvamVjdGlvblNjYWxlRlA2NDogZnA2NGlmeSh0aGlzLnNjYWxlKSxcblxuICAgICAgLy8gVE9ETyAtIGRlcHJlY2F0ZWQsIHJlbW92ZVxuICAgICAgbWVyY2F0b3JTY2FsZTogTWF0aC5wb3coMiwgdGhpcy56b29tKSxcbiAgICAgIG1lcmNhdG9yQ2VudGVyOiB0aGlzLmNlbnRlclxuICAgICAgLy8gcHJvamVjdGlvbk1hdHJpeENlbnRlcmVkOiB0aGlzLmdsUHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIC8vIHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkOiB0aGlzLmdsUHJvamVjdGlvbk1hdHJpeFVuY2VudGVyZWRcbiAgICAgIC8vIF9PTkUgdW5pZm9ybSBpcyBoYWNrOiBtYWtlIHRhbl9mcDY0KCkgY2FsbGFibGUgaW4gZXhpc3RpbmcgMzJiaXQgbGF5ZXJzXG4gICAgfTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVXZWJHTE1hdHJpY2VzKCkge1xuICAgIHRoaXMuZ2xQcm9qZWN0aW9uTWF0cml4ID1cbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkodGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdGhpcy5nbFByb2plY3Rpb25NYXRyaXhGUDY0ID0gbmV3IEZsb2F0MzJBcnJheSgzMik7XG4gICAgdGhpcy5fZHk2NGlmeVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxuXG4gIF9keTY0aWZ5UHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgICAgW1xuICAgICAgICAgIHRoaXMuZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDJdLFxuICAgICAgICAgIHRoaXMuZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDIgKyAxXVxuICAgICAgICBdID0gZnA2NGlmeSh0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4W2ogKiA0ICsgaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19