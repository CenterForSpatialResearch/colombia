'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// IMLEMENTATION NOTES: Why new layers are created on every render
//
// The key here is to understand the declarative / functional
// programming nature of "reactive" applications.
//
// - In a reactive application, the entire "UI tree"
//   is re-rendered every time something in the application changes.
//
// - The UI framework (such as React or deck.gl) then diffs the rendered
//   tree of UI elements (React Elements or deck.gl Layers) against the
//   previously tree and makes optimized changes (to the DOM or to WebGL state).
//
// - Deck.gl layers are not based on React.
//   But it should be possible to wrap deck.gl layers in React components to
//   enable use of JSX.
//
// The deck.gl model that for the app creates a new set of on layers on every
// render.
// Internally, the new layers are efficiently matched against existing layers
// using layer ids.
//
// All calculated state (programs, attributes etc) are stored in a state object
// and this state object is moved forward to the match layer on every render
// cycle.  The new layer ends up with the state of the old layer (and the
// props of the new layer), while the old layer is simply discarded for
// garbage collecion.
//
/* eslint-disable no-try-catch */


var _layer = require('./layer');

var _layer2 = _interopRequireDefault(_layer);

var _viewport = require('../viewport');

var _utils = require('./utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _pickLayers = require('./pick-layers');

var _luma = require('luma.gl');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LayerManager = function () {
  function LayerManager(_ref) {
    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    this.prevLayers = [];
    this.layers = [];
    // Tracks if any layers were drawn last update
    // Needed to ensure that screen is cleared when no layers are shown
    this.drewLayers = false;
    this.oldContext = {};
    this.context = {
      gl: gl,
      uniforms: {},
      viewport: null,
      viewportChanged: true,
      pickingFBO: null
    };
    this.redrawNeeded = true;
    Object.seal(this.context);
  }

  _createClass(LayerManager, [{
    key: 'setContext',
    value: function setContext(_ref2) {
      var width = _ref2.width,
          height = _ref2.height,
          latitude = _ref2.latitude,
          longitude = _ref2.longitude,
          zoom = _ref2.zoom,
          pitch = _ref2.pitch,
          bearing = _ref2.bearing,
          altitude = _ref2.altitude;

      var oldViewport = this.context.viewport;
      var viewportChanged = !oldViewport || width !== oldViewport.width || height !== oldViewport.height || latitude !== oldViewport.latitude || longitude !== oldViewport.longitude || zoom !== oldViewport.zoom || bearing !== oldViewport.bearing || pitch !== oldViewport.pitch || altitude !== oldViewport.altitude;

      if (viewportChanged || !this.context.viewport) {
        Object.assign(this.oldContext, this.context);

        var viewport = new _viewport.Viewport({
          width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing, altitude: altitude,
          tileSize: 512
        });

        this.context.viewport = viewport;
        this.context.viewportChanged = viewportChanged;
        this.context.uniforms = {};

        (0, _utils.log)(4, viewport, latitude, longitude, zoom);
      }

      return this;
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref3) {
      var newLayers = _ref3.newLayers;

      (0, _assert2.default)(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return Boolean(newLayer);
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers() {
      (0, _assert2.default)(this.context.viewport, 'LayerManager.drawLayers: viewport not set');

      var uniforms = this.context.uniforms;

      var layerIndex = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          if (layer.props.visible) {
            layer.drawLayer({ uniforms: uniforms, layerIndex: layerIndex });
            layerIndex++;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return this;
    }
  }, {
    key: 'pickLayer',
    value: function pickLayer(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          mode = _ref4.mode;
      var _context = this.context,
          gl = _context.gl,
          uniforms = _context.uniforms;

      // Set up a frame buffer if needed

      if (this.context.pickingFBO === null || gl.canvas.width !== this.context.pickingFBO.width || gl.canvas.height !== this.context.pickingFBO.height) {
        this.context.pickingFBO = new _luma.FramebufferObject(gl, {
          width: gl.canvas.width,
          height: gl.canvas.height
        });
      }
      return (0, _pickLayers.pickLayers)(gl, {
        x: x,
        y: y,
        uniforms: uniforms,
        layers: this.layers,
        mode: mode,
        pickingFBO: this.context.pickingFBO
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$clearRedrawFlag = _ref5.clearRedrawFlags,
          clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = false;

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0 && this.drewLayers) {
        redraw = true;
        return true;
      }

      if (this.redrawNeeded) {
        this.redrawNeeded = false;
        redraw = true;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var layer = _step3.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
          this.drewLayers = true;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return redraw;
    }

    // PRIVATE METHODS

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref6) {
      var oldLayers = _ref6.oldLayers,
          newLayers = _ref6.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var oldLayer = _step4.value;

          if (oldLayerMap[oldLayer.id]) {
            _utils.log.once(0, 'Multipe old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref7) {
      var newLayers = _ref7.newLayers,
          oldLayerMap = _ref7.oldLayerMap,
          generatedLayers = _ref7.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return Boolean(newLayer);
      });

      var error = null;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var newLayer = _step5.value;

          newLayer.context = this.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              _utils.log.once(0, 'Multipe new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {
              (0, _utils.log)(3, 'matched ' + layerName(newLayer), oldLayer, '=>', newLayer);
              this._transferLayerState(oldLayer, newLayer);
              this._updateLayer(newLayer);
            } else {
              this._initializeNewLayer(newLayer);
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var sublayers = newLayer.renderLayers();
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              sublayers = Array.isArray(sublayers) ? sublayers : [sublayers];
              this._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            _utils.log.once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err);
            // Save first error
            error = error || err;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      (0, _assert2.default)(state, 'deck.gl sanity check - Matching layer has no state');
      (0, _assert2.default)(oldLayer !== newLayer, 'deck.gl sanity check - Matching layer is same');

      // Move state
      newLayer.state = state;
      state.layer = newLayer;

      // Update model layer reference
      if (state.model) {
        state.model.userData.layer = newLayer;
      }
      // Keep a temporary ref to the old props, for prop comparison
      newLayer.oldProps = props;
      oldLayer.state = null;
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Unmatched layers still have state, it will be discarded
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = oldLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var layer = _step6.value;

          if (layer.state) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        (0, _utils.log)(1, 'initializing ' + layerName(layer));
        try {
          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });
        } catch (err) {
          _utils.log.once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          _utils.log.once(0, 'deck.gl error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        (0, _utils.log)(2, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          _utils.log.once(0, 'deck.gl error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        layer.state = null;
        (0, _utils.log)(1, 'finalizing ' + layerName(layer));
      }
      return error;
    }
  }]);

  return LayerManager;
}();

exports.default = LayerManager;


function layerName(layer) {
  if (layer instanceof _layer2.default) {
    return '' + layer;
  }
  return !layer ? 'null layer' : 'invalid layer';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJMYXllck1hbmFnZXIiLCJnbCIsInByZXZMYXllcnMiLCJsYXllcnMiLCJkcmV3TGF5ZXJzIiwib2xkQ29udGV4dCIsImNvbnRleHQiLCJ1bmlmb3JtcyIsInZpZXdwb3J0Iiwidmlld3BvcnRDaGFuZ2VkIiwicGlja2luZ0ZCTyIsInJlZHJhd05lZWRlZCIsIk9iamVjdCIsInNlYWwiLCJ3aWR0aCIsImhlaWdodCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwib2xkVmlld3BvcnQiLCJhc3NpZ24iLCJ0aWxlU2l6ZSIsIm5ld0xheWVycyIsImZpbHRlciIsIkJvb2xlYW4iLCJuZXdMYXllciIsImxheWVyIiwiX3VwZGF0ZUxheWVycyIsIm9sZExheWVycyIsImVycm9yIiwiZ2VuZXJhdGVkTGF5ZXJzIiwibGF5ZXJJbmRleCIsInByb3BzIiwidmlzaWJsZSIsImRyYXdMYXllciIsIngiLCJ5IiwibW9kZSIsImNhbnZhcyIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJsZW5ndGgiLCJnZXROZWVkc1JlZHJhdyIsIm9sZExheWVyTWFwIiwib2xkTGF5ZXIiLCJpZCIsIm9uY2UiLCJsYXllck5hbWUiLCJfbWF0Y2hTdWJsYXllcnMiLCJlcnJvcjIiLCJfZmluYWxpemVPbGRMYXllcnMiLCJmaXJzdEVycm9yIiwiX3RyYW5zZmVyTGF5ZXJTdGF0ZSIsIl91cGRhdGVMYXllciIsIl9pbml0aWFsaXplTmV3TGF5ZXIiLCJwdXNoIiwic3VibGF5ZXJzIiwicmVuZGVyTGF5ZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyIiwic3RhdGUiLCJtb2RlbCIsInVzZXJEYXRhIiwib2xkUHJvcHMiLCJfZmluYWxpemVMYXllciIsImluaXRpYWxpemVMYXllciIsImNoYW5nZUZsYWdzIiwiZGlmZlByb3BzIiwidXBkYXRlTGF5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RUE7QUFDQS9CLGtCQUFRK0IsR0FBUjtBQUNEO0FBQ0RsQyxjQUFNbUMsS0FBTixHQUFjLElBQWQ7QUFDQSx3QkFBSSxDQUFKLGtCQUFxQmQsVUFBVXJCLEtBQVYsQ0FBckI7QUFDRDtBQUNELGFBQU9HLEtBQVA7QUFDRDs7Ozs7O2tCQXJVa0JoQyxZOzs7QUF3VXJCLFNBQVNrRCxTQUFULENBQW1CckIsS0FBbkIsRUFBMEI7QUFDeEIsTUFBSUEsZ0NBQUosRUFBNEI7QUFDMUIsZ0JBQVVBLEtBQVY7QUFDRDtBQUNELFNBQU8sQ0FBQ0EsS0FBRCxHQUFTLFlBQVQsR0FBd0IsZUFBL0I7QUFDRCIsImZpbGUiOiJsYXllci1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBJTUxFTUVOVEFUSU9OIE5PVEVTOiBXaHkgbmV3IGxheWVycyBhcmUgY3JlYXRlZCBvbiBldmVyeSByZW5kZXJcbi8vXG4vLyBUaGUga2V5IGhlcmUgaXMgdG8gdW5kZXJzdGFuZCB0aGUgZGVjbGFyYXRpdmUgLyBmdW5jdGlvbmFsXG4vLyBwcm9ncmFtbWluZyBuYXR1cmUgb2YgXCJyZWFjdGl2ZVwiIGFwcGxpY2F0aW9ucy5cbi8vXG4vLyAtIEluIGEgcmVhY3RpdmUgYXBwbGljYXRpb24sIHRoZSBlbnRpcmUgXCJVSSB0cmVlXCJcbi8vICAgaXMgcmUtcmVuZGVyZWQgZXZlcnkgdGltZSBzb21ldGhpbmcgaW4gdGhlIGFwcGxpY2F0aW9uIGNoYW5nZXMuXG4vL1xuLy8gLSBUaGUgVUkgZnJhbWV3b3JrIChzdWNoIGFzIFJlYWN0IG9yIGRlY2suZ2wpIHRoZW4gZGlmZnMgdGhlIHJlbmRlcmVkXG4vLyAgIHRyZWUgb2YgVUkgZWxlbWVudHMgKFJlYWN0IEVsZW1lbnRzIG9yIGRlY2suZ2wgTGF5ZXJzKSBhZ2FpbnN0IHRoZVxuLy8gICBwcmV2aW91c2x5IHRyZWUgYW5kIG1ha2VzIG9wdGltaXplZCBjaGFuZ2VzICh0byB0aGUgRE9NIG9yIHRvIFdlYkdMIHN0YXRlKS5cbi8vXG4vLyAtIERlY2suZ2wgbGF5ZXJzIGFyZSBub3QgYmFzZWQgb24gUmVhY3QuXG4vLyAgIEJ1dCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gd3JhcCBkZWNrLmdsIGxheWVycyBpbiBSZWFjdCBjb21wb25lbnRzIHRvXG4vLyAgIGVuYWJsZSB1c2Ugb2YgSlNYLlxuLy9cbi8vIFRoZSBkZWNrLmdsIG1vZGVsIHRoYXQgZm9yIHRoZSBhcHAgY3JlYXRlcyBhIG5ldyBzZXQgb2Ygb24gbGF5ZXJzIG9uIGV2ZXJ5XG4vLyByZW5kZXIuXG4vLyBJbnRlcm5hbGx5LCB0aGUgbmV3IGxheWVycyBhcmUgZWZmaWNpZW50bHkgbWF0Y2hlZCBhZ2FpbnN0IGV4aXN0aW5nIGxheWVyc1xuLy8gdXNpbmcgbGF5ZXIgaWRzLlxuLy9cbi8vIEFsbCBjYWxjdWxhdGVkIHN0YXRlIChwcm9ncmFtcywgYXR0cmlidXRlcyBldGMpIGFyZSBzdG9yZWQgaW4gYSBzdGF0ZSBvYmplY3Rcbi8vIGFuZCB0aGlzIHN0YXRlIG9iamVjdCBpcyBtb3ZlZCBmb3J3YXJkIHRvIHRoZSBtYXRjaCBsYXllciBvbiBldmVyeSByZW5kZXJcbi8vIGN5Y2xlLiAgVGhlIG5ldyBsYXllciBlbmRzIHVwIHdpdGggdGhlIHN0YXRlIG9mIHRoZSBvbGQgbGF5ZXIgKGFuZCB0aGVcbi8vIHByb3BzIG9mIHRoZSBuZXcgbGF5ZXIpLCB3aGlsZSB0aGUgb2xkIGxheWVyIGlzIHNpbXBseSBkaXNjYXJkZWQgZm9yXG4vLyBnYXJiYWdlIGNvbGxlY2lvbi5cbi8vXG4vKiBlc2xpbnQtZGlzYWJsZSBuby10cnktY2F0Y2ggKi9cbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcbmltcG9ydCB7Vmlld3BvcnR9IGZyb20gJy4uL3ZpZXdwb3J0JztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7cGlja0xheWVyc30gZnJvbSAnLi9waWNrLWxheWVycyc7XG5pbXBvcnQge0ZyYW1lYnVmZmVyT2JqZWN0fSBmcm9tICdsdW1hLmdsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXJNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioe2dsfSkge1xuICAgIHRoaXMucHJldkxheWVycyA9IFtdO1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgLy8gVHJhY2tzIGlmIGFueSBsYXllcnMgd2VyZSBkcmF3biBsYXN0IHVwZGF0ZVxuICAgIC8vIE5lZWRlZCB0byBlbnN1cmUgdGhhdCBzY3JlZW4gaXMgY2xlYXJlZCB3aGVuIG5vIGxheWVycyBhcmUgc2hvd25cbiAgICB0aGlzLmRyZXdMYXllcnMgPSBmYWxzZTtcbiAgICB0aGlzLm9sZENvbnRleHQgPSB7fTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBnbCxcbiAgICAgIHVuaWZvcm1zOiB7fSxcbiAgICAgIHZpZXdwb3J0OiBudWxsLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkOiB0cnVlLFxuICAgICAgcGlja2luZ0ZCTzogbnVsbFxuICAgIH07XG4gICAgdGhpcy5yZWRyYXdOZWVkZWQgPSB0cnVlO1xuICAgIE9iamVjdC5zZWFsKHRoaXMuY29udGV4dCk7XG4gIH1cblxuICBzZXRDb250ZXh0KHtcbiAgICB3aWR0aCwgaGVpZ2h0LCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBwaXRjaCwgYmVhcmluZywgYWx0aXR1ZGVcbiAgfSkge1xuICAgIGNvbnN0IG9sZFZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9ICFvbGRWaWV3cG9ydCB8fFxuICAgICAgd2lkdGggIT09IG9sZFZpZXdwb3J0LndpZHRoIHx8XG4gICAgICBoZWlnaHQgIT09IG9sZFZpZXdwb3J0LmhlaWdodCB8fFxuICAgICAgbGF0aXR1ZGUgIT09IG9sZFZpZXdwb3J0LmxhdGl0dWRlIHx8XG4gICAgICBsb25naXR1ZGUgIT09IG9sZFZpZXdwb3J0LmxvbmdpdHVkZSB8fFxuICAgICAgem9vbSAhPT0gb2xkVmlld3BvcnQuem9vbSB8fFxuICAgICAgYmVhcmluZyAhPT0gb2xkVmlld3BvcnQuYmVhcmluZyB8fFxuICAgICAgcGl0Y2ggIT09IG9sZFZpZXdwb3J0LnBpdGNoIHx8XG4gICAgICBhbHRpdHVkZSAhPT0gb2xkVmlld3BvcnQuYWx0aXR1ZGU7XG5cbiAgICBpZiAodmlld3BvcnRDaGFuZ2VkIHx8ICF0aGlzLmNvbnRleHQudmlld3BvcnQpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vbGRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuXG4gICAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydCh7XG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nLCBhbHRpdHVkZSxcbiAgICAgICAgdGlsZVNpemU6IDUxMlxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0Q2hhbmdlZCA9IHZpZXdwb3J0Q2hhbmdlZDtcbiAgICAgIHRoaXMuY29udGV4dC51bmlmb3JtcyA9IHt9O1xuXG4gICAgICBsb2coNCwgdmlld3BvcnQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJzKHtuZXdMYXllcnN9KSB7XG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgICdMYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gQm9vbGVhbihuZXdMYXllcikpO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIGxheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgY29uc3Qge2Vycm9yLCBnZW5lcmF0ZWRMYXllcnN9ID0gdGhpcy5fdXBkYXRlTGF5ZXJzKHtcbiAgICAgIG9sZExheWVyczogdGhpcy5wcmV2TGF5ZXJzLFxuICAgICAgbmV3TGF5ZXJzXG4gICAgfSk7XG4gICAgdGhpcy5sYXllcnMgPSBnZW5lcmF0ZWRMYXllcnM7XG4gICAgLy8gVGhyb3cgZmlyc3QgZXJyb3IgZm91bmQsIGlmIGFueVxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZHJhd0xheWVycygpIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnM6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgIGNvbnN0IHt1bmlmb3Jtc30gPSB0aGlzLmNvbnRleHQ7XG4gICAgbGV0IGxheWVySW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlKSB7XG4gICAgICAgIGxheWVyLmRyYXdMYXllcih7dW5pZm9ybXMsIGxheWVySW5kZXh9KTtcbiAgICAgICAgbGF5ZXJJbmRleCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGlja0xheWVyKHt4LCB5LCBtb2RlfSkge1xuICAgIGNvbnN0IHtnbCwgdW5pZm9ybXN9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgLy8gU2V0IHVwIGEgZnJhbWUgYnVmZmVyIGlmIG5lZWRlZFxuICAgIGlmICh0aGlzLmNvbnRleHQucGlja2luZ0ZCTyA9PT0gbnVsbCB8fFxuICAgIGdsLmNhbnZhcy53aWR0aCAhPT0gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8ud2lkdGggfHxcbiAgICBnbC5jYW52YXMuaGVpZ2h0ICE9PSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPID0gbmV3IEZyYW1lYnVmZmVyT2JqZWN0KGdsLCB7XG4gICAgICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwaWNrTGF5ZXJzKGdsLCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgbGF5ZXJzOiB0aGlzLmxheWVycyxcbiAgICAgIG1vZGUsXG4gICAgICBwaWNraW5nRkJPOiB0aGlzLmNvbnRleHQucGlja2luZ0ZCT1xuICAgIH0pO1xuICB9XG5cbiAgbmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGlmICghdGhpcy5jb250ZXh0LnZpZXdwb3J0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzIGNsZWFyZWQgb25jZSB3aGVuIGxheWVyIGxpc3QgYmVjb21lcyBlbXB0eVxuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDAgJiYgdGhpcy5kcmV3TGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVkcmF3TmVlZGVkKSB7XG4gICAgICB0aGlzLnJlZHJhd05lZWRlZCA9IGZhbHNlO1xuICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICAgIHRoaXMuZHJld0xheWVycyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICAvLyBNYXRjaCBhbGwgbGF5ZXJzLCBjaGVja2luZyBmb3IgY2F1Z2h0IGVycm9yc1xuICAvLyBUbyBhdm9pZCBoYXZpbmcgYW4gZXhjZXB0aW9uIGluIG9uZSBsYXllciBkaXNydXB0IG90aGVyIGxheWVyc1xuICBfdXBkYXRlTGF5ZXJzKHtvbGRMYXllcnMsIG5ld0xheWVyc30pIHtcbiAgICAvLyBDcmVhdGUgb2xkIGxheWVyIG1hcFxuICAgIGNvbnN0IG9sZExheWVyTWFwID0ge307XG4gICAgZm9yIChjb25zdCBvbGRMYXllciBvZiBvbGRMYXllcnMpIHtcbiAgICAgIGlmIChvbGRMYXllck1hcFtvbGRMYXllci5pZF0pIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYE11bHRpcGUgb2xkIGxheWVycyB3aXRoIHNhbWUgaWQgJHtsYXllck5hbWUob2xkTGF5ZXIpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdID0gb2xkTGF5ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb2NhdGUgYXJyYXkgZm9yIGdlbmVyYXRlZCBsYXllcnNcbiAgICBjb25zdCBnZW5lcmF0ZWRMYXllcnMgPSBbXTtcblxuICAgIC8vIE1hdGNoIHN1YmxheWVyc1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hTdWJsYXllcnMoe1xuICAgICAgbmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBlcnJvcjIgPSB0aGlzLl9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllcnMpO1xuICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBlcnJvciB8fCBlcnJvcjI7XG4gICAgcmV0dXJuIHtlcnJvcjogZmlyc3RFcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9tYXRjaFN1YmxheWVycyh7bmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzfSkge1xuICAgIC8vIEZpbHRlciBvdXQgYW55IG51bGwgbGF5ZXJzXG4gICAgbmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmZpbHRlcihuZXdMYXllciA9PiBCb29sZWFuKG5ld0xheWVyKSk7XG5cbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbmV3TGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBuZXdMYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyAxLiBnaXZlbiBhIG5ldyBjb21pbmcgbGF5ZXIsIGZpbmQgaXRzIG1hdGNoaW5nIGxheWVyXG4gICAgICAgIGNvbnN0IG9sZExheWVyID0gb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdO1xuICAgICAgICBvbGRMYXllck1hcFtuZXdMYXllci5pZF0gPSBudWxsO1xuXG4gICAgICAgIGlmIChvbGRMYXllciA9PT0gbnVsbCkge1xuICAgICAgICAgIGxvZy5vbmNlKDAsIGBNdWx0aXBlIG5ldyBsYXllcnMgd2l0aCBzYW1lIGlkICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgdHJhbnNmZXIgc3RhdGUgYXQgdGhpcyBzdGFnZS4gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9uc1xuICAgICAgICAvLyB1bnRpbCBhbGwgbGF5ZXJzJyBzdGF0ZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgaWYgKG9sZExheWVyKSB7XG4gICAgICAgICAgbG9nKDMsIGBtYXRjaGVkICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gLCBvbGRMYXllciwgJz0+JywgbmV3TGF5ZXIpO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKG5ld0xheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplTmV3TGF5ZXIobmV3TGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRlZExheWVycy5wdXNoKG5ld0xheWVyKTtcblxuICAgICAgICAvLyBDYWxsIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcbiAgICAgICAgbGV0IHN1YmxheWVycyA9IG5ld0xheWVyLnJlbmRlckxheWVycygpO1xuICAgICAgICAvLyBFbmQgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuXG4gICAgICAgIGlmIChzdWJsYXllcnMpIHtcbiAgICAgICAgICBzdWJsYXllcnMgPSBBcnJheS5pc0FycmF5KHN1YmxheWVycykgPyBzdWJsYXllcnMgOiBbc3VibGF5ZXJzXTtcbiAgICAgICAgICB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICAgICAgICBuZXdMYXllcnM6IHN1YmxheWVycyxcbiAgICAgICAgICAgIG9sZExheWVyTWFwLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLFxuICAgICAgICAgIGBkZWNrLmdsIGVycm9yIGR1cmluZyBtYXRjaGluZyBvZiAke2xheWVyTmFtZShuZXdMYXllcil9ICR7ZXJyfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIF90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKSB7XG4gICAgY29uc3Qge3N0YXRlLCBwcm9wc30gPSBvbGRMYXllcjtcblxuICAgIC8vIHNhbml0eSBjaGVja1xuICAgIGFzc2VydChzdGF0ZSxcbiAgICAgICdkZWNrLmdsIHNhbml0eSBjaGVjayAtIE1hdGNoaW5nIGxheWVyIGhhcyBubyBzdGF0ZScpO1xuICAgIGFzc2VydChvbGRMYXllciAhPT0gbmV3TGF5ZXIsXG4gICAgICAnZGVjay5nbCBzYW5pdHkgY2hlY2sgLSBNYXRjaGluZyBsYXllciBpcyBzYW1lJyk7XG5cbiAgICAvLyBNb3ZlIHN0YXRlXG4gICAgbmV3TGF5ZXIuc3RhdGUgPSBzdGF0ZTtcbiAgICBzdGF0ZS5sYXllciA9IG5ld0xheWVyO1xuXG4gICAgLy8gVXBkYXRlIG1vZGVsIGxheWVyIHJlZmVyZW5jZVxuICAgIGlmIChzdGF0ZS5tb2RlbCkge1xuICAgICAgc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBuZXdMYXllcjtcbiAgICB9XG4gICAgLy8gS2VlcCBhIHRlbXBvcmFyeSByZWYgdG8gdGhlIG9sZCBwcm9wcywgZm9yIHByb3AgY29tcGFyaXNvblxuICAgIG5ld0xheWVyLm9sZFByb3BzID0gcHJvcHM7XG4gICAgb2xkTGF5ZXIuc3RhdGUgPSBudWxsO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBvbGQgbGF5ZXJzIHRoYXQgd2VyZSBub3QgbWF0Y2hlZFxuICBfZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJzKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAvLyBVbm1hdGNoZWQgbGF5ZXJzIHN0aWxsIGhhdmUgc3RhdGUsIGl0IHdpbGwgYmUgZGlzY2FyZGVkXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBvbGRMYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5zdGF0ZSkge1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IHRoaXMuX2ZpbmFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBJbml0aWFsaXplcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF9pbml0aWFsaXplTmV3TGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIC8vIENoZWNrIGlmIG5ldyBsYXllciwgYW5kIGluaXRpYWxpemUgaXQncyBzdGF0ZVxuICAgIGlmICghbGF5ZXIuc3RhdGUpIHtcbiAgICAgIGxvZygxLCBgaW5pdGlhbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmluaXRpYWxpemVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHM6IHt9LFxuICAgICAgICAgIHByb3BzOiBsYXllci5wcm9wcyxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMoe30sIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uIG9mICR7bGF5ZXJOYW1lKGxheWVyKX0gJHtlcnJ9YCxcbiAgICAgICAgICBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGJhY2sgcG9pbnRlciAodXNlZCBpbiBwaWNraW5nKVxuICAgICAgaWYgKGxheWVyLnN0YXRlKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIC8vIFNhdmUgbGF5ZXIgb24gbW9kZWwgZm9yIHBpY2tpbmcgcHVycG9zZXNcbiAgICAgICAgLy8gVE9ETyAtIHN0b3JlIG9uIG1vZGVsLnVzZXJEYXRhIHJhdGhlciB0aGFuIGRpcmVjdGx5IG9uIG1vZGVsXG4gICAgICB9XG4gICAgICBpZiAobGF5ZXIuc3RhdGUgJiYgbGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgbGF5ZXIuc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gVXBkYXRlcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF91cGRhdGVMYXllcihsYXllcikge1xuICAgIGNvbnN0IHtvbGRQcm9wcywgcHJvcHN9ID0gbGF5ZXI7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBpZiAob2xkUHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLnVwZGF0ZUxheWVyKHtcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMob2xkUHJvcHMsIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIHVwZGF0ZSBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIGxvZygyLCBgdXBkYXRpbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBGaW5hbGl6ZXMgYSBzaW5nbGUgbGF5ZXJcbiAgX2ZpbmFsaXplTGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IHtzdGF0ZX0gPSBsYXllcjtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmZpbmFsaXplTGF5ZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLFxuICAgICAgICAgIGBkZWNrLmdsIGVycm9yIGR1cmluZyBmaW5hbGl6YXRpb24gb2YgJHtsYXllck5hbWUobGF5ZXIpfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICBsYXllci5zdGF0ZSA9IG51bGw7XG4gICAgICBsb2coMSwgYGZpbmFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF5ZXJOYW1lKGxheWVyKSB7XG4gIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgcmV0dXJuIGAke2xheWVyfWA7XG4gIH1cbiAgcmV0dXJuICFsYXllciA/ICdudWxsIGxheWVyJyA6ICdpbnZhbGlkIGxheWVyJztcbn1cbiJdfQ==