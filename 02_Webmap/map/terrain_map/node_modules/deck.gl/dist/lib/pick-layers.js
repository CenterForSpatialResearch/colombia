'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickLayers = pickLayers;

var _luma = require('luma.gl');

/* eslint-disable max-depth, max-statements */
function pickLayers(gl, _ref) {
  var layers = _ref.layers,
      pickingFBO = _ref.pickingFBO,
      _ref$uniforms = _ref.uniforms,
      uniforms = _ref$uniforms === undefined ? {} : _ref$uniforms,
      x = _ref.x,
      y = _ref.y,
      mode = _ref.mode;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * pixelRatio;
  var deviceY = gl.canvas.height - y * pixelRatio;

  // TODO - just return glContextWithState once luma updates
  var pickedInfos = [];

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  (0, _luma.glContextWithState)(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {
    var zOrder = 0;

    for (var i = layers.length - 1; i >= 0; --i) {
      var layer = layers[i];

      if (layer.props.visible && layer.props.pickable) {
        // Clear the frame buffer, render and sample
        gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);
        var info = createInfo({
          layer: layer,
          pixel: [x, y],
          devicePixel: [deviceX, deviceY],
          pixelRatio: pixelRatio
        });

        layer.pickLayer({
          info: info,
          uniforms: uniforms,
          pickEnableUniforms: { renderPickingBuffer: 1, pickingEnabled: 1 },
          pickDisableUniforms: { renderPickingBuffer: 0, pickingEnabled: 0 },
          deviceX: deviceX, deviceY: deviceY,
          mode: mode
        });

        if (info.index >= 0) {
          info.picked = true;
          info.zOrder = zOrder++;
          // If props.data is an indexable array, get the object
          if (Array.isArray(layer.props.data)) {
            info.object = layer.props.data[info.index];
          }
        }

        pickedInfos.push(info);
      }
    }
  });

  // Calling callbacks can have async interactions with React
  // which nullifies layer.state.
  var unhandledPickInfos = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = pickedInfos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var info = _step.value;

      var handled = null;
      switch (mode) {
        case 'click':
          handled = info.layer.props.onClick(info);break;
        case 'hover':
          handled = info.layer.props.onHover(info);break;
        default:
          throw new Error('unknown pick type');
      }

      if (!handled) {
        unhandledPickInfos.push(info);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return unhandledPickInfos;
}
/* eslint-enable max-depth, max-statements */

/* global window */
function createInfo(_ref2) {
  var info = _ref2.info,
      layer = _ref2.layer,
      pixel = _ref2.pixel,
      devicePixel = _ref2.devicePixel,
      pixelRatio = _ref2.pixelRatio;

  // Assign a number of potentially useful props to the "info" object
  return {
    layer: layer,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    devicePixel: devicePixel,
    pixelRatio: pixelRatio,
    lngLat: layer.unproject(pixel)
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcGljay1sYXllcnMuanMiXSwibmFtZXMiOlsicGlja0xheWVycyIsImdsIiwibGF5ZXJzIiwicGlja2luZ0ZCTyIsInVuaWZvcm1zIiwieCIsInkiLCJtb2RlIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VYIiwiZGV2aWNlWSIsImNhbnZhcyIsImhlaWdodCIsInBpY2tlZEluZm9zIiwiZnJhbWVCdWZmZXIiLCJmcmFtZWJ1ZmZlciIsInNjaXNzb3JUZXN0IiwidyIsImgiLCJ6T3JkZXIiLCJpIiwibGVuZ3RoIiwibGF5ZXIiLCJwcm9wcyIsInZpc2libGUiLCJwaWNrYWJsZSIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJpbmZvIiwiY3JlYXRlSW5mbyIsInBpeGVsIiwiZGV2aWNlUGl4ZWwiLCJwaWNrTGF5ZXIiLCJwaWNrRW5hYmxlVW5pZm9ybXMiLCJyZW5kZXJQaWNraW5nQnVmZmVyIiwicGlja2luZ0VuYWJsZWQiLCJwaWNrRGlzYWJsZVVuaWZvcm1zIiwiaW5kZXgiLCJwaWNrZWQiLCJBcnJheSIsImlzQXJyYXkiLCJkYXRhIiwib2JqZWN0IiwicHVzaCIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImhhbmRsZWQiLCJvbkNsaWNrIiwib25Ib3ZlciIsIkVycm9yIiwibG5nTGF0IiwidW5wcm9qZWN0Il0sIm1hcHBpbmdzIjoiOzs7OztRQUlnQkEsVSxHQUFBQSxVOztBQUhoQjs7QUFFQTtBQUNPLFNBQVNBLFVBQVQsQ0FBb0JDLEVBQXBCLFFBT0o7QUFBQSxNQU5EQyxNQU1DLFFBTkRBLE1BTUM7QUFBQSxNQUxEQyxVQUtDLFFBTERBLFVBS0M7QUFBQSwyQkFKREMsUUFJQztBQUFBLE1BSkRBLFFBSUMsaUNBSlUsRUFJVjtBQUFBLE1BSERDLENBR0MsUUFIREEsQ0FHQztBQUFBLE1BRkRDLENBRUMsUUFGREEsQ0FFQztBQUFBLE1BRERDLElB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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF3RUQsU0FBT2dCLGtCQUFQO0FBQ0Q7QUFDRDs7QUFyRkE7QUF1RkEsU0FBU2YsVUFBVCxRQU1HO0FBQUEsTUFMREQsSUFLQyxTQUxEQSxJQUtDO0FBQUEsTUFKRFAsS0FJQyxTQUpEQSxLQUlDO0FBQUEsTUFIRFMsS0FHQyxTQUhEQSxLQUdDO0FBQUEsTUFGREMsV0FFQyxTQUZEQSxXQUVDO0FBQUEsTUFERDFCLFVBQ0MsU0FEREEsVUFDQzs7QUFDRDtBQUNBLFNBQU87QUFDTGdCLGdCQURLO0FBRUxnQixXQUFPLENBQUMsQ0FGSDtBQUdMQyxZQUFRLEtBSEg7QUFJTHBDLE9BQUc0QixNQUFNLENBQU4sQ0FKRTtBQUtMM0IsT0FBRzJCLE1BQU0sQ0FBTixDQUxFO0FBTUxBLGdCQU5LO0FBT0xDLDRCQVBLO0FBUUwxQiwwQkFSSztBQVNMNEMsWUFBUTVCLE1BQU02QixTQUFOLENBQWdCcEIsS0FBaEI7QUFUSCxHQUFQO0FBV0QiLCJmaWxlIjoicGljay1sYXllcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCBnbENvbnRleHRXaXRoU3RhdGV9IGZyb20gJ2x1bWEuZ2wnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5leHBvcnQgZnVuY3Rpb24gcGlja0xheWVycyhnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIHVuaWZvcm1zID0ge30sXG4gIHgsXG4gIHksXG4gIG1vZGVcbn0pIHtcbiAgLy8gQ29udmVydCBmcm9tIGNhbnZhcyB0b3AtbGVmdCB0byBXZWJHTCBib3R0b20tbGVmdCBjb29yZGluYXRlc1xuICAvLyBBbmQgY29tcGVuc2F0ZSBmb3IgcGl4ZWxSYXRpb1xuICBjb25zdCBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgY29uc3QgZGV2aWNlWCA9IHggKiBwaXhlbFJhdGlvO1xuICBjb25zdCBkZXZpY2VZID0gZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvO1xuXG4gIC8vIFRPRE8gLSBqdXN0IHJldHVybiBnbENvbnRleHRXaXRoU3RhdGUgb25jZSBsdW1hIHVwZGF0ZXNcbiAgY29uc3QgcGlja2VkSW5mb3MgPSBbXTtcblxuICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgc2Npc3NvciB0ZXN0IGFuZCBmYm8gYmluZGluZ3MgaW4gY2FzZSBvZiBleGNlcHRpb25zXG4gIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb25lIHBpeGVsLCBubyBuZWVkIHRvIHJlbmRlciBhbnl0aGluZyBlbHNlXG4gIGdsQ29udGV4dFdpdGhTdGF0ZShnbCwge1xuICAgIGZyYW1lQnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIGZyYW1lYnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIHNjaXNzb3JUZXN0OiB7eDogZGV2aWNlWCwgeTogZGV2aWNlWSwgdzogMSwgaDogMX1cbiAgfSwgKCkgPT4ge1xuICAgIGxldCB6T3JkZXIgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlICYmIGxheWVyLnByb3BzLnBpY2thYmxlKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBmcmFtZSBidWZmZXIsIHJlbmRlciBhbmQgc2FtcGxlXG4gICAgICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGNyZWF0ZUluZm8oe1xuICAgICAgICAgIGxheWVyLFxuICAgICAgICAgIHBpeGVsOiBbeCwgeV0sXG4gICAgICAgICAgZGV2aWNlUGl4ZWw6IFtkZXZpY2VYLCBkZXZpY2VZXSxcbiAgICAgICAgICBwaXhlbFJhdGlvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheWVyLnBpY2tMYXllcih7XG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICBwaWNrRW5hYmxlVW5pZm9ybXM6IHtyZW5kZXJQaWNraW5nQnVmZmVyOiAxLCBwaWNraW5nRW5hYmxlZDogMX0sXG4gICAgICAgICAgcGlja0Rpc2FibGVVbmlmb3Jtczoge3JlbmRlclBpY2tpbmdCdWZmZXI6IDAsIHBpY2tpbmdFbmFibGVkOiAwfSxcbiAgICAgICAgICBkZXZpY2VYLCBkZXZpY2VZLFxuICAgICAgICAgIG1vZGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGluZm8uaW5kZXggPj0gMCkge1xuICAgICAgICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcbiAgICAgICAgICBpbmZvLnpPcmRlciA9IHpPcmRlcisrO1xuICAgICAgICAgIC8vIElmIHByb3BzLmRhdGEgaXMgYW4gaW5kZXhhYmxlIGFycmF5LCBnZXQgdGhlIG9iamVjdFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxheWVyLnByb3BzLmRhdGEpKSB7XG4gICAgICAgICAgICBpbmZvLm9iamVjdCA9IGxheWVyLnByb3BzLmRhdGFbaW5mby5pbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGlja2VkSW5mb3MucHVzaChpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIENhbGxpbmcgY2FsbGJhY2tzIGNhbiBoYXZlIGFzeW5jIGludGVyYWN0aW9ucyB3aXRoIFJlYWN0XG4gIC8vIHdoaWNoIG51bGxpZmllcyBsYXllci5zdGF0ZS5cbiAgY29uc3QgdW5oYW5kbGVkUGlja0luZm9zID0gW107XG4gIGZvciAoY29uc3QgaW5mbyBvZiBwaWNrZWRJbmZvcykge1xuICAgIGxldCBoYW5kbGVkID0gbnVsbDtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdjbGljayc6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uQ2xpY2soaW5mbyk7IGJyZWFrO1xuICAgIGNhc2UgJ2hvdmVyJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25Ib3ZlcihpbmZvKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBpY2sgdHlwZScpO1xuICAgIH1cblxuICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgdW5oYW5kbGVkUGlja0luZm9zLnB1c2goaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHtcbiAgaW5mbyxcbiAgbGF5ZXIsXG4gIHBpeGVsLFxuICBkZXZpY2VQaXhlbCxcbiAgcGl4ZWxSYXRpb1xufSkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBsYXllcixcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbCxcbiAgICBkZXZpY2VQaXhlbCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIGxuZ0xhdDogbGF5ZXIudW5wcm9qZWN0KHBpeGVsKVxuICB9O1xufVxuIl19