'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.COORDINATE_SYSTEM = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class; // View and Projection Matrix calculations for mapbox-js style
// map view properties
//
// ATTRIBUTION:
// Projection matrix creation are intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl.
// See: transform.js in https://github.com/mapbox/mapbox-gl-js

// gl-matrix is a large dependency for a small module.
// However since it is used by mapbox etc, it should already be present
// in most target application bundles.


var _glMatrix = require('gl-matrix');

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

// CONSTANTS

var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE / (2 * PI);

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

// EXPORTS

var COORDINATE_SYSTEM = exports.COORDINATE_SYSTEM = {
  // Positions are interpreted as [lng,lat,elevation], distances as meters
  LNGLAT: 1.0,
  // Positions are interpreted as meter offsets, distances as meters
  METERS: 2.0,
  // Positions and distances are not transformed
  IDENTITY: 0.0
};

var Viewport = (_class = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        mercatorEnabled = _ref.mercatorEnabled;

    _classCallCheck(this, Viewport);

    // Viewport - support undefined arguments
    /* eslint-disable max-len */
    this.width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    this.height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    this.zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    this.latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    this.longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    this.bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    this.pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    this.altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;
    this.mercatorEnabled = mercatorEnabled !== undefined ? mercatorEnabled : true;
    /* eslint-enable max-len */

    // Silently allow apps to send in 0,0
    this.width = this.width || 1;
    this.height = this.height || 1;

    this._initialize();

    // Object.seal(this);
    // Object.freeze(this);
  }
  /* eslint-enable complexity */

  /**
   * Projects latitude and longitude to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */


  _createClass(Viewport, [{
    key: 'project',
    value: function project(lngLatZ) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;

      var _ref3 = this.mercatorEnabled || this.mercator ? this.projectFlat(lngLatZ) : lngLatZ,
          _ref4 = _slicedToArray(_ref3, 2),
          X = _ref4[0],
          Y = _ref4[1];

      var v = [X, Y, lngLatZ[2] || 0, 1];

      // vec4.sub(v, v, [this.centerX, this.centerY, 0, 0]);
      _glMatrix.vec4.transformMat4(v, v, this.pixelProjectionMatrix);
      // Divide by w
      var scale = 1 / v[3];
      _glMatrix.vec4.multiply(v, v, [scale, scale, scale, scale]);
      var x = v[0],
          y = v[1],
          z = v[2];
      // const y2 = topLeft ? this.height - 1 - y : y;

      var y2 = topLeft ? this.height - y : y;
      return lngLatZ.length === 2 ? [x, y2] : [x, y2, z];
    }

    /**
     * Unproject pixel coordinates on screen onto [lon, lat] on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$topLeft = _ref5.topLeft,
          topLeft = _ref5$topLeft === undefined ? true : _ref5$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          _xyz$ = _xyz[0],
          x = _xyz$ === undefined ? 0 : _xyz$,
          _xyz$2 = _xyz[1],
          y = _xyz$2 === undefined ? 0 : _xyz$2,
          _xyz$3 = _xyz[2],
          z = _xyz$3 === undefined ? 0 : _xyz$3;
      // const y2 = topLeft ? this.height - 1 - y : y;


      var y2 = topLeft ? this.height - y : y;
      var v = [x, y2, z, 1];
      _glMatrix.vec4.transformMat4(v, v, this.pixelUnprojectionMatrix);
      var scale = 1 / v[3];
      _glMatrix.vec4.multiply(v, v, [scale, scale, scale, scale]);

      var _unprojectFlat = this.unprojectFlat(v),
          _unprojectFlat2 = _slicedToArray(_unprojectFlat, 2),
          x0 = _unprojectFlat2[0],
          y0 = _unprojectFlat2[1];

      var z0 = v[2];

      return xyz.length === 2 ? [x0, y0] : [x0, y0, z0];
    }

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     *
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref6) {
      var _ref7 = _slicedToArray(_ref6, 2),
          lng = _ref7[0],
          lat = _ref7[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      scale = scale * WORLD_SCALE;
      var lambda2 = lng * DEGREES_TO_RADIANS;
      var phi2 = lat * DEGREES_TO_RADIANS;
      var x = scale * (lambda2 + PI);
      var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));
      return [x, y];
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(_ref8) {
      var _ref9 = _slicedToArray(_ref8, 2),
          x = _ref9[0],
          y = _ref9[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      scale = scale * WORLD_SCALE;
      var lambda2 = x / scale - PI;
      var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale)) - PI_4);
      return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
    }
  }, {
    key: 'getProjections',
    value: function getProjections() {
      return {
        pixelProjectionMatrix: this.pixelProjectionMatrix,
        pixelUnprojectionMatrix: this.pixelUnprojectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix
      };
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return {
        pixelsPerMeter: this.pixelsPerMeter,
        metersPerPixel: this.metersPerPixel
      };
    }

    // INTERNAL METHODS

    /* eslint-disable max-statements */

  }, {
    key: '_initialize',
    value: function _initialize() {
      // Scale
      this.scale = Math.pow(2, this.zoom);
      this.worldSize = TILE_SIZE * this.scale;
      this.tileZoom = Math.floor(this.zoom);
      this.zoomFraction = this.zoom - Math.floor(this.zoom);

      // Bearing
      this.bearingRadians = this.bearing / 180 * Math.PI;
      this.bearingRotationMatrix = _glMatrix.mat2.create();
      _glMatrix.mat2.rotate(this.bearingRotationMatrix, this.bearingRotationMatrix, this.bearing);

      // Pitch
      this.originalPitch = this.pitch;
      this.pitch = Math.min(60, this.pitch);
      this.pitchRadians = this.pitch / 180 * Math.PI;

      // Altitude
      this.originalAltitude = this.altitude;
      this.altitude = Math.max(0.75, this.altitude);

      // Center x, y
      this.center = this.projectFlat([this.longitude, this.latitude]);
      this.centerX = this.center[0];
      this.centerY = this.center[1];

      // Find the distance from the center point to the center top
      // in altitude units using law of sines.
      this.halfFov = Math.atan(0.5 / this.altitude);
      this.topHalfSurfaceDistance = Math.sin(this.halfFov) * this.altitude / Math.sin(Math.PI / 2 - this.pitchRadians - this.halfFov);

      // Calculate z value of the farthest fragment that should be rendered.
      this.farZ = Math.cos(Math.PI / 2 - this.pitchRadians) * this.topHalfSurfaceDistance + this.altitude;

      // Calculate matrices and scales needed for projection
      this._calculateDistanceScales();
      this._calculateTransformationMatrices();
    }
    /* eslint-enable max-statements */

    /**
     * Calculate distance scales in meters around current lat/lon, both for
     * degrees and pixels.
     * In mercator projection mode, the distance scales vary significantly
     * with latitude.
     */

  }, {
    key: '_calculateDistanceScales',
    value: function _calculateDistanceScales() {
      // Approximately 111km per degree at equator
      var METERS_PER_DEGREE = 111000;
      var latitude = this.latitude,
          longitude = this.longitude;


      var latCosine = Math.cos(latitude * Math.PI / 180);

      var metersPerDegree = METERS_PER_DEGREE * latCosine;

      // Calculate number of pixels occupied by one degree longitude
      // around current lat/lon
      var pixelsPerDegreeX = _glMatrix.vec2.distance(this.projectFlat([longitude + 0.5, latitude]), this.projectFlat([longitude - 0.5, latitude]));
      // Calculate number of pixels occupied by one degree latitude
      // around current lat/lon
      var pixelsPerDegreeY = _glMatrix.vec2.distance(this.projectFlat([longitude, latitude + 0.5]), this.projectFlat([longitude, latitude - 0.5]));

      var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
      var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
      var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;

      // const scale = 0.95;
      // const pixelsPerMeter = [
      //   pixelsPerMeterX * scale, pixelsPerMeterY * scale, pixelsPerMeterZ * scale
      // ];
      var altPixelsPerMeter = this.worldSize / (4e7 * latCosine);
      var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
      var metersPerPixel = [1 / pixelsPerMeterX, 1 / pixelsPerMeterY, 1 / pixelsPerMeterZ];

      // Main results, used for scaling offsets
      this.pixelsPerMeter = pixelsPerMeter;
      // Additional results
      this.metersPerPixel = metersPerPixel;
      // metersPerDegree,
      // degreesPerMeter: 1 / metersPerDegree
    }

    // Note: As usual, matrix operation orders should be read in reverse
    // since vectors will be multiplied in from the right during transformation
    /* eslint-disable max-statements */

  }, {
    key: '_calculateTransformationMatrices',
    value: function _calculateTransformationMatrices() {
      // PROJECTION MATRIX: PROJECTS FROM CAMERA SPACE TO CLIPSPACE
      /* eslint-disable no-inline-comments */
      this.projectionMatrix = _glMatrix.mat4.perspective(this._createMat4(), 2 * Math.atan(this.height / 2 / this.altitude), // fov in radians
      this.width / this.height, // aspect ratio
      0.1, // near plane
      this.farZ * 10.0 // far plane
      );
      /* eslint-enable no-inline-comments */

      // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
      var vm = this._createMat4();

      // Move camera to altitude
      _glMatrix.mat4.translate(vm, vm, [0, 0, -this.altitude]);

      // After the rotateX, z values are in pixel units. Convert them to
      // altitude units. 1 altitude unit = the screen height.
      _glMatrix.mat4.scale(vm, vm, [1, -1, 1 / this.height]);

      // Rotate by bearing, and then by pitch (which tilts the view)
      _glMatrix.mat4.rotateX(vm, vm, this.pitchRadians);
      _glMatrix.mat4.rotateZ(vm, vm, -this.bearingRadians);

      this.viewMatrix = this._createMat4();
      _glMatrix.mat4.translate(this.viewMatrix, vm, [-this.centerX, -this.centerY, 0]);

      var vpm = this._createMat4();
      _glMatrix.mat4.multiply(vpm, vpm, this.projectionMatrix);
      _glMatrix.mat4.multiply(vpm, vpm, this.viewMatrix);

      this.viewProjectionMatrix = vpm;

      // PIXEL PROJECTION MATRIX
      var m = this._createMat4();

      // Scale with viewport window's width and height in pixels
      _glMatrix.mat4.scale(m, m, [this.width, this.height, 1]);
      // Convert to (0, 1)
      _glMatrix.mat4.translate(m, m, [0.5, 0.5, 0]);
      _glMatrix.mat4.scale(m, m, [0.5, 0.5, 0]);
      // Project to clip space (-1, 1)
      _glMatrix.mat4.multiply(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      var mInverse = this._createMat4();
      _glMatrix.mat4.invert(mInverse, m);
      this.pixelUnprojectionMatrix = mInverse;
    }
    /* eslint-enable max-statements */

    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     *
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */

  }, {
    key: '_calculatePixelProjectionMatrices',
    value: function _calculatePixelProjectionMatrices() {
      var m = this._createMat4();

      // Scale with viewport window's width and height in pixels
      _glMatrix.mat4.scale(m, m, [this.width, this.height, 1]);
      // Convert to (0, 1)
      _glMatrix.mat4.translate(m, m, [0.5, 0.5, 0]);
      _glMatrix.mat4.scale(m, m, [0.5, 0.5, 0]);
      // Project to clip space (-1, 1)
      _glMatrix.mat4.multiply(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      var mInverse = this._createMat4();
      _glMatrix.mat4.invert(mInverse, m);
      this.pixelUnprojectionMatrix = mInverse;
    }

    // Helper, avoids low-precision 32 bit matrices from mat4.create();

  }, {
    key: '_createMat4',
    value: function _createMat4() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
  }]);

  return Viewport;
}(), (_applyDecoratedDescriptor(_class.prototype, 'project', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'project'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'unproject', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'unproject'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'projectFlat', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'projectFlat'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'unprojectFlat', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'unprojectFlat'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'getProjections', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getProjections'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'getDistanceScales', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getDistanceScales'), _class.prototype)), _class);
exports.default = Viewport;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wZXJzcGVjdGl2ZS12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJQSSIsIk1hdGgiLCJQSV80IiwiREVHUkVFU19UT19SQURJQU5TIiwiUkFESUFOU19UT19ERUdSRUVTIiwiVElMRV9TSVpFIiwiV09STERfU0NBTEUiLCJERUZBVUxUX01BUF9TVEFURSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwiQ09PUkRJTkFURV9TWVNURU0iLCJMTkdMQVQiLCJNRVRFUlMiLCJJREVOVElUWSIsIlZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJtZXJjYXRvckVuYWJsZWQiLCJ1bmRlZmluZWQiLCJfaW5pdGlhbGl6ZSIsImxuZ0xhdFoiLCJ0b3BMZWZ0IiwibWVyY2F0b3IiLCJwcm9qZWN0RmxhdCIsIlgiLCJZIiwidiIsInRyYW5zZm9ybU1hdDQiLCJwaXhlbFByb2plY3Rpb25NYXRyaXgiLCJzY2FsZSIsIm11bHRpcGx5IiwieCIsInkiLCJ6IiwieTIiLCJsZW5ndGgiLCJ4eXoiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsInVucHJvamVjdEZsYXQiLCJ4MCIsInkwIiwiejAiLCJsbmciLCJsYXQiLCJsYW1iZGEyIiwicGhpMiIsImxvZyIsInRhbiIsImF0YW4iLCJleHAiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsInZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwicGl4ZWxzUGVyTWV0ZXIiLCJtZXRlcnNQZXJQaXhlbCIsInBvdyIsIndvcmxkU2l6ZSIsInRpbGVab29tIiwiZmxvb3IiLCJ6b29tRnJhY3Rpb24iLCJiZWFyaW5nUmFkaWFucyIsImJlYXJpbmdSb3RhdGlvbk1hdHJpeCIsImNyZWF0ZSIsInJvdGF0ZSIsIm9yaWdpbmFsUGl0Y2giLCJtaW4iLCJwaXRjaFJhZGlhbnMiLCJvcmlnaW5hbEFsdGl0dWRlIiwibWF4IiwiY2VudGVyIiwiY2VudGVyWCIsImNlbnRlclkiLCJoYWxmRm92IiwidG9wSGFsZlN1cmZhY2VEaXN0YW5jZSIsInNpbiIsImZhcloiLCJjb3MiLCJfY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMiLCJfY2FsY3VsYXRlVHJhbnNmb3JtYXRpb25NYXRyaWNlcyIsIk1FVEVSU19QRVJfREVHUkVFIiwibGF0Q29zaW5lIiwibWV0ZXJzUGVyRGVncmVlIiwicGl4ZWxzUGVyRGVncmVlWCIsImRpc3RhbmNlIiwicGl4ZWxzUGVyRGVncmVlWSIsInBpeGVsc1Blck1ldGVyWCIsInBpeGVsc1Blck1ldGVyWSIsInBpeGVsc1Blck1ldGVyWiIsImFsdFBpeGVsc1Blck1ldGVyIiwicGVyc3BlY3RpdmUiLCJfY3JlYXRlTWF0NCIsInZtIiwidHJhbnNsYXRlIiwicm90YXRlWCIsInJvdGF0ZVoiLCJ2cG0iLCJtIiwibUludmVyc2UiLCJpbnZlcnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzJCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUVBLElBQU1BLEtBQUtDLEtBQUtELEVBQWhCO0FBQ0EsSUFBTUUsT0FBT0YsS0FBSyxDQUFsQjtBQUNBLElBQU1HLHFCQUFxQkgsS0FBSyxHQUFoQztBQUNBLElBQU1JLHFCQUFxQixNQUFNSixFQUFqQztBQUNBLElBQU1LLFlBQVksR0FBbEI7QUFDQSxJQUFNQyxjQUFjRCxhQUFhLElBQUlMLEVBQWpCLENBQXBCOztBQUVBLElBQU1PLG9CQUFvQjtBQUN4QkMsWUFBVSxFQURjO0FBRXhCQyxhQUFXLENBQUMsR0FGWTtBQUd4QkMsUUFBTSxFQUhrQjtBQUl4QkMsU0FBTyxDQUppQjtBQUt4QkMsV0FBUyxDQUxlO0FBTXhCQyxZQUFVO0FBTmMsQ0FBMUI7O0FBU0E7O0FBRU8sSUFBTUMsZ0RBQW9CO0FBQy9CO0FBQ0FDLFVBQVEsR0FGdUI7QUFHL0I7QUFDQUMsVUFBUSxHQUp1QjtBQUsvQjtBQUNBQyxZQUFVO0FBTnFCLENBQTFCOztJQVNjQyxRO0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTtBQUNBLHNCQVdRO0FBQUEsbUZBQUosRUFBSTtBQUFBLFFBVE5DLEtBU00sUUFUTkEsS0FTTTtBQUFBLFFBUk5DLE1BUU0sUUFSTkEsTUFRTTtBQUFBLFFBUE5aLFFBT00sUUFQTkEsUUFPTTtBQUFBLFFBTk5DLFNBTU0sUUFOTkEsU0FNTTtBQUFBLFFBTE5DLElBS00sUUFMTkEsSUFLTTtBQUFBLFFBSk5DLEtBSU0sUUFKTkEsS0FJTTtBQUFBLFFBSE5DLE9BR00sUUFITkEsT0FHTTtBQUFBLFFBRk5DLFFBRU0sUUFGTkEsUUFFTTtBQUFBLFFBRE5RLGVBQ00sUUFETkEsZUFDTTs7QUFBQTs7QUFDTjtBQUNBO0FBQ0EsU0FBS0YsS0FBTCxHQUFhQSxVQUFVRyxTQUFWLEdBQXNCSCxLQUF0QixHQUE4Qlosa0JBQWtCWSxLQUE3RDtBQUNBLFNBQUtDLE1BQUwsR0FBY0EsV0FBV0UsU0FBWCxHQUF1QkYsTUFBdkIsR0FBZ0NiLGtCQUFrQmEsTUFBaEU7QUFDQSxTQUFLVixJQUFMLEdBQVlBLFNBQVNZLFNBQVQsR0FBcUJaLElBQXJCLEdBQTRCSCxrQkFBa0JHLElBQTFEO0FBQ0EsU0FBS0YsUUFBTCxHQUFnQkEsYUFBYWMsU0FBYixHQUF5QmQsUUFBekIsR0FBb0NELGtCQUFrQkMsUUFBdEU7QUFDQSxTQUFLQyxTQUFMLEdBQWlCQSxjQUFjYSxTQUFkLEdBQTBCYixTQUExQixHQUFzQ0Ysa0JBQWtCRSxTQUF6RTtBQUNBLFNBQUtHLE9BQUwsR0FBZUEsWUFBWVUsU0FBWixHQUF3QlYsT0FBeEIsR0FBa0NMLGtCQUFrQkssT0FBbkU7QUFDQSxTQUFLRCxLQUFMLEdBQWFBLFVBQVVXLFNBQVYsR0FBc0JYLEtBQXRCLEdBQThCSixrQkFBa0JJLEtBQTdEO0FBQ0EsU0FBS0UsUUFBTCxHQUFnQkEsYUFBYVMsU0FBYixHQUF5QlQsUUFBekIsR0FBb0NOLGtCQUFrQk0sUUFBdEU7QUFDQSxTQUFLUSxlQUFMLEdBQXVCQSxvQkFBb0JDLFNBQXBCLEdBQWdDRCxlQUFoQyxHQUFrRCxJQUF6RTtBQUNBOztBQUVBO0FBQ0EsU0FBS0YsS0FBTCxHQUFhLEtBQUtBLEtBQUwsSUFBYyxDQUEzQjtBQUNBLFNBQUtDLE1BQUwsR0FBYyxLQUFLQSxNQUFMLElBQWUsQ0FBN0I7O0FBRUEsU0FBS0csV0FBTDs7QUFFQTtBQUNBO0FBQ0Q7QUFDRDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFhUUMsTyxFQUFnQztBQUFBLHNGQUFKLEVBQUk7QUFBQSxnQ0FBdEJDLE9BQXNCO0FBQUEsVUFBdEJBLE9BQXNCLGlDQUFaLElBQVk7O0FBQUEsa0JBQ3ZCLEtBQUtKLGVBQUwsSUFBd0IsS0FBS0ssUUFBN0IsR0FDYixLQUFLQyxXQUFMLENBQWlCSCxPQUFqQixDQURhLEdBQ2VBLE9BRlE7QUFBQTtBQUFBLFVBQy9CSSxDQUQrQjtBQUFBLFVBQzVCQyxDQUQ0Qjs7QUFHdEMsVUFBTUMsSUFBSSxDQUFDRixDQUFELEVBQUlDLENBQUosRUFBT0wsUUFBUSxDQUFSLEtBQWMsQ0FBckIsRUFBd0IsQ0FBeEIsQ0FBVjs7QUFFQTtBQUNBLHFCQUFLTyxhQUFMLENBQW1CRCxDQUFuQixFQUFzQkEsQ0FBdEIsRUFBeUIsS0FBS0UscUJBQTlCO0FBQ0E7QUFDQSxVQUFNQyxRQUFRLElBQUlILEVBQUUsQ0FBRixDQUFsQjtBQUNBLHFCQUFLSSxRQUFMLENBQWNKLENBQWQsRUFBaUJBLENBQWpCLEVBQW9CLENBQUNHLEtBQUQsRUFBUUEsS0FBUixFQUFlQSxLQUFmLEVBQXNCQSxLQUF0QixDQUFwQjtBQVRzQyxVQVUvQkUsQ0FWK0IsR0FVcEJMLENBVm9CO0FBQUEsVUFVNUJNLENBVjRCLEdBVXBCTixDQVZvQjtBQUFBLFVBVXpCTyxDQVZ5QixHQVVwQlAsQ0FWb0I7QUFXdEM7O0FBQ0EsVUFBTVEsS0FBS2IsVUFBVSxLQUFLTCxNQUFMLEdBQWNnQixDQUF4QixHQUE0QkEsQ0FBdkM7QUFDQSxhQUFPWixRQUFRZSxNQUFSLEtBQW1CLENBQW5CLEdBQXVCLENBQUNKLENBQUQsRUFBSUcsRUFBSixDQUF2QixHQUFpQyxDQUFDSCxDQUFELEVBQUlHLEVBQUosRUFBUUQsQ0FBUixDQUF4QztBQUNEOztBQUVEOzs7Ozs7Ozs7OzhCQVFVRyxHLEVBQTRCO0FBQUEsc0ZBQUosRUFBSTtBQUFBLGdDQUF0QmYsT0FBc0I7QUFBQSxVQUF0QkEsT0FBc0IsaUNBQVosSUFBWTs7QUFBQSxnQ0FDTmUsR0FETTtBQUFBO0FBQUEsVUFDN0JMLENBRDZCLHlCQUN6QixDQUR5QjtBQUFBO0FBQUEsVUFDdEJDLENBRHNCLDBCQUNsQixDQURrQjtBQUFBO0FBQUEsVUFDZkMsQ0FEZSwwQkFDWCxDQURXO0FBRXBDOzs7QUFDQSxVQUFNQyxLQUFLYixVQUFVLEtBQUtMLE1BQUwsR0FBY2dCLENBQXhCLEdBQTRCQSxDQUF2QztBQUNBLFVBQU1OLElBQUksQ0FBQ0ssQ0FBRCxFQUFJRyxFQUFKLEVBQVFELENBQVIsRUFBVyxDQUFYLENBQVY7QUFDQSxxQkFBS04sYUFBTCxDQUFtQkQsQ0FBbkIsRUFBc0JBLENBQXRCLEVBQXlCLEtBQUtXLHVCQUE5QjtBQUNBLFVBQU1SLFFBQVEsSUFBSUgsRUFBRSxDQUFGLENBQWxCO0FBQ0EscUJBQUtJLFFBQUwsQ0FBY0osQ0FBZCxFQUFpQkEsQ0FBakIsRUFBb0IsQ0FBQ0csS0FBRCxFQUFRQSxLQUFSLEVBQWVBLEtBQWYsRUFBc0JBLEtBQXRCLENBQXBCOztBQVBvQywyQkFRbkIsS0FBS1MsYUFBTCxDQUFtQlosQ0FBbkIsQ0FSbUI7QUFBQTtBQUFBLFVBUTdCYSxFQVI2QjtBQUFBLFVBUXpCQyxFQVJ5Qjs7QUFBQSxVQVN6QkMsRUFUeUIsR0FTbkJmLENBVG1COztBQVVwQyxhQUFPVSxJQUFJRCxNQUFKLEtBQWUsQ0FBZixHQUFtQixDQUFDSSxFQUFELEVBQUtDLEVBQUwsQ0FBbkIsR0FBOEIsQ0FBQ0QsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLEVBQVQsQ0FBckM7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozt1Q0FXNEM7QUFBQTtBQUFBLFVBQS9CQyxHQUErQjtBQUFBLFVBQTFCQyxHQUEwQjs7QUFBQSxVQUFwQmQsS0FBb0IsdUVBQVosS0FBS0EsS0FBTzs7QUFDMUNBLGNBQVFBLFFBQVEzQixXQUFoQjtBQUNBLFVBQU0wQyxVQUFVRixNQUFNM0Msa0JBQXRCO0FBQ0EsVUFBTThDLE9BQU9GLE1BQU01QyxrQkFBbkI7QUFDQSxVQUFNZ0MsSUFBSUYsU0FBU2UsVUFBVWhELEVBQW5CLENBQVY7QUFDQSxVQUFNb0MsSUFBSUgsU0FBU2pDLEtBQUtDLEtBQUtpRCxHQUFMLENBQVNqRCxLQUFLa0QsR0FBTCxDQUFTakQsT0FBTytDLE9BQU8sR0FBdkIsQ0FBVCxDQUFkLENBQVY7QUFDQSxhQUFPLENBQUNkLENBQUQsRUFBSUMsQ0FBSixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozt5Q0FVMEM7QUFBQTtBQUFBLFVBQTNCRCxDQUEyQjtBQUFBLFVBQXhCQyxDQUF3Qjs7QUFBQSxVQUFwQkgsS0FBb0IsdUVBQVosS0FBS0EsS0FBTzs7QUFDeENBLGNBQVFBLFFBQVEzQixXQUFoQjtBQUNBLFVBQU0wQyxVQUFVYixJQUFJRixLQUFKLEdBQVlqQyxFQUE1QjtBQUNBLFVBQU1pRCxPQUFPLEtBQUtoRCxLQUFLbUQsSUFBTCxDQUFVbkQsS0FBS29ELEdBQUwsQ0FBU3JELEtBQUtvQyxJQUFJSCxLQUFsQixDQUFWLElBQXNDL0IsSUFBM0MsQ0FBYjtBQUNBLGFBQU8sQ0FBQzhDLFVBQVU1QyxrQkFBWCxFQUErQjZDLE9BQU83QyxrQkFBdEMsQ0FBUDtBQUNEOzs7cUNBR2dCO0FBQ2YsYUFBTztBQUNMNEIsK0JBQXVCLEtBQUtBLHFCQUR2QjtBQUVMUyxpQ0FBeUIsS0FBS0EsdUJBRnpCO0FBR0xhLDhCQUFzQixLQUFLQSxvQkFIdEI7QUFJTEMsb0JBQVksS0FBS0EsVUFKWjtBQUtMQywwQkFBa0IsS0FBS0E7QUFMbEIsT0FBUDtBQU9EOzs7d0NBR21CO0FBQ2xCLGFBQU87QUFDTEMsd0JBQWdCLEtBQUtBLGNBRGhCO0FBRUxDLHdCQUFnQixLQUFLQTtBQUZoQixPQUFQO0FBSUQ7O0FBRUQ7O0FBRUE7Ozs7a0NBQ2M7QUFDWjtBQUNBLFdBQUt6QixLQUFMLEdBQWFoQyxLQUFLMEQsR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLakQsSUFBakIsQ0FBYjtBQUNBLFdBQUtrRCxTQUFMLEdBQWlCdkQsWUFBWSxLQUFLNEIsS0FBbEM7QUFDQSxXQUFLNEIsUUFBTCxHQUFnQjVELEtBQUs2RCxLQUFMLENBQVcsS0FBS3BELElBQWhCLENBQWhCO0FBQ0EsV0FBS3FELFlBQUwsR0FBb0IsS0FBS3JELElBQUwsR0FBWVQsS0FBSzZELEtBQUwsQ0FBVyxLQUFLcEQsSUFBaEIsQ0FBaEM7O0FBRUE7QUFDQSxXQUFLc0QsY0FBTCxHQUFzQixLQUFLcEQsT0FBTCxHQUFlLEdBQWYsR0FBcUJYLEtBQUtELEVBQWhEO0FBQ0EsV0FBS2lFLHFCQUFMLEdBQTZCLGVBQUtDLE1BQUwsRUFBN0I7QUFDQSxxQkFBS0MsTUFBTCxDQUNFLEtBQUtGLHFCQURQLEVBQzhCLEtBQUtBLHFCQURuQyxFQUMwRCxLQUFLckQsT0FEL0Q7O0FBSUE7QUFDQSxXQUFLd0QsYUFBTCxHQUFxQixLQUFLekQsS0FBMUI7QUFDQSxXQUFLQSxLQUFMLEdBQWFWLEtBQUtvRSxHQUFMLENBQVMsRUFBVCxFQUFhLEtBQUsxRCxLQUFsQixDQUFiO0FBQ0EsV0FBSzJELFlBQUwsR0FBb0IsS0FBSzNELEtBQUwsR0FBYSxHQUFiLEdBQW1CVixLQUFLRCxFQUE1Qzs7QUFFQTtBQUNBLFdBQUt1RSxnQkFBTCxHQUF3QixLQUFLMUQsUUFBN0I7QUFDQSxXQUFLQSxRQUFMLEdBQWdCWixLQUFLdUUsR0FBTCxDQUFTLElBQVQsRUFBZSxLQUFLM0QsUUFBcEIsQ0FBaEI7O0FBRUE7QUFDQSxXQUFLNEQsTUFBTCxHQUFjLEtBQUs5QyxXQUFMLENBQWlCLENBQUMsS0FBS2xCLFNBQU4sRUFBaUIsS0FBS0QsUUFBdEIsQ0FBakIsQ0FBZDtBQUNBLFdBQUtrRSxPQUFMLEdBQWUsS0FBS0QsTUFBTCxDQUFZLENBQVosQ0FBZjtBQUNBLFdBQUtFLE9BQUwsR0FBZSxLQUFLRixNQUFMLENBQVksQ0FBWixDQUFmOztBQUVBO0FBQ0E7QUFDQSxXQUFLRyxPQUFMLEdBQWUzRSxLQUFLbUQsSUFBTCxDQUFVLE1BQU0sS0FBS3ZDLFFBQXJCLENBQWY7QUFDQSxXQUFLZ0Usc0JBQUwsR0FDRTVFLEtBQUs2RSxHQUFMLENBQVMsS0FBS0YsT0FBZCxJQUF5QixLQUFLL0QsUUFBOUIsR0FDQVosS0FBSzZFLEdBQUwsQ0FBUzdFLEtBQUtELEVBQUwsR0FBVSxDQUFWLEdBQWMsS0FBS3NFLFlBQW5CLEdBQWtDLEtBQUtNLE9BQWhELENBRkY7O0FBSUE7QUFDQSxXQUFLRyxJQUFMLEdBQVk5RSxLQUFLK0UsR0FBTCxDQUFTL0UsS0FBS0QsRUFBTCxHQUFVLENBQVYsR0FBYyxLQUFLc0UsWUFBNUIsSUFDVixLQUFLTyxzQkFESyxHQUNvQixLQUFLaEUsUUFEckM7O0FBR0E7QUFDQSxXQUFLb0Usd0JBQUw7QUFDQSxXQUFLQyxnQ0FBTDtBQUNEO0FBQ0Q7O0FBRUE7Ozs7Ozs7OzsrQ0FNMkI7QUFDekI7QUFDQSxVQUFNQyxvQkFBb0IsTUFBMUI7QUFGeUIsVUFHbEIzRSxRQUhrQixHQUdLLElBSEwsQ0FHbEJBLFFBSGtCO0FBQUEsVUFHUkMsU0FIUSxHQUdLLElBSEwsQ0FHUkEsU0FIUTs7O0FBS3pCLFVBQU0yRSxZQUFZbkYsS0FBSytFLEdBQUwsQ0FBU3hFLFdBQVdQLEtBQUtELEVBQWhCLEdBQXFCLEdBQTlCLENBQWxCOztBQUVBLFVBQU1xRixrQkFBa0JGLG9CQUFvQkMsU0FBNUM7O0FBRUE7QUFDQTtBQUNBLFVBQU1FLG1CQUFtQixlQUFLQyxRQUFMLENBQ3ZCLEtBQUs1RCxXQUFMLENBQWlCLENBQUNsQixZQUFZLEdBQWIsRUFBa0JELFFBQWxCLENBQWpCLENBRHVCLEVBRXZCLEtBQUttQixXQUFMLENBQWlCLENBQUNsQixZQUFZLEdBQWIsRUFBa0JELFFBQWxCLENBQWpCLENBRnVCLENBQXpCO0FBSUE7QUFDQTtBQUNBLFVBQU1nRixtQkFBbUIsZUFBS0QsUUFBTCxDQUN2QixLQUFLNUQsV0FBTCxDQUFpQixDQUFDbEIsU0FBRCxFQUFZRCxXQUFXLEdBQXZCLENBQWpCLENBRHVCLEVBRXZCLEtBQUttQixXQUFMLENBQWlCLENBQUNsQixTQUFELEVBQVlELFdBQVcsR0FBdkIsQ0FBakIsQ0FGdUIsQ0FBekI7O0FBS0EsVUFBTWlGLGtCQUFrQkgsbUJBQW1CRCxlQUEzQztBQUNBLFVBQU1LLGtCQUFrQkYsbUJBQW1CSCxlQUEzQztBQUNBLFVBQU1NLGtCQUFrQixDQUFDRixrQkFBa0JDLGVBQW5CLElBQXNDLENBQTlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBTUUsb0JBQW9CLEtBQUtoQyxTQUFMLElBQWtCLE1BQU13QixTQUF4QixDQUExQjtBQUNBLFVBQU0zQixpQkFBaUIsQ0FDckJtQyxpQkFEcUIsRUFDRkEsaUJBREUsRUFDaUJBLGlCQURqQixDQUF2QjtBQUdBLFVBQU1sQyxpQkFBaUIsQ0FDckIsSUFBSStCLGVBRGlCLEVBQ0EsSUFBSUMsZUFESixFQUNxQixJQUFJQyxlQUR6QixDQUF2Qjs7QUFJQTtBQUNBLFdBQUtsQyxjQUFMLEdBQXNCQSxjQUF0QjtBQUNBO0FBQ0EsV0FBS0MsY0FBTCxHQUFzQkEsY0FBdEI7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOzs7O3VEQUNtQztBQUNqQztBQUNBO0FBQ0EsV0FBS0YsZ0JBQUwsR0FBd0IsZUFBS3FDLFdBQUwsQ0FDdEIsS0FBS0MsV0FBTCxFQURzQixFQUV0QixJQUFJN0YsS0FBS21ELElBQUwsQ0FBVyxLQUFLaEMsTUFBTCxHQUFjLENBQWYsR0FBb0IsS0FBS1AsUUFBbkMsQ0FGa0IsRUFFNEI7QUFDbEQsV0FBS00sS0FBTCxHQUFhLEtBQUtDLE1BSEksRUFHNEI7QUFDbEQsU0FKc0IsRUFJNEI7QUFDbEQsV0FBSzJELElBQUwsR0FBWSxJQUxVLENBSzRCO0FBTDVCLE9BQXhCO0FBT0E7O0FBRUE7QUFDQSxVQUFNZ0IsS0FBSyxLQUFLRCxXQUFMLEVBQVg7O0FBRUE7QUFDQSxxQkFBS0UsU0FBTCxDQUFlRCxFQUFmLEVBQW1CQSxFQUFuQixFQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQyxLQUFLbEYsUUFBYixDQUF2Qjs7QUFFQTtBQUNBO0FBQ0EscUJBQUtvQixLQUFMLENBQVc4RCxFQUFYLEVBQWVBLEVBQWYsRUFBbUIsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsSUFBSSxLQUFLM0UsTUFBakIsQ0FBbkI7O0FBRUE7QUFDQSxxQkFBSzZFLE9BQUwsQ0FBYUYsRUFBYixFQUFpQkEsRUFBakIsRUFBcUIsS0FBS3pCLFlBQTFCO0FBQ0EscUJBQUs0QixPQUFMLENBQWFILEVBQWIsRUFBaUJBLEVBQWpCLEVBQXFCLENBQUMsS0FBSy9CLGNBQTNCOztBQUVBLFdBQUtULFVBQUwsR0FBa0IsS0FBS3VDLFdBQUwsRUFBbEI7QUFDQSxxQkFBS0UsU0FBTCxDQUFlLEtBQUt6QyxVQUFwQixFQUFnQ3dDLEVBQWhDLEVBQW9DLENBQUMsQ0FBQyxLQUFLckIsT0FBUCxFQUFnQixDQUFDLEtBQUtDLE9BQXRCLEVBQStCLENBQS9CLENBQXBDOztBQUVBLFVBQU13QixNQUFNLEtBQUtMLFdBQUwsRUFBWjtBQUNBLHFCQUFLNUQsUUFBTCxDQUFjaUUsR0FBZCxFQUFtQkEsR0FBbkIsRUFBd0IsS0FBSzNDLGdCQUE3QjtBQUNBLHFCQUFLdEIsUUFBTCxDQUFjaUUsR0FBZCxFQUFtQkEsR0FBbkIsRUFBd0IsS0FBSzVDLFVBQTdCOztBQUVBLFdBQUtELG9CQUFMLEdBQTRCNkMsR0FBNUI7O0FBRUE7QUFDQSxVQUFNQyxJQUFJLEtBQUtOLFdBQUwsRUFBVjs7QUFFQTtBQUNBLHFCQUFLN0QsS0FBTCxDQUFXbUUsQ0FBWCxFQUFjQSxDQUFkLEVBQWlCLENBQUMsS0FBS2pGLEtBQU4sRUFBYSxLQUFLQyxNQUFsQixFQUEwQixDQUExQixDQUFqQjtBQUNBO0FBQ0EscUJBQUs0RSxTQUFMLENBQWVJLENBQWYsRUFBa0JBLENBQWxCLEVBQXFCLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxDQUFYLENBQXJCO0FBQ0EscUJBQUtuRSxLQUFMLENBQVdtRSxDQUFYLEVBQWNBLENBQWQsRUFBaUIsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLENBQVgsQ0FBakI7QUFDQTtBQUNBLHFCQUFLbEUsUUFBTCxDQUFja0UsQ0FBZCxFQUFpQkEsQ0FBakIsRUFBb0IsS0FBSzlDLG9CQUF6QjtBQUNBLFdBQUt0QixxQkFBTCxHQUE2Qm9FLENBQTdCOztBQUVBLFVBQU1DLFdBQVcsS0FBS1AsV0FBTCxFQUFqQjtBQUNBLHFCQUFLUSxNQUFMLENBQVlELFFBQVosRUFBc0JELENBQXRCO0FBQ0EsV0FBSzNELHVCQUFMLEdBQStCNEQsUUFBL0I7QUFDRDtBQUNEOztBQUVBOzs7Ozs7Ozs7Ozs7O3dEQVVvQztBQUNsQyxVQUFNRCxJQUFJLEtBQUtOLFdBQUwsRUFBVjs7QUFFQTtBQUNBLHFCQUFLN0QsS0FBTCxDQUFXbUUsQ0FBWCxFQUFjQSxDQUFkLEVBQWlCLENBQUMsS0FBS2pGLEtBQU4sRUFBYSxLQUFLQyxNQUFsQixFQUEwQixDQUExQixDQUFqQjtBQUNBO0FBQ0EscUJBQUs0RSxTQUFMLENBQWVJLENBQWYsRUFBa0JBLENBQWxCLEVBQXFCLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxDQUFYLENBQXJCO0FBQ0EscUJBQUtuRSxLQUFMLENBQVdtRSxDQUFYLEVBQWNBLENBQWQsRUFBaUIsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLENBQVgsQ0FBakI7QUFDQTtBQUNBLHFCQUFLbEUsUUFBTCxDQUFja0UsQ0FBZCxFQUFpQkEsQ0FBakIsRUFBb0IsS0FBSzlDLG9CQUF6QjtBQUNBLFdBQUt0QixxQkFBTCxHQUE2Qm9FLENBQTdCOztBQUVBLFVBQU1DLFdBQVcsS0FBS1AsV0FBTCxFQUFqQjtBQUNBLHFCQUFLUSxNQUFMLENBQVlELFFBQVosRUFBc0JELENBQXRCO0FBQ0EsV0FBSzNELHVCQUFMLEdBQStCNEQsUUFBL0I7QUFDRDs7QUFFRDs7OztrQ0FDYztBQUNaLGFBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUFQO0FBQ0Q7Ozs7O2tCQTNXa0JuRixRIiwiZmlsZSI6InBlcnNwZWN0aXZlLXZpZXdwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVmlldyBhbmQgUHJvamVjdGlvbiBNYXRyaXggY2FsY3VsYXRpb25zIGZvciBtYXBib3gtanMgc3R5bGVcbi8vIG1hcCB2aWV3IHByb3BlcnRpZXNcbi8vXG4vLyBBVFRSSUJVVElPTjpcbi8vIFByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGFyZSBpbnRlbnRpb25hbGx5IGtlcHQgY29tcGF0aWJsZSB3aXRoXG4vLyBtYXBib3gtZ2wncyBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgdGhhdCBzZWFtbGVzcyBpbnRlcm9wZXJhdGlvblxuLy8gd2l0aCBtYXBib3ggYW5kIHJlYWN0LW1hcC1nbC5cbi8vIFNlZTogdHJhbnNmb3JtLmpzIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5cbi8vIGdsLW1hdHJpeCBpcyBhIGxhcmdlIGRlcGVuZGVuY3kgZm9yIGEgc21hbGwgbW9kdWxlLlxuLy8gSG93ZXZlciBzaW5jZSBpdCBpcyB1c2VkIGJ5IG1hcGJveCBldGMsIGl0IHNob3VsZCBhbHJlYWR5IGJlIHByZXNlbnRcbi8vIGluIG1vc3QgdGFyZ2V0IGFwcGxpY2F0aW9uIGJ1bmRsZXMuXG5pbXBvcnQge21hdDIsIG1hdDQsIHZlYzIsIHZlYzR9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnYXV0b2JpbmQtZGVjb3JhdG9yJztcblxuLy8gQ09OU1RBTlRTXG5cbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5jb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBQSSAvIDE4MDtcbmNvbnN0IFJBRElBTlNfVE9fREVHUkVFUyA9IDE4MCAvIFBJO1xuY29uc3QgVElMRV9TSVpFID0gNTEyO1xuY29uc3QgV09STERfU0NBTEUgPSBUSUxFX1NJWkUgLyAoMiAqIFBJKTtcblxuY29uc3QgREVGQVVMVF9NQVBfU1RBVEUgPSB7XG4gIGxhdGl0dWRlOiAzNyxcbiAgbG9uZ2l0dWRlOiAtMTIyLFxuICB6b29tOiAxMSxcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG5cbi8vIEVYUE9SVFNcblxuZXhwb3J0IGNvbnN0IENPT1JESU5BVEVfU1lTVEVNID0ge1xuICAvLyBQb3NpdGlvbnMgYXJlIGludGVycHJldGVkIGFzIFtsbmcsbGF0LGVsZXZhdGlvbl0sIGRpc3RhbmNlcyBhcyBtZXRlcnNcbiAgTE5HTEFUOiAxLjAsXG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgbWV0ZXIgb2Zmc2V0cywgZGlzdGFuY2VzIGFzIG1ldGVyc1xuICBNRVRFUlM6IDIuMCxcbiAgLy8gUG9zaXRpb25zIGFuZCBkaXN0YW5jZXMgYXJlIG5vdCB0cmFuc2Zvcm1lZFxuICBJREVOVElUWTogMC4wXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIE1hbmFnZXMgY29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb25zIGZvciBkZWNrLmdsLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBtZXJjYXRvcj10cnVlIC0gV2hldGhlciB0byB1c2UgbWVyY2F0b3IgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge0FycmF5fSBvcHQuY2VudGVyPVswLCAwXSAtIENlbnRlciBvZiB2aWV3cG9ydFxuICAgKiAgIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBvciBbeCwgeV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuXG4gICAqIE5vdGVzOlxuICAgKiAgLSBPbmx5IG9uZSBvZiBjZW50ZXIgb3IgW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBiZSBzcGVjaWZpZWRcbiAgICogIC0gW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBvbmx5IGJlIHNwZWNpZmllZCB3aGVuIFwibWVyY2F0b3JcIiBpcyB0cnVlXG4gICAqICAtIEFsdGl0dWRlIGhhcyBhIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXRjaGVzIGFzc3VtcHRpb25zIGluIG1hcGJveC1nbFxuICAgKiAgLSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBmb3JjZWQgdG8gMSBpZiBzdXBwbGllZCBhcyAwLCB0byBhdm9pZFxuICAgKiAgICBkaXZpc2lvbiBieSB6ZXJvLiBUaGlzIGlzIGludGVuZGVkIHRvIHJlZHVjZSB0aGUgYnVyZGVuIG9mIGFwcHMgdG9cbiAgICogICAgdG8gY2hlY2sgdmFsdWVzIGJlZm9yZSBpbnN0YW50aWF0aW5nIGEgVmlld3BvcnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBNYXAgc3RhdGVcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGF0aXR1ZGUsXG4gICAgbG9uZ2l0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBtZXJjYXRvckVuYWJsZWRcbiAgfSA9IHt9KSB7XG4gICAgLy8gVmlld3BvcnQgLSBzdXBwb3J0IHVuZGVmaW5lZCBhcmd1bWVudHNcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoICE9PSB1bmRlZmluZWQgPyB3aWR0aCA6IERFRkFVTFRfTUFQX1NUQVRFLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgdGhpcy56b29tID0gem9vbSAhPT0gdW5kZWZpbmVkID8gem9vbSA6IERFRkFVTFRfTUFQX1NUQVRFLnpvb207XG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlICE9PSB1bmRlZmluZWQgPyBsYXRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZyAhPT0gdW5kZWZpbmVkID8gYmVhcmluZyA6IERFRkFVTFRfTUFQX1NUQVRFLmJlYXJpbmc7XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoICE9PSB1bmRlZmluZWQgPyBwaXRjaCA6IERFRkFVTFRfTUFQX1NUQVRFLnBpdGNoO1xuICAgIHRoaXMuYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcbiAgICB0aGlzLm1lcmNhdG9yRW5hYmxlZCA9IG1lcmNhdG9yRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gbWVyY2F0b3JFbmFibGVkIDogdHJ1ZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDBcbiAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgMTtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcblxuICAgIC8vIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgIC8vIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gd2luZG93XG4gICAqIHVzaW5nIHZpZXdwb3J0IHByb2plY3Rpb24gcGFyYW1ldGVyc1xuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlXSB0byBbeCwgeV1cbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgWl0gPT4gW3gsIHksIHpdXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQsIHJldHVybnMgdG9wLWxlZnQgY29vcmRpbmF0ZXMgZm9yIGNhbnZhcy9TVkcgdHlwZSByZW5kZXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0WiAtIFtsbmcsIGxhdF0gb3IgW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudG9wTGVmdD10cnVlIC0gV2hldGhlciBwcm9qZWN0ZWQgY29vcmRzIGFyZSB0b3AgbGVmdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbeCwgeV0gb3IgW3gsIHksIHpdIGluIHRvcCBsZWZ0IGNvb3Jkc1xuICAgKi9cbiAgQGF1dG9iaW5kXG4gIHByb2plY3QobG5nTGF0Wiwge3RvcExlZnQgPSB0cnVlfSA9IHt9KSB7XG4gICAgY29uc3QgW1gsIFldID0gdGhpcy5tZXJjYXRvckVuYWJsZWQgfHwgdGhpcy5tZXJjYXRvciA/XG4gICAgICB0aGlzLnByb2plY3RGbGF0KGxuZ0xhdFopIDogbG5nTGF0WjtcbiAgICBjb25zdCB2ID0gW1gsIFksIGxuZ0xhdFpbMl0gfHwgMCwgMV07XG5cbiAgICAvLyB2ZWM0LnN1Yih2LCB2LCBbdGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIDAsIDBdKTtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodiwgdiwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgIC8vIERpdmlkZSBieSB3XG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gdlszXTtcbiAgICB2ZWM0Lm11bHRpcGx5KHYsIHYsIFtzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuICAgIGNvbnN0IFt4LCB5LCB6XSA9IHY7XG4gICAgLy8gY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSAxIC0geSA6IHk7XG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB5IDogeTtcbiAgICByZXR1cm4gbG5nTGF0Wi5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gW2xvbiwgbGF0XSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIHVucHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gdHJ1ZX0gPSB7fSkge1xuICAgIGNvbnN0IFt4ID0gMCwgeSA9IDAsIHogPSAwXSA9IHh5ejtcbiAgICAvLyBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIDEgLSB5IDogeTtcbiAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHkgOiB5O1xuICAgIGNvbnN0IHYgPSBbeCwgeTIsIHosIDFdO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NCh2LCB2LCB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBjb25zdCBzY2FsZSA9IDEgLyB2WzNdO1xuICAgIHZlYzQubXVsdGlwbHkodiwgdiwgW3NjYWxlLCBzY2FsZSwgc2NhbGUsIHNjYWxlXSk7XG4gICAgY29uc3QgW3gwLCB5MF0gPSB0aGlzLnVucHJvamVjdEZsYXQodik7XG4gICAgY29uc3QgWywgLCB6MF0gPSB2O1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gwLCB5MF0gOiBbeDAsIHkwLCB6MF07XG4gIH1cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgcHJvamVjdEZsYXQoW2xuZywgbGF0XSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICAgIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gICAgY29uc3QgcGhpMiA9IGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgICBjb25zdCB4ID0gc2NhbGUgKiAobGFtYmRhMiArIFBJKTtcbiAgICBjb25zdCB5ID0gc2NhbGUgKiAoUEkgLSBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgdW5wcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgICBjb25zdCBsYW1iZGEyID0geCAvIHNjYWxlIC0gUEk7XG4gICAgY29uc3QgcGhpMiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFBJIC0geSAvIHNjYWxlKSkgLSBQSV80KTtcbiAgICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIGdldFByb2plY3Rpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXg6IHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXg6IHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeDogdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXg6IHRoaXMudmlld01hdHJpeCxcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHRoaXMucHJvamVjdGlvbk1hdHJpeFxuICAgIH07XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpeGVsc1Blck1ldGVyOiB0aGlzLnBpeGVsc1Blck1ldGVyLFxuICAgICAgbWV0ZXJzUGVyUGl4ZWw6IHRoaXMubWV0ZXJzUGVyUGl4ZWxcbiAgICB9O1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIFNjYWxlXG4gICAgdGhpcy5zY2FsZSA9IE1hdGgucG93KDIsIHRoaXMuem9vbSk7XG4gICAgdGhpcy53b3JsZFNpemUgPSBUSUxFX1NJWkUgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMudGlsZVpvb20gPSBNYXRoLmZsb29yKHRoaXMuem9vbSk7XG4gICAgdGhpcy56b29tRnJhY3Rpb24gPSB0aGlzLnpvb20gLSBNYXRoLmZsb29yKHRoaXMuem9vbSk7XG5cbiAgICAvLyBCZWFyaW5nXG4gICAgdGhpcy5iZWFyaW5nUmFkaWFucyA9IHRoaXMuYmVhcmluZyAvIDE4MCAqIE1hdGguUEk7XG4gICAgdGhpcy5iZWFyaW5nUm90YXRpb25NYXRyaXggPSBtYXQyLmNyZWF0ZSgpO1xuICAgIG1hdDIucm90YXRlKFxuICAgICAgdGhpcy5iZWFyaW5nUm90YXRpb25NYXRyaXgsIHRoaXMuYmVhcmluZ1JvdGF0aW9uTWF0cml4LCB0aGlzLmJlYXJpbmdcbiAgICApO1xuXG4gICAgLy8gUGl0Y2hcbiAgICB0aGlzLm9yaWdpbmFsUGl0Y2ggPSB0aGlzLnBpdGNoO1xuICAgIHRoaXMucGl0Y2ggPSBNYXRoLm1pbig2MCwgdGhpcy5waXRjaCk7XG4gICAgdGhpcy5waXRjaFJhZGlhbnMgPSB0aGlzLnBpdGNoIC8gMTgwICogTWF0aC5QSTtcblxuICAgIC8vIEFsdGl0dWRlXG4gICAgdGhpcy5vcmlnaW5hbEFsdGl0dWRlID0gdGhpcy5hbHRpdHVkZTtcbiAgICB0aGlzLmFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgdGhpcy5hbHRpdHVkZSk7XG5cbiAgICAvLyBDZW50ZXIgeCwgeVxuICAgIHRoaXMuY2VudGVyID0gdGhpcy5wcm9qZWN0RmxhdChbdGhpcy5sb25naXR1ZGUsIHRoaXMubGF0aXR1ZGVdKTtcbiAgICB0aGlzLmNlbnRlclggPSB0aGlzLmNlbnRlclswXTtcbiAgICB0aGlzLmNlbnRlclkgPSB0aGlzLmNlbnRlclsxXTtcblxuICAgIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcFxuICAgIC8vIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgICB0aGlzLmhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gdGhpcy5hbHRpdHVkZSk7XG4gICAgdGhpcy50b3BIYWxmU3VyZmFjZURpc3RhbmNlID1cbiAgICAgIE1hdGguc2luKHRoaXMuaGFsZkZvdikgKiB0aGlzLmFsdGl0dWRlIC9cbiAgICAgIE1hdGguc2luKE1hdGguUEkgLyAyIC0gdGhpcy5waXRjaFJhZGlhbnMgLSB0aGlzLmhhbGZGb3YpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHogdmFsdWUgb2YgdGhlIGZhcnRoZXN0IGZyYWdtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgIHRoaXMuZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gdGhpcy5waXRjaFJhZGlhbnMpICpcbiAgICAgIHRoaXMudG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIHRoaXMuYWx0aXR1ZGU7XG5cbiAgICAvLyBDYWxjdWxhdGUgbWF0cmljZXMgYW5kIHNjYWxlcyBuZWVkZWQgZm9yIHByb2plY3Rpb25cbiAgICB0aGlzLl9jYWxjdWxhdGVEaXN0YW5jZVNjYWxlcygpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uTWF0cmljZXMoKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gICAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAgICogSW4gbWVyY2F0b3IgcHJvamVjdGlvbiBtb2RlLCB0aGUgZGlzdGFuY2Ugc2NhbGVzIHZhcnkgc2lnbmlmaWNhbnRseVxuICAgKiB3aXRoIGxhdGl0dWRlLlxuICAgKi9cbiAgX2NhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKCkge1xuICAgIC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG4gICAgY29uc3QgTUVURVJTX1BFUl9ERUdSRUUgPSAxMTEwMDA7XG4gICAgY29uc3Qge2xhdGl0dWRlLCBsb25naXR1ZGV9ID0gdGhpcztcblxuICAgIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgICBjb25zdCBtZXRlcnNQZXJEZWdyZWUgPSBNRVRFUlNfUEVSX0RFR1JFRSAqIGxhdENvc2luZTtcblxuICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbG9uZ2l0dWRlXG4gICAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyLmRpc3RhbmNlKFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlICsgMC41LCBsYXRpdHVkZV0pLFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlIC0gMC41LCBsYXRpdHVkZV0pXG4gICAgKTtcbiAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxhdGl0dWRlXG4gICAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSB2ZWMyLmRpc3RhbmNlKFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSArIDAuNV0pLFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSAtIDAuNV0pXG4gICAgKTtcblxuICAgIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gICAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJZID0gcGl4ZWxzUGVyRGVncmVlWSAvIG1ldGVyc1BlckRlZ3JlZTtcbiAgICBjb25zdCBwaXhlbHNQZXJNZXRlclogPSAocGl4ZWxzUGVyTWV0ZXJYICsgcGl4ZWxzUGVyTWV0ZXJZKSAvIDI7XG5cbiAgICAvLyBjb25zdCBzY2FsZSA9IDAuOTU7XG4gICAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbXG4gICAgLy8gICBwaXhlbHNQZXJNZXRlclggKiBzY2FsZSwgcGl4ZWxzUGVyTWV0ZXJZICogc2NhbGUsIHBpeGVsc1Blck1ldGVyWiAqIHNjYWxlXG4gICAgLy8gXTtcbiAgICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlciA9IHRoaXMud29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gICAgY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbXG4gICAgICBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyXG4gICAgXTtcbiAgICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFtcbiAgICAgIDEgLyBwaXhlbHNQZXJNZXRlclgsIDEgLyBwaXhlbHNQZXJNZXRlclksIDEgLyBwaXhlbHNQZXJNZXRlclpcbiAgICBdO1xuXG4gICAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBzY2FsaW5nIG9mZnNldHNcbiAgICB0aGlzLnBpeGVsc1Blck1ldGVyID0gcGl4ZWxzUGVyTWV0ZXI7XG4gICAgLy8gQWRkaXRpb25hbCByZXN1bHRzXG4gICAgdGhpcy5tZXRlcnNQZXJQaXhlbCA9IG1ldGVyc1BlclBpeGVsO1xuICAgIC8vIG1ldGVyc1BlckRlZ3JlZSxcbiAgICAvLyBkZWdyZWVzUGVyTWV0ZXI6IDEgLyBtZXRlcnNQZXJEZWdyZWVcbiAgfVxuXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGluIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfY2FsY3VsYXRlVHJhbnNmb3JtYXRpb25NYXRyaWNlcygpIHtcbiAgICAvLyBQUk9KRUNUSU9OIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBDQU1FUkEgU1BBQ0UgVE8gQ0xJUFNQQUNFXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8taW5saW5lLWNvbW1lbnRzICovXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5wZXJzcGVjdGl2ZShcbiAgICAgIHRoaXMuX2NyZWF0ZU1hdDQoKSxcbiAgICAgIDIgKiBNYXRoLmF0YW4oKHRoaXMuaGVpZ2h0IC8gMikgLyB0aGlzLmFsdGl0dWRlKSwgLy8gZm92IGluIHJhZGlhbnNcbiAgICAgIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgICAwLjEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lYXIgcGxhbmVcbiAgICAgIHRoaXMuZmFyWiAqIDEwLjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFyIHBsYW5lXG4gICAgKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWlubGluZS1jb21tZW50cyAqL1xuXG4gICAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIEZST00gVklSVFVBTCBQSVhFTFMgVE8gQ0FNRVJBIFNQQUNFXG4gICAgY29uc3Qgdm0gPSB0aGlzLl9jcmVhdGVNYXQ0KCk7XG5cbiAgICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZVxuICAgIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC10aGlzLmFsdGl0dWRlXSk7XG5cbiAgICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgICAvLyBhbHRpdHVkZSB1bml0cy4gMSBhbHRpdHVkZSB1bml0ID0gdGhlIHNjcmVlbiBoZWlnaHQuXG4gICAgbWF0NC5zY2FsZSh2bSwgdm0sIFsxLCAtMSwgMSAvIHRoaXMuaGVpZ2h0XSk7XG5cbiAgICAvLyBSb3RhdGUgYnkgYmVhcmluZywgYW5kIHRoZW4gYnkgcGl0Y2ggKHdoaWNoIHRpbHRzIHRoZSB2aWV3KVxuICAgIG1hdDQucm90YXRlWCh2bSwgdm0sIHRoaXMucGl0Y2hSYWRpYW5zKTtcbiAgICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCAtdGhpcy5iZWFyaW5nUmFkaWFucyk7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB0aGlzLl9jcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC50cmFuc2xhdGUodGhpcy52aWV3TWF0cml4LCB2bSwgWy10aGlzLmNlbnRlclgsIC10aGlzLmNlbnRlclksIDBdKTtcblxuICAgIGNvbnN0IHZwbSA9IHRoaXMuX2NyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHRoaXMudmlld01hdHJpeCk7XG5cbiAgICB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdnBtO1xuXG4gICAgLy8gUElYRUwgUFJPSkVDVElPTiBNQVRSSVhcbiAgICBjb25zdCBtID0gdGhpcy5fY3JlYXRlTWF0NCgpO1xuXG4gICAgLy8gU2NhbGUgd2l0aCB2aWV3cG9ydCB3aW5kb3cncyB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVsc1xuICAgIG1hdDQuc2NhbGUobSwgbSwgW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAxXSk7XG4gICAgLy8gQ29udmVydCB0byAoMCwgMSlcbiAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMC41LCAwLjUsIDBdKTtcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFswLjUsIDAuNSwgMF0pO1xuICAgIC8vIFByb2plY3QgdG8gY2xpcCBzcGFjZSAoLTEsIDEpXG4gICAgbWF0NC5tdWx0aXBseShtLCBtLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4KTtcbiAgICB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG07XG5cbiAgICBjb25zdCBtSW52ZXJzZSA9IHRoaXMuX2NyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0LmludmVydChtSW52ZXJzZSwgbSk7XG4gICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1JbnZlcnNlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKipcbiAgICogQnVpbGRzIG1hdHJpY2VzIHRoYXQgY29udmVydHMgcHJlcHJvamVjdGVkIGxuZ0xhdHMgdG8gc2NyZWVuIHBpeGVsc1xuICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICpcbiAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAqIE5vdGU6IFN0YXJ0cyB3aXRoIHRoZSBHTCBwcm9qZWN0aW9uIG1hdHJpeCBhbmQgYWRkcyBzdGVwcyB0byB0aGVcbiAgICogICAgICAgc2NhbGUgYW5kIHRyYW5zbGF0ZSB0aGF0IG1hdHJpeCBvbnRvIHRoZSB3aW5kb3cuXG4gICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgKiAgICAgICBhbmQgZG9lcyBub3QgbmVlZCB0aGlzIHN0ZXAuXG4gICAqL1xuICBfY2FsY3VsYXRlUGl4ZWxQcm9qZWN0aW9uTWF0cmljZXMoKSB7XG4gICAgY29uc3QgbSA9IHRoaXMuX2NyZWF0ZU1hdDQoKTtcblxuICAgIC8vIFNjYWxlIHdpdGggdmlld3BvcnQgd2luZG93J3Mgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHNcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMV0pO1xuICAgIC8vIENvbnZlcnQgdG8gKDAsIDEpXG4gICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzAuNSwgMC41LCAwXSk7XG4gICAgbWF0NC5zY2FsZShtLCBtLCBbMC41LCAwLjUsIDBdKTtcbiAgICAvLyBQcm9qZWN0IHRvIGNsaXAgc3BhY2UgKC0xLCAxKVxuICAgIG1hdDQubXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuXG4gICAgY29uc3QgbUludmVyc2UgPSB0aGlzLl9jcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5pbnZlcnQobUludmVyc2UsIG0pO1xuICAgIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtSW52ZXJzZTtcbiAgfVxuXG4gIC8vIEhlbHBlciwgYXZvaWRzIGxvdy1wcmVjaXNpb24gMzIgYml0IG1hdHJpY2VzIGZyb20gbWF0NC5jcmVhdGUoKTtcbiAgX2NyZWF0ZU1hdDQoKSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgfVxufVxuIl19