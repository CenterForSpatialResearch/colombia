'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lib = require('../../../lib');

var _shaderUtils = require('../../../shader-utils');

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _lodash = require('lodash.flattendeep');

var _lodash2 = _interopRequireDefault(_lodash);

var _geojsonNormalize = require('geojson-normalize');

var _geojsonNormalize2 = _interopRequireDefault(_geojsonNormalize);

var _luma = require('luma.gl');

var _extrudePolyline = require('extrude-polyline');

var _extrudePolyline2 = _interopRequireDefault(_extrudePolyline);

var _enhancedChoroplethLayerVertex = require('./enhanced-choropleth-layer-vertex');

var _enhancedChoroplethLayerVertex2 = _interopRequireDefault(_enhancedChoroplethLayerVertex);

var _enhancedChoroplethLayerFragment = require('./enhanced-choropleth-layer-fragment');

var _enhancedChoroplethLayerFragment2 = _interopRequireDefault(_enhancedChoroplethLayerFragment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EnhancedChoroplethLayer = function (_Layer) {
  _inherits(EnhancedChoroplethLayer, _Layer);

  /**
   * @classdesc
   * ChoroplethLayer
   *
   * @class
   * @param {object} props
   * @param {bool} props.drawContour - ? drawContour : drawArea
   * @param {function} props.onChoroplethHovered - provide properties of the
   *     selected choropleth, together with the mouse event when mouse hovered
   * @param {function} props.onChoroplethClicked - provide properties of the
   *     selected choropleth, together with the mouse event when mouse clicked
   */
  function EnhancedChoroplethLayer(_ref) {
    var _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? null : _ref$getColor,
        _ref$fillColor = _ref.fillColor,
        fillColor = _ref$fillColor === undefined ? [128, 128, 128] : _ref$fillColor,
        _ref$drawContour = _ref.drawContour,
        drawContour = _ref$drawContour === undefined ? true : _ref$drawContour,
        _ref$strokeWidth = _ref.strokeWidth,
        strokeWidth = _ref$strokeWidth === undefined ? 3 : _ref$strokeWidth,
        _ref$strokeColor = _ref.strokeColor,
        strokeColor = _ref$strokeColor === undefined ? [0, 0, 0] : _ref$strokeColor,
        _ref$elevation = _ref.elevation,
        elevation = _ref$elevation === undefined ? 0 : _ref$elevation,
        props = _objectWithoutProperties(_ref, ['getColor', 'fillColor', 'drawContour', 'strokeWidth', 'strokeColor', 'elevation']);

    _classCallCheck(this, EnhancedChoroplethLayer);

    return _possibleConstructorReturn(this, (EnhancedChoroplethLayer.__proto__ || Object.getPrototypeOf(EnhancedChoroplethLayer)).call(this, _extends({
      getColor: getColor,
      fillColor: fillColor,
      drawContour: drawContour,
      strokeWidth: strokeWidth,
      strokeColor: strokeColor,
      elevation: elevation
    }, props)));
  }

  _createClass(EnhancedChoroplethLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.state.attributeManager;


      attributeManager.add({
        positions: { size: 3, 0: 'x', 1: 'y', 2: 'unused' },
        indices: { size: 1, 0: 'index', isIndexed: true },
        colors: { size: 3, 0: 'red', 1: 'green', 2: 'blue' },
        // Override picking colors to prevent auto allocation
        pickingColors: { size: 3, 0: 'pickRed', 1: 'pickGreen', 2: 'pickBlue' }
      }, {
        // Primtive attributes
        indices: { update: this.calculateIndices },
        positions: { update: this.calculatePositions },
        colors: { update: this.calculateColors },
        // Instanced attributes
        pickingColors: { update: this.calculatePickingColors, noAlloc: true }
      });

      this.setState({
        numInstances: 0,
        model: this.getModel(gl)
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          changeFlags = _ref2.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged || oldProps.strokeWidth !== props.strokeWidth) {
        this.extractChoropleths();
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: 'pick',
    value: function pick(opts) {
      _get(EnhancedChoroplethLayer.prototype.__proto__ || Object.getPrototypeOf(EnhancedChoroplethLayer.prototype), 'pick', this).call(this, opts);
      var info = opts.info;

      var index = this.decodePickingColor(info.color);
      var feature = index >= 0 ? this.props.data.features[index] : null;
      info.feature = feature;
      info.object = feature;
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      return new _luma.Model(_extends({
        gl: gl,
        id: this.props.id
      }, (0, _shaderUtils.assembleShaders)(gl, {
        vs: _enhancedChoroplethLayerVertex2.default,
        fs: _enhancedChoroplethLayerFragment2.default
      }), {
        geometry: new _luma.Geometry({ drawMode: _luma.GL.TRIANGLES }),
        vertexCount: 0,
        isIndexed: true
      }));
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      var elevation = this.props.elevation;

      var positions = this.props.drawContour ? (0, _lodash2.default)(this.state.meshes.map(function (mesh) {
        return mesh.positions.map(function (pos) {
          return [].concat(_toConsumableArray(pos), [elevation]);
        });
      })) : (0, _lodash2.default)(this.state.groupedVertices);

      attribute.value = new Float32Array(positions);
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      // adjust index offset for multiple choropleths
      var offsets = this.props.drawContour ? this.state.meshes.reduce(function (acc, mesh) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + mesh.positions.length]);
      }, [0]) : this.state.groupedVertices.reduce(function (acc, vertices) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + vertices.length]);
      }, [0]);

      var indices = this.props.drawContour ? this.state.meshes.map(function (mesh, choroplethIndex) {
        return mesh.cells.map(function (cell) {
          return cell.map(function (index) {
            return index + offsets[choroplethIndex];
          });
        });
      }) : this.state.groupedVertices.map(function (vertices, choroplethIndex) {
        return (0, _earcut2.default)((0, _lodash2.default)(vertices), null, 3).map(function (index) {
          return index + offsets[choroplethIndex];
        });
      });

      attribute.value = new Uint16Array((0, _lodash2.default)(indices));
      attribute.target = _luma.GL.ELEMENT_ARRAY_BUFFER;
      // attribute.isIndexed = true;

      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _this2 = this;

      var _props = this.props,
          strokeColor = _props.strokeColor,
          fillColor = _props.fillColor,
          getColor = _props.getColor;

      var vColor = void 0;
      var colors = this.props.drawContour ? this.state.meshes.map(function (mesh, i) {
        vColor = getColor ? getColor(_this2.state.choropleths[i]) : strokeColor;
        return mesh.positions.map(function (p) {
          return vColor;
        });
      }) : this.state.groupedVertices.map(function (vertices, i) {
        vColor = getColor ? getColor(_this2.state.choropleths[i]) : fillColor;
        return vertices.map(function (vertex) {
          return vColor;
        });
      });

      attribute.value = new Float32Array((0, _lodash2.default)(colors));
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      var colors = this.props.drawContour ? this.state.meshes.map(function (mesh, i) {
        return mesh.positions.map(function (pos) {
          return [0, 0, 0];
        });
      }) : this.state.groupedVertices.map(function (vertices, choroplethIndex) {
        return vertices.map(function (vertex) {
          return [(choroplethIndex + 1) % 256, Math.floor((choroplethIndex + 1) / 256) % 256, Math.floor((choroplethIndex + 1) / 256 / 256) % 256];
        });
      });

      attribute.value = new Float32Array((0, _lodash2.default)(colors));
    }
  }, {
    key: 'extractChoropleths',
    value: function extractChoropleths() {
      var _this3 = this;

      var data = this.props.data;

      var normalizedGeojson = (0, _geojsonNormalize2.default)(data);

      this.state.choropleths = normalizedGeojson.features.map(function (choropleth) {
        var coordinates = choropleth.geometry.coordinates[0] || [];
        // flatten nested polygons
        if (coordinates.length === 1 && coordinates[0].length > 2) {
          coordinates = coordinates[0];
        }
        return {
          properties: choropleth.properties,
          coordinates: coordinates
        };
      });

      if (this.props.drawContour) {
        (function () {
          var stroke = (0, _extrudePolyline2.default)({
            thickness: 0.0001 * _this3.props.strokeWidth,
            cap: 'butt',
            join: 'bevel',
            miterLimit: 0.005
          });

          _this3.state.meshes = _this3.state.choropleths.map(function (choropleth) {
            return stroke.build(choropleth.coordinates.map(function (coordinate) {
              return [coordinate[0], coordinate[1]];
            }));
          });
        })();
      } else {
        this.state.groupedVertices = this.state.choropleths.map(function (choropleth) {
          return choropleth.coordinates.map(function (coordinate) {
            return [coordinate[0], coordinate[1], 100];
          });
        });
      }
    }
  }]);

  return EnhancedChoroplethLayer;
}(_lib.Layer);

EnhancedChoroplethLayer.layerName = 'EnhancedChoroplethLayer';
exports.default = EnhancedChoroplethLayer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvc2FtcGxlcy9lbmhhbmNlZC1jaG9yb3BsZXRoLWxheWVyL2VuaGFuY2VkLWNob3JvcGxldGgtbGF5ZXIuanMiXSwibmFtZXMiOlsiRW5oYW5jZWRDaG9yb3BsZXRoTGF5ZXIiLCJnZXRDb2xvciIsImZpbGxDb2xvciIsImRyYXdDb250b3VyIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VDb2xvciIsImVsZXZhdGlvbiIsInByb3BzIiwiZ2wiLCJjb250ZXh0IiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwiYWRkIiwicG9zaXRpb25zIiwic2l6ZSIsImluZGljZXMiLCJpc0luZGV4ZWQiLCJjb2xvcnMiLCJwaWNraW5nQ29sb3JzIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5kaWNlcyIsImNhbGN1bGF0ZVBvc2l0aW9ucyIsImNhbGN1bGF0ZUNvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJub0FsbG9jIiwic2V0U3RhdGUiLCJudW1JbnN0YW5jZXMiLCJtb2RlbCIsImdldE1vZGVsIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwiZXh0cmFjdENob3JvcGxldGhzIiwiaW52YWxpZGF0ZUFsbCIsIm9wdHMiLCJpbmZvIiwiaW5kZXgiLCJkZWNvZGVQaWNraW5nQ29sb3IiLCJjb2xvciIsImZlYXR1cmUiLCJkYXRhIiwiZmVhdHVyZXMiLCJvYmplY3QiLCJpZCIsInZzIiwiZnMiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiVFJJQU5HTEVTIiwidmVydGV4Q291bnQiLCJhdHRyaWJ1dGUiLCJtZXNoZXMiLCJtYXAiLCJtZXNoIiwicG9zIiwiZ3JvdXBlZFZlcnRpY2VzIiwidmFsdWUiLCJGbG9hdDMyQXJyYXkiLCJvZmZzZXRzIiwicmVkdWNlIiwiYWNjIiwibGVuZ3RoIiwidmVydGljZXMiLCJjaG9yb3BsZXRoSW5kZXgiLCJjZWxscyIsImNlbGwiLCJVaW50MTZBcnJheSIsInRhcmdldCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwic2V0VmVydGV4Q291bnQiLCJ2Q29sb3IiLCJpIiwiY2hvcm9wbGV0aHMiLCJNYXRoIiwiZmxvb3IiLCJub3JtYWxpemVkR2VvanNvbiIsImNvb3JkaW5hdGVzIiwiY2hvcm9wbGV0aCIsInByb3BlcnRpZXMiLCJzdHJva2UiLCJ0aGlja25lc3MiLCJjYXAiLCJqb2luIiwibWl0ZXJMaW1pdCIsImJ1aWxkIiwiY29vcmRpbmF0ZSIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUVBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztJQUVxQkEsdUI7OztBQUluQjs7Ozs7Ozs7Ozs7O0FBWUEseUNBUUc7QUFBQSw2QkFQREMsUUFPQztBQUFBLFFBUERBLFFBT0MsaUNBUFUsSUFPVjtBQUFBLDhCQU5EQyxTQU1DO0FBQUEsUUFOREEsU0FNQyxrQ0FOVyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxDQU1YO0FBQUEsZ0NBTERDLFdBS0M7QUFBQSxRQUxEQSxXQUtDLG9DQUxhLElBS2I7QUFBQSxnQ0FKREMsV0FJQztBQUFBLFFBSkRBLFdBSUMsb0NBSmEsQ0FJYjtBQUFBLGdDQUhEQyxXQUdDO0FBQUEsUUFIREEsV0FHQyxvQ0FIYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUdiO0FBQUEsOEJBRkRDLFNBRUM7QUFBQSxRQUZEQSxTQUVDLGtDQUZXLENBRVg7QUFBQSxRQURFQyxLQUNGOztBQUFBOztBQUFBO0FBRUNOLHdCQUZEO0FBR0NDLDBCQUhEO0FBSUNDLDhCQUpEO0FBS0NDLDhCQUxEO0FBTUNDLDhCQU5EO0FBT0NDO0FBUEQsT0FRSUMsS0FSSjtBQVVGOzs7O3NDQUVpQjtBQUFBLFVBQ1RDLEVBRFMsR0FDSCxLQUFLQyxPQURGLENBQ1RELEVBRFM7QUFBQSxVQUVURSxnQkFGUyxHQUVXLEtBQUtDLEtBRmhCLENBRVRE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LENBQWQ7QUFBQSxTQUQyQixDQUE3QjtBQUtEO0FBQ0Y7Ozs7OztBQTFOa0JyRix1QixDQUVac0YsUyxHQUFZLHlCO2tCQUZBdEYsdUIiLCJmaWxlIjoiZW5oYW5jZWQtY2hvcm9wbGV0aC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCBmbGF0dGVuRGVlcCBmcm9tICdsb2Rhc2guZmxhdHRlbmRlZXAnO1xuaW1wb3J0IG5vcm1hbGl6ZSBmcm9tICdnZW9qc29uLW5vcm1hbGl6ZSc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgZXh0cnVkZVBvbHlsaW5lIGZyb20gJ2V4dHJ1ZGUtcG9seWxpbmUnO1xuXG5pbXBvcnQgVkVSVEVYX1NIQURFUiBmcm9tICcuL2VuaGFuY2VkLWNob3JvcGxldGgtbGF5ZXItdmVydGV4JztcbmltcG9ydCBGUkFHTUVOVF9TSEFERVIgZnJvbSAnLi9lbmhhbmNlZC1jaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5oYW5jZWRDaG9yb3BsZXRoTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG5cbiAgc3RhdGljIGxheWVyTmFtZSA9ICdFbmhhbmNlZENob3JvcGxldGhMYXllcic7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQ2hvcm9wbGV0aExheWVyXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtib29sfSBwcm9wcy5kcmF3Q29udG91ciAtID8gZHJhd0NvbnRvdXIgOiBkcmF3QXJlYVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9wcy5vbkNob3JvcGxldGhIb3ZlcmVkIC0gcHJvdmlkZSBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgKiAgICAgc2VsZWN0ZWQgY2hvcm9wbGV0aCwgdG9nZXRoZXIgd2l0aCB0aGUgbW91c2UgZXZlbnQgd2hlbiBtb3VzZSBob3ZlcmVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb3BzLm9uQ2hvcm9wbGV0aENsaWNrZWQgLSBwcm92aWRlIHByb3BlcnRpZXMgb2YgdGhlXG4gICAqICAgICBzZWxlY3RlZCBjaG9yb3BsZXRoLCB0b2dldGhlciB3aXRoIHRoZSBtb3VzZSBldmVudCB3aGVuIG1vdXNlIGNsaWNrZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZXRDb2xvciA9IG51bGwsXG4gICAgZmlsbENvbG9yID0gWzEyOCwgMTI4LCAxMjhdLFxuICAgIGRyYXdDb250b3VyID0gdHJ1ZSxcbiAgICBzdHJva2VXaWR0aCA9IDMsXG4gICAgc3Ryb2tlQ29sb3IgPSBbMCwgMCwgMF0sXG4gICAgZWxldmF0aW9uID0gMCxcbiAgICAuLi5wcm9wc1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZ2V0Q29sb3IsXG4gICAgICBmaWxsQ29sb3IsXG4gICAgICBkcmF3Q29udG91cixcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICBlbGV2YXRpb24sXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgIHBvc2l0aW9uczoge3NpemU6IDMsIDA6ICd4JywgMTogJ3knLCAyOiAndW51c2VkJ30sXG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgMDogJ2luZGV4JywgaXNJbmRleGVkOiB0cnVlfSxcbiAgICAgIGNvbG9yczoge3NpemU6IDMsIDA6ICdyZWQnLCAxOiAnZ3JlZW4nLCAyOiAnYmx1ZSd9LFxuICAgICAgLy8gT3ZlcnJpZGUgcGlja2luZyBjb2xvcnMgdG8gcHJldmVudCBhdXRvIGFsbG9jYXRpb25cbiAgICAgIHBpY2tpbmdDb2xvcnM6IHtzaXplOiAzLCAwOiAncGlja1JlZCcsIDE6ICdwaWNrR3JlZW4nLCAyOiAncGlja0JsdWUnfVxuICAgIH0sIHtcbiAgICAgIC8vIFByaW10aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGluZGljZXM6IHt1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlc30sXG4gICAgICBwb3NpdGlvbnM6IHt1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zfSxcbiAgICAgIGNvbG9yczoge3VwZGF0ZTogdGhpcy5jYWxjdWxhdGVDb2xvcnN9LFxuICAgICAgLy8gSW5zdGFuY2VkIGF0dHJpYnV0ZXNcbiAgICAgIHBpY2tpbmdDb2xvcnM6IHt1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUGlja2luZ0NvbG9ycywgbm9BbGxvYzogdHJ1ZX1cbiAgICB9KTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBvbGRQcm9wcy5zdHJva2VXaWR0aCAhPT0gcHJvcHMuc3Ryb2tlV2lkdGgpIHtcbiAgICAgIHRoaXMuZXh0cmFjdENob3JvcGxldGhzKCk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICBwaWNrKG9wdHMpIHtcbiAgICBzdXBlci5waWNrKG9wdHMpO1xuICAgIGNvbnN0IHtpbmZvfSA9IG9wdHM7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihpbmZvLmNvbG9yKTtcbiAgICBjb25zdCBmZWF0dXJlID0gaW5kZXggPj0gMCA/IHRoaXMucHJvcHMuZGF0YS5mZWF0dXJlc1tpbmRleF0gOiBudWxsO1xuICAgIGluZm8uZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgaW5mby5vYmplY3QgPSBmZWF0dXJlO1xuICB9XG5cbiAgZ2V0TW9kZWwoZ2wpIHtcbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAuLi5hc3NlbWJsZVNoYWRlcnMoZ2wsIHtcbiAgICAgICAgdnM6IFZFUlRFWF9TSEFERVIsXG4gICAgICAgIGZzOiBGUkFHTUVOVF9TSEFERVJcbiAgICAgIH0pLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7ZHJhd01vZGU6IEdMLlRSSUFOR0xFU30pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZWxldmF0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/XG4gICAgICBmbGF0dGVuRGVlcCh0aGlzLnN0YXRlLm1lc2hlcy5tYXAobWVzaCA9PlxuICAgICAgICBtZXNoLnBvc2l0aW9ucy5tYXAocG9zID0+IFsuLi5wb3MsIGVsZXZhdGlvbl0pKSkgOlxuICAgICAgZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMpO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBjaG9yb3BsZXRoc1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLnByb3BzLmRyYXdDb250b3VyID9cbiAgICAgIHRoaXMuc3RhdGUubWVzaGVzLnJlZHVjZShcbiAgICAgICAgKGFjYywgbWVzaCkgPT4gWy4uLmFjYywgYWNjW2FjYy5sZW5ndGggLSAxXSArIG1lc2gucG9zaXRpb25zLmxlbmd0aF0sXG4gICAgICAgIFswXVxuICAgICAgKSA6XG5cbiAgICAgIHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzLnJlZHVjZShcbiAgICAgICAgKGFjYywgdmVydGljZXMpID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyB2ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICBbMF1cbiAgICAgICk7XG5cbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/XG4gICAgICB0aGlzLnN0YXRlLm1lc2hlcy5tYXAoXG4gICAgICAgIChtZXNoLCBjaG9yb3BsZXRoSW5kZXgpID0+IG1lc2guY2VsbHMubWFwKFxuICAgICAgICAgIGNlbGwgPT4gY2VsbC5tYXAoXG4gICAgICAgICAgICBpbmRleCA9PiBpbmRleCArIG9mZnNldHNbY2hvcm9wbGV0aEluZGV4XVxuICAgICAgICAgIClcbiAgICAgICAgKSkgOlxuICAgICAgdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKFxuICAgICAgICAodmVydGljZXMsIGNob3JvcGxldGhJbmRleCkgPT5cbiAgICAgICAgICBlYXJjdXQoZmxhdHRlbkRlZXAodmVydGljZXMpLCBudWxsLCAzKS5tYXAoXG4gICAgICAgICAgICBpbmRleCA9PiBpbmRleCArIG9mZnNldHNbY2hvcm9wbGV0aEluZGV4XVxuICAgICAgICAgIClcbiAgICAgICk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDE2QXJyYXkoZmxhdHRlbkRlZXAoaW5kaWNlcykpO1xuICAgIGF0dHJpYnV0ZS50YXJnZXQgPSBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICAvLyBhdHRyaWJ1dGUuaXNJbmRleGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7c3Ryb2tlQ29sb3IsIGZpbGxDb2xvciwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgdkNvbG9yO1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgP1xuICAgICAgdGhpcy5zdGF0ZS5tZXNoZXMubWFwKFxuICAgICAgICAobWVzaCwgaSkgPT4ge1xuICAgICAgICAgIHZDb2xvciA9IGdldENvbG9yID9cbiAgICAgICAgICAgIGdldENvbG9yKHRoaXMuc3RhdGUuY2hvcm9wbGV0aHNbaV0pIDogc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgcmV0dXJuIG1lc2gucG9zaXRpb25zLm1hcChcbiAgICAgICAgICAgIHAgPT4gdkNvbG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKSA6XG4gICAgICB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5tYXAoXG4gICAgICAgICh2ZXJ0aWNlcywgaSkgPT4ge1xuICAgICAgICAgIHZDb2xvciA9IGdldENvbG9yID9cbiAgICAgICAgICAgIGdldENvbG9yKHRoaXMuc3RhdGUuY2hvcm9wbGV0aHNbaV0pIDogZmlsbENvbG9yO1xuICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcy5tYXAoXG4gICAgICAgICAgICB2ZXJ0ZXggPT4gdkNvbG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBwaWNraW5nIGNvbG9ycyBjYWxjdWxhdGlvblxuICBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgP1xuICAgICAgdGhpcy5zdGF0ZS5tZXNoZXMubWFwKFxuICAgICAgICAobWVzaCwgaSkgPT4gbWVzaC5wb3NpdGlvbnMubWFwKFxuICAgICAgICAgIHBvcyA9PiBbMCwgMCwgMF1cbiAgICAgICAgKVxuICAgICAgKSA6XG4gICAgICB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5tYXAoXG4gICAgICAgICh2ZXJ0aWNlcywgY2hvcm9wbGV0aEluZGV4KSA9PiB2ZXJ0aWNlcy5tYXAoXG4gICAgICAgICAgdmVydGV4ID0+IFtcbiAgICAgICAgICAgIChjaG9yb3BsZXRoSW5kZXggKyAxKSAlIDI1NixcbiAgICAgICAgICAgIE1hdGguZmxvb3IoKGNob3JvcGxldGhJbmRleCArIDEpIC8gMjU2KSAlIDI1NixcbiAgICAgICAgICAgIE1hdGguZmxvb3IoKGNob3JvcGxldGhJbmRleCArIDEpIC8gMjU2IC8gMjU2KSAlIDI1Nl1cbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG4gIH1cblxuICBleHRyYWN0Q2hvcm9wbGV0aHMoKSB7XG4gICAgY29uc3Qge2RhdGF9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBub3JtYWxpemVkR2VvanNvbiA9IG5vcm1hbGl6ZShkYXRhKTtcblxuICAgIHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMgPSBub3JtYWxpemVkR2VvanNvbi5mZWF0dXJlcy5tYXAoY2hvcm9wbGV0aCA9PiB7XG4gICAgICBsZXQgY29vcmRpbmF0ZXMgPSBjaG9yb3BsZXRoLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdIHx8IFtdO1xuICAgICAgLy8gZmxhdHRlbiBuZXN0ZWQgcG9seWdvbnNcbiAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDEgJiYgY29vcmRpbmF0ZXNbMF0ubGVuZ3RoID4gMikge1xuICAgICAgICBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcGVydGllczogY2hvcm9wbGV0aC5wcm9wZXJ0aWVzLFxuICAgICAgICBjb29yZGluYXRlc1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnByb3BzLmRyYXdDb250b3VyKSB7XG4gICAgICBjb25zdCBzdHJva2UgPSBleHRydWRlUG9seWxpbmUoe1xuICAgICAgICB0aGlja25lc3M6IDAuMDAwMSAqIHRoaXMucHJvcHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIGNhcDogJ2J1dHQnLFxuICAgICAgICBqb2luOiAnYmV2ZWwnLFxuICAgICAgICBtaXRlckxpbWl0OiAwLjAwNVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc3RhdGUubWVzaGVzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoXG4gICAgICAgIGNob3JvcGxldGggPT4gc3Ryb2tlLmJ1aWxkKGNob3JvcGxldGguY29vcmRpbmF0ZXMubWFwKFxuICAgICAgICAgIGNvb3JkaW5hdGUgPT4gW2Nvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV1dXG4gICAgICAgICkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKFxuICAgICAgICBjaG9yb3BsZXRoID0+IGNob3JvcGxldGguY29vcmRpbmF0ZXMubWFwKFxuICAgICAgICAgIGNvb3JkaW5hdGUgPT4gW2Nvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIDEwMF1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==