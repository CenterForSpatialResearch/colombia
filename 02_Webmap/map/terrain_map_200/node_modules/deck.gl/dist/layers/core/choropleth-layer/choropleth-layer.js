'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lib = require('../../../lib');

var _shaderUtils = require('../../../shader-utils');

var _luma = require('luma.gl');

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _lodash = require('lodash.flattendeep');

var _lodash2 = _interopRequireDefault(_lodash);

var _geojsonNormalize = require('geojson-normalize');

var _geojsonNormalize2 = _interopRequireDefault(_geojsonNormalize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var glslify = require('glslify');

var DEFAULT_COLOR = [0, 0, 255, 255];

var defaultGetColor = function defaultGetColor(feature) {
  return feature.properties.color;
};

var ChoroplethLayer = function (_Layer) {
  _inherits(ChoroplethLayer, _Layer);

  /**
   * @class
   * @param {object} props
   */
  function ChoroplethLayer(props) {
    _classCallCheck(this, ChoroplethLayer);

    return _possibleConstructorReturn(this, (ChoroplethLayer.__proto__ || Object.getPrototypeOf(ChoroplethLayer)).call(this, _extends({
      getColor: defaultGetColor,
      drawCountour: false,
      strokeWidth: 1
    }, props)));
  }

  _createClass(ChoroplethLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.state.attributeManager;

      attributeManager.addDynamic({
        // Primtive attributes
        indices: { size: 1, update: this.calculateIndices, isIndexed: true },
        positions: { size: 3, update: this.calculatePositions },
        colors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 4,
          update: this.calculateColors
        },
        // Instanced attributes
        pickingColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculatePickingColors,
          noAlloc: true
        }
      });

      var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;

      this.setState({
        model: this.getModel(gl),
        numInstances: 0,
        IndexType: IndexType
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged) {
        this.state.choropleths = extractChoropleths(props.data);
        attributeManager.invalidateAll();
      }

      if (oldProps.opacity !== props.opacity) {
        this.setUniforms({ opacity: props.opacity });
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var gl = this.context.gl;

      var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);
      gl.lineWidth(lineWidth);
      this.state.model.render(uniforms);
      // Setting line width back to 1 is here to workaround a Google Chrome bug
      // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with
      // correct parameter
      // This is not happening on Safari and Firefox
      gl.lineWidth(1.0);
    }
  }, {
    key: 'pick',
    value: function pick(opts) {
      _get(ChoroplethLayer.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer.prototype), 'pick', this).call(this, opts);
      var info = opts.info;

      var index = this.decodePickingColor(info.color);
      var feature = index >= 0 ? this.props.data.features[index] : null;
      info.feature = feature;
      info.object = feature;
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      return new _luma.Model(_extends({
        gl: gl,
        id: this.props.id
      }, (0, _shaderUtils.assembleShaders)(gl, {
        vs: '#define GLSLIFY 1\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n#define SHADER_NAME choropleth-layer-vertex-shader\n\n// #pragma glslify: preproject = require(../../../../shaderlib/preproject)\n// #pragma glslify: scale = require(../../../../shaderlib/scale)\n// #pragma glslify: project = require(../../../../shaderlib/project)\n\nattribute vec3 positions;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\nvoid picking_setPickColor(vec3 pickingColor) {\n  vPickingColor = vec4(pickingColor,  1.);\n}\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\n  return vPickingColor;\n}\n// PICKING\n\n// vec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\n//   vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\n//   vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\n//   return mix(color4, pickingColor4, renderPickingBuffer);\n// }\n\nvoid main(void) {\n\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\n\n  picking_setNormalAndPickColors(\n    color,\n    pickingColors / 255.\n  );\n\n  vec3 p = project_position(positions);\n  gl_Position = project_to_clipspace(vec4(p, 1.));\n}\n',
        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n#define SHADER_NAME choropleth-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\n\n// PICKING\n// uniform bool pickingEnabled;\nvarying vec4 vPickingColor;\nvec4 picking_getColor() {\n  return vPickingColor;\n}\n// PICKING\n\nvoid main(void) {\n  gl_FragColor = picking_getColor();\n}\n'
      }), {
        geometry: new _luma.Geometry({
          drawMode: this.props.drawContour ? _luma.GL.LINES : _luma.GL.TRIANGLES
        }),
        vertexCount: 0,
        isIndexed: true
      }));
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      var _this2 = this;

      // adjust index offset for multiple choropleths
      var offsets = this.state.choropleths.reduce(function (acc, choropleth) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) {
          return count + polygon.length;
        }, 0)]);
      }, [0]);
      var IndexType = this.state.IndexType;

      if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {
        throw new Error('Vertex count exceeds browser\'s limit');
      }

      var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        return _this2.props.drawContour ?
        // 1. get sequentially ordered indices of each choropleth contour
        // 2. offset them by the number of indices in previous choropleths
        calculateContourIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        }) :
        // 1. get triangulated indices for the internal areas
        // 2. offset them by the number of indices in previous choropleths
        calculateSurfaceIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        });
      });

      attribute.value = new IndexType((0, _lodash2.default)(indices));
      attribute.target = _luma.GL.ELEMENT_ARRAY_BUFFER;
      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      var vertices = (0, _lodash2.default)(this.state.choropleths);
      attribute.value = new Float32Array(vertices);
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _props = this.props,
          features = _props.data.features,
          getColor = _props.getColor;


      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var feature = features[choropleth.featureIndex];
        var color = getColor(feature) || DEFAULT_COLOR;

        if (isNaN(color[3])) {
          color[3] = DEFAULT_COLOR[3];
        }

        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array((0, _lodash2.default)(colors));
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      var _this3 = this;

      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var featureIndex = choropleth.featureIndex;

        var color = _this3.props.drawContour ? [0, 0, 0] : [(featureIndex + 1) % 256, Math.floor((featureIndex + 1) / 256) % 256, Math.floor((featureIndex + 1) / 256 / 256) % 256];
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array((0, _lodash2.default)(colors));
    }
  }]);

  return ChoroplethLayer;
}(_lib.Layer);

/*
 * converts list of features from a GeoJSON object to a list of GeoJSON
 * polygon-style coordinates
 * @param {Object} data - geojson object
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */


ChoroplethLayer.layerName = 'ChoroplethLayer';
exports.default = ChoroplethLayer;
function extractChoropleths(data) {
  var normalizedGeojson = (0, _geojsonNormalize2.default)(data);
  var result = [];

  normalizedGeojson.features.map(function (feature, featureIndex) {
    var choropleths = featureToChoropleths(feature);
    choropleths.forEach(function (choropleth) {
      choropleth.featureIndex = featureIndex;
    });
    result.push.apply(result, _toConsumableArray(choropleths));
  });
  return result;
}

/*
 * converts one GeoJSON features from object to a list of GeoJSON polygon-style
 * coordinates
 * @param {Object} data - geojson object
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */
function featureToChoropleths(feature) {
  var _feature$geometry = feature.geometry,
      coordinates = _feature$geometry.coordinates,
      type = _feature$geometry.type;

  var choropleths = void 0;

  switch (type) {
    case 'MultiPolygon':
      choropleths = coordinates;
      break;
    case 'Polygon':
      choropleths = [coordinates];
      break;
    case 'LineString':
      // create a LineStringLayer for LineString and MultiLineString?
      choropleths = [[coordinates]];
      break;
    case 'MultiLineString':
      choropleths = coordinates.map(function (coords) {
        return [coords];
      });
      break;
    default:
      choropleths = [];
  }
  return choropleths.map(function (choropleth) {
    return choropleth.map(function (polygon) {
      return polygon.map(function (coordinate) {
        return [coordinate[0], coordinate[1], coordinate[2] || 0];
      });
    });
  });
}

/*
 * get vertex indices for drawing choropleth contour
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateContourIndices(choropleth) {
  var offset = 0;

  return choropleth.reduce(function (acc, polygon) {
    var numVertices = polygon.length;

    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]
    var indices = [].concat(_toConsumableArray(acc), [offset]);
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset + numVertices - 1);

    offset += numVertices;
    return indices;
  }, []);
}

/*
 * get vertex indices for drawing choropleth mesh
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateSurfaceIndices(choropleth) {
  var holes = null;

  if (choropleth.length > 1) {
    holes = choropleth.reduce(function (acc, polygon) {
      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
    }, [0]).slice(1, choropleth.length);
  }

  return (0, _earcut2.default)((0, _lodash2.default)(choropleth), holes, 3);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXIuanMiXSwibmFtZXMiOlsiZ2xzbGlmeSIsInJlcXVpcmUiLCJERUZBVUxUX0NPTE9SIiwiZGVmYXVsdEdldENvbG9yIiwiZmVhdHVyZSIsInByb3BlcnRpZXMiLCJjb2xvciIsIkNob3JvcGxldGhMYXllciIsInByb3BzIiwiZ2V0Q29sb3IiLCJkcmF3Q291bnRvdXIiLCJzdHJva2VXaWR0aCIsImdsIiwiY29udGV4dCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsImFkZER5bmFtaWMiLCJpbmRpY2VzIiwic2l6ZSIsInVwZGF0ZSIsImNhbGN1bGF0ZUluZGljZXMiLCJpc0luZGV4ZWQiLCJwb3NpdGlvbnMiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJjb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUNvbG9ycyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwibm9BbGxvYyIsIkluZGV4VHlwZSIsImdldEV4dGVuc2lvbiIsIlVpbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJudW1JbnN0YW5jZXMiLCJvbGRQcm9wcyIsImNoYW5nZUZsYWdzIiwiZGF0YUNoYW5nZWQiLCJjaG9yb3BsZXRocyIsImV4dHJhY3RDaG9yb3BsZXRocyIsImRhdGEiLCJpbnZhbGlkYXRlQWxsIiwib3BhY2l0eSIsInNldFVuaWZvcm1zIiwidW5pZm9ybXMiLCJsaW5lV2lkdGgiLCJzY3JlZW5Ub0RldmljZVBpeGVscyIsInJlbmRlciIsIm9wdHMiLCJpbmZvIiwiaW5kZXgiLCJkZWNvZGVQaWNraW5nQ29sb3IiLCJmZWF0dXJlcyIsIm9iamVjdCIsImlkIiwidnMiLCJmcyIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJkcmF3Q29udG91ciIsIkxJTkVTIiwiVFJJQU5HTEVTIiwidmVydGV4Q291bnQiLCJhdHRyaWJ1dGUiLCJvZmZzZXRzIiwicmVkdWNlIiwiYWNjIiwiY2hvcm9wbGV0aCIsImxlbmd0aCIsImNvdW50IiwicG9seWdvbiIsIkVycm9yIiwibWFwIiwiY2hvcm9wbGV0aEluZGV4IiwiY2FsY3VsYXRlQ29udG91ckluZGljZXMiLCJjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyIsInZhbHVlIiwidGFyZ2V0IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJzZXRWZXJ0ZXhDb3VudCIsInZlcnRpY2VzIiwiRmxvYXQzMkFycmF5IiwiZmVhdHVyZUluZGV4IiwiaXNOYU4iLCJVaW50OEFycmF5IiwiTWF0aCIsImZsb29yIiwibGF5ZXJOYW1lIiwibm9ybWFsaXplZEdlb2pzb24iLCJyZXN1bHQiLCJmZWF0dXJlVG9DaG9yb3BsZXRocyIsImZvckVhY2giLCJwdXNoIiwiY29vcmRpbmF0ZXMiLCJjb29yZHMiLCJjb29yZGluYXRlIiwib2Zmc2V0IiwibnVtVmVydGljZXMiLCJpIiwiaG9sZXMiLCJzbGljZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFJQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OzsrZUE1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTUEsSUFBTUEsVUFBVUMsUUFBUSxTQUFSLENBQWhCOztBQU1BLElBQU1DLGdCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sR0FBUCxFQUFZLEdBQVosQ0FBdEI7O0FBRUEsSUFBTUMsa0JBQWtCLFNBQWxCQSxlQUFrQjtBQUFBLFNBQVdDLFFBQVFDLFVBQVIsQ0FBbUJDLEtBQTlCO0FBQUEsQ0FBeEI7O0lBRXFCQyxlOzs7QUFJbkI7Ozs7QUFJQSwyQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBO0FBRWZDLGdCQUFVTixlQUZL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M0MsTUFBSTZCLFNBQVMsQ0FBYjs7QUFFQSxTQUFPN0IsV0FBV0YsTUFBWCxDQUFrQixVQUFDQyxHQUFELEVBQU1JLE9BQU4sRUFBa0I7QUFDekMsUUFBTTJCLGNBQWMzQixRQUFRRixNQUE1Qjs7QUFFQTtBQUNBLFFBQU12RCx1Q0FBY3FELEdBQWQsSUFBbUI4QixNQUFuQixFQUFOO0FBQ0EsU0FBSyxJQUFJRSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELGNBQWMsQ0FBbEMsRUFBcUNDLEdBQXJDLEVBQTBDO0FBQ3hDckYsY0FBUStFLElBQVIsQ0FBYU0sSUFBSUYsTUFBakIsRUFBeUJFLElBQUlGLE1BQTdCO0FBQ0Q7QUFDRG5GLFlBQVErRSxJQUFSLENBQWFJLFNBQVNDLFdBQVQsR0FBdUIsQ0FBcEM7O0FBRUFELGNBQVVDLFdBQVY7QUFDQSxXQUFPcEYsT0FBUDtBQUNELEdBWk0sRUFZSixFQVpJLENBQVA7QUFhRDs7QUFFRDs7Ozs7QUFLQSxTQUFTOEQsdUJBQVQsQ0FBaUNSLFVBQWpDLEVBQTZDO0FBQzNDLE1BQUlnQyxRQUFRLElBQVo7O0FBRUEsTUFBSWhDLFdBQVdDLE1BQVgsR0FBb0IsQ0FBeEIsRUFBMkI7QUFDekIrQixZQUFRaEMsV0FBV0YsTUFBWCxDQUNOLFVBQUNDLEdBQUQsRUFBTUksT0FBTjtBQUFBLDBDQUFzQkosR0FBdEIsSUFBMkJBLElBQUlBLElBQUlFLE1BQUosR0FBYSxDQUFqQixJQUFzQkUsUUFBUUYsTUFBekQ7QUFBQSxLQURNLEVBRU4sQ0FBQyxDQUFELENBRk0sRUFHTmdDLEtBSE0sQ0FHQSxDQUhBLEVBR0dqQyxXQUFXQyxNQUhkLENBQVI7QUFJRDs7QUFFRCxTQUFPLHNCQUFPLHNCQUFZRCxVQUFaLENBQVAsRUFBZ0NnQyxLQUFoQyxFQUF1QyxDQUF2QyxDQUFQO0FBQ0QiLCJmaWxlIjoiY2hvcm9wbGV0aC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5cbmNvbnN0IGdsc2xpZnkgPSByZXF1aXJlKCdnbHNsaWZ5Jyk7XG5cbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCBmbGF0dGVuRGVlcCBmcm9tICdsb2Rhc2guZmxhdHRlbmRlZXAnO1xuaW1wb3J0IG5vcm1hbGl6ZSBmcm9tICdnZW9qc29uLW5vcm1hbGl6ZSc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMjU1LCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0R2V0Q29sb3IgPSBmZWF0dXJlID0+IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hvcm9wbGV0aExheWVyIGV4dGVuZHMgTGF5ZXIge1xuXG4gIHN0YXRpYyBsYXllck5hbWUgPSAnQ2hvcm9wbGV0aExheWVyJztcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcih7XG4gICAgICBnZXRDb2xvcjogZGVmYXVsdEdldENvbG9yLFxuICAgICAgZHJhd0NvdW50b3VyOiBmYWxzZSxcbiAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZER5bmFtaWMoe1xuICAgICAgLy8gUHJpbXRpdmUgYXR0cmlidXRlc1xuICAgICAgaW5kaWNlczoge3NpemU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbmRpY2VzLCBpc0luZGV4ZWQ6IHRydWV9LFxuICAgICAgcG9zaXRpb25zOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uc30sXG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc1xuICAgICAgfSxcbiAgICAgIC8vIEluc3RhbmNlZCBhdHRyaWJ1dGVzXG4gICAgICBwaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQaWNraW5nQ29sb3JzLFxuICAgICAgICBub0FsbG9jOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBJbmRleFR5cGUgPSBnbC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSA/XG4gICAgICBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCksXG4gICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICBJbmRleFR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnN0YXRlLmNob3JvcGxldGhzID0gZXh0cmFjdENob3JvcGxldGhzKHByb3BzLmRhdGEpO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFByb3BzLm9wYWNpdHkgIT09IHByb3BzLm9wYWNpdHkpIHtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMoe29wYWNpdHk6IHByb3BzLm9wYWNpdHl9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMuc2NyZWVuVG9EZXZpY2VQaXhlbHModGhpcy5wcm9wcy5zdHJva2VXaWR0aCk7XG4gICAgZ2wubGluZVdpZHRoKGxpbmVXaWR0aCk7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIC8vIFNldHRpbmcgbGluZSB3aWR0aCBiYWNrIHRvIDEgaXMgaGVyZSB0byB3b3JrYXJvdW5kIGEgR29vZ2xlIENocm9tZSBidWdcbiAgICAvLyBnbC5jbGVhcigpIGFuZCBnbC5pc0VuYWJsZWQoKSB3aWxsIHJldHVybiBHTF9JTlZBTElEX1ZBTFVFIGV2ZW4gd2l0aFxuICAgIC8vIGNvcnJlY3QgcGFyYW1ldGVyXG4gICAgLy8gVGhpcyBpcyBub3QgaGFwcGVuaW5nIG9uIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgIGdsLmxpbmVXaWR0aCgxLjApO1xuICB9XG5cbiAgcGljayhvcHRzKSB7XG4gICAgc3VwZXIucGljayhvcHRzKTtcbiAgICBjb25zdCB7aW5mb30gPSBvcHRzO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWNvZGVQaWNraW5nQ29sb3IoaW5mby5jb2xvcik7XG4gICAgY29uc3QgZmVhdHVyZSA9IGluZGV4ID49IDAgPyB0aGlzLnByb3BzLmRhdGEuZmVhdHVyZXNbaW5kZXhdIDogbnVsbDtcbiAgICBpbmZvLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgIGluZm8ub2JqZWN0ID0gZmVhdHVyZTtcbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgLi4uYXNzZW1ibGVTaGFkZXJzKGdsLCB7XG4gICAgICAgIHZzOiBnbHNsaWZ5KCcuL2Nob3JvcGxldGgtbGF5ZXItdmVydGV4Lmdsc2wnKSxcbiAgICAgICAgZnM6IGdsc2xpZnkoJy4vY2hvcm9wbGV0aC1sYXllci1mcmFnbWVudC5nbHNsJylcbiAgICAgIH0pLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiB0aGlzLnByb3BzLmRyYXdDb250b3VyID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVNcbiAgICAgIH0pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgY2hvcm9wbGV0aHNcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5yZWR1Y2UoXG4gICAgICAoYWNjLCBjaG9yb3BsZXRoKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICtcbiAgICAgICAgY2hvcm9wbGV0aC5yZWR1Y2UoKGNvdW50LCBwb2x5Z29uKSA9PiBjb3VudCArIHBvbHlnb24ubGVuZ3RoLCAwKV0sXG4gICAgICBbMF1cbiAgICApO1xuICAgIGNvbnN0IHtJbmRleFR5cGV9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoSW5kZXhUeXBlID09PSBVaW50MTZBcnJheSAmJiBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV0gPiA2NTUzNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyXFwncyBsaW1pdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcChcbiAgICAgIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpID0+IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgP1xuICAgICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIGNob3JvcGxldGggY29udG91clxuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgY2hvcm9wbGV0aHNcbiAgICAgICAgY2FsY3VsYXRlQ29udG91ckluZGljZXMoY2hvcm9wbGV0aCkubWFwKFxuICAgICAgICAgIGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdXG4gICAgICAgICkgOlxuICAgICAgICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgY2hvcm9wbGV0aHNcbiAgICAgICAgY2FsY3VsYXRlU3VyZmFjZUluZGljZXMoY2hvcm9wbGV0aCkubWFwKFxuICAgICAgICAgIGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEluZGV4VHlwZShmbGF0dGVuRGVlcChpbmRpY2VzKSk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IGZsYXR0ZW5EZWVwKHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMpO1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpO1xuICB9XG5cbiAgY2FsY3VsYXRlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhOiB7ZmVhdHVyZXN9LCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoXG4gICAgICAoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tjaG9yb3BsZXRoLmZlYXR1cmVJbmRleF07XG4gICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IoZmVhdHVyZSkgfHwgREVGQVVMVF9DT0xPUjtcblxuICAgICAgICBpZiAoaXNOYU4oY29sb3JbM10pKSB7XG4gICAgICAgICAgY29sb3JbM10gPSBERUZBVUxUX0NPTE9SWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob3JvcGxldGgubWFwKHBvbHlnb24gPT5cbiAgICAgICAgICBwb2x5Z29uLm1hcCh2ZXJ0ZXggPT4gY29sb3IpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBVaW50OEFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGlja2luZyBjb2xvcnMgY2FsY3VsYXRpb25cbiAgY2FsY3VsYXRlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUpIHtcblxuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKFxuICAgICAgKGNob3JvcGxldGgsIGNob3JvcGxldGhJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7ZmVhdHVyZUluZGV4fSA9IGNob3JvcGxldGg7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/IFswLCAwLCAwXSA6IFtcbiAgICAgICAgICAoZmVhdHVyZUluZGV4ICsgMSkgJSAyNTYsXG4gICAgICAgICAgTWF0aC5mbG9vcigoZmVhdHVyZUluZGV4ICsgMSkgLyAyNTYpICUgMjU2LFxuICAgICAgICAgIE1hdGguZmxvb3IoKGZlYXR1cmVJbmRleCArIDEpIC8gMjU2IC8gMjU2KSAlIDI1Nl07XG4gICAgICAgIHJldHVybiBjaG9yb3BsZXRoLm1hcChwb2x5Z29uID0+XG4gICAgICAgICAgcG9seWdvbi5tYXAodmVydGV4ID0+IGNvbG9yKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDhBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbiAgfVxufVxuXG4vKlxuICogY29udmVydHMgbGlzdCBvZiBmZWF0dXJlcyBmcm9tIGEgR2VvSlNPTiBvYmplY3QgdG8gYSBsaXN0IG9mIEdlb0pTT05cbiAqIHBvbHlnb24tc3R5bGUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZ2VvanNvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXVtdfSBhcnJheSBvZiBjaG9yb3BsZXRoc1xuICovXG5mdW5jdGlvbiBleHRyYWN0Q2hvcm9wbGV0aHMoZGF0YSkge1xuICBjb25zdCBub3JtYWxpemVkR2VvanNvbiA9IG5vcm1hbGl6ZShkYXRhKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgbm9ybWFsaXplZEdlb2pzb24uZmVhdHVyZXMubWFwKChmZWF0dXJlLCBmZWF0dXJlSW5kZXgpID0+IHtcbiAgICBjb25zdCBjaG9yb3BsZXRocyA9IGZlYXR1cmVUb0Nob3JvcGxldGhzKGZlYXR1cmUpO1xuICAgIGNob3JvcGxldGhzLmZvckVhY2goY2hvcm9wbGV0aCA9PiB7XG4gICAgICBjaG9yb3BsZXRoLmZlYXR1cmVJbmRleCA9IGZlYXR1cmVJbmRleDtcbiAgICB9KTtcbiAgICByZXN1bHQucHVzaCguLi5jaG9yb3BsZXRocyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogY29udmVydHMgb25lIEdlb0pTT04gZmVhdHVyZXMgZnJvbSBvYmplY3QgdG8gYSBsaXN0IG9mIEdlb0pTT04gcG9seWdvbi1zdHlsZVxuICogY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZ2VvanNvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXVtdfSBhcnJheSBvZiBjaG9yb3BsZXRoc1xuICovXG5mdW5jdGlvbiBmZWF0dXJlVG9DaG9yb3BsZXRocyhmZWF0dXJlKSB7XG4gIGNvbnN0IHtjb29yZGluYXRlcywgdHlwZX0gPSBmZWF0dXJlLmdlb21ldHJ5O1xuICBsZXQgY2hvcm9wbGV0aHM7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgY2hvcm9wbGV0aHMgPSBjb29yZGluYXRlcztcbiAgICBicmVhaztcbiAgY2FzZSAnUG9seWdvbic6XG4gICAgY2hvcm9wbGV0aHMgPSBbY29vcmRpbmF0ZXNdO1xuICAgIGJyZWFrO1xuICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAvLyBjcmVhdGUgYSBMaW5lU3RyaW5nTGF5ZXIgZm9yIExpbmVTdHJpbmcgYW5kIE11bHRpTGluZVN0cmluZz9cbiAgICBjaG9yb3BsZXRocyA9IFtbY29vcmRpbmF0ZXNdXTtcbiAgICBicmVhaztcbiAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjaG9yb3BsZXRocyA9IGNvb3JkaW5hdGVzLm1hcChjb29yZHMgPT4gW2Nvb3Jkc10pO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIGNob3JvcGxldGhzID0gW107XG4gIH1cbiAgcmV0dXJuIGNob3JvcGxldGhzLm1hcChcbiAgICBjaG9yb3BsZXRoID0+IGNob3JvcGxldGgubWFwKFxuICAgICAgcG9seWdvbiA9PiBwb2x5Z29uLm1hcChcbiAgICAgICAgY29vcmRpbmF0ZSA9PiBbY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSB8fCAwXVxuICAgICAgKVxuICAgIClcbiAgKTtcbn1cblxuLypcbiAqIGdldCB2ZXJ0ZXggaW5kaWNlcyBmb3IgZHJhd2luZyBjaG9yb3BsZXRoIGNvbnRvdXJcbiAqIEBwYXJhbSB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW119IGNob3JvcGxldGhcbiAqIEByZXR1cm5zIHtbTnVtYmVyXX0gaW5kaWNlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250b3VySW5kaWNlcyhjaG9yb3BsZXRoKSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIHJldHVybiBjaG9yb3BsZXRoLnJlZHVjZSgoYWNjLCBwb2x5Z29uKSA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIGdsLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMiwgbi0yLCBuLTFdXG4gICAgY29uc3QgaW5kaWNlcyA9IFsuLi5hY2MsIG9mZnNldF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0ICsgbnVtVmVydGljZXMgLSAxKTtcblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSwgW10pO1xufVxuXG4vKlxuICogZ2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNob3JvcGxldGggbWVzaFxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY2hvcm9wbGV0aFxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKGNob3JvcGxldGgpIHtcbiAgbGV0IGhvbGVzID0gbnVsbDtcblxuICBpZiAoY2hvcm9wbGV0aC5sZW5ndGggPiAxKSB7XG4gICAgaG9sZXMgPSBjaG9yb3BsZXRoLnJlZHVjZShcbiAgICAgIChhY2MsIHBvbHlnb24pID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBwb2x5Z29uLmxlbmd0aF0sXG4gICAgICBbMF1cbiAgICApLnNsaWNlKDEsIGNob3JvcGxldGgubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBlYXJjdXQoZmxhdHRlbkRlZXAoY2hvcm9wbGV0aCksIGhvbGVzLCAzKTtcbn1cbiJdfQ==