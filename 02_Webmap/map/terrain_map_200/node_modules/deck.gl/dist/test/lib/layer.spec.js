'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _tapeCatch = require('tape-catch');

var _tapeCatch2 = _interopRequireDefault(_tapeCatch);

require('luma.gl/headless');

var _ = require('../..');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dataVariants = [{ data: ['a', 'b', 'c'], size: 3 }
//  {data: new Map('a', 'b', 'c'), size: 3},
//  {data: {a: 'a', b: 'b', c: 'c'}, size: 3}
];

var LAYER_PROPS = {
  id: 'testLayer',
  data: []
};
var LAYER_PROPS_ZEROES = {
  id: 'testLayer',
  data: []
};

(0, _tapeCatch2.default)('Layer#constructor', function (t) {
  var layer = new _.Layer(LAYER_PROPS);
  t.ok(layer, 'Layer created');
  t.end();
});

(0, _tapeCatch2.default)('Layer#constructor with zeroes', function (t) {
  var layer = new _.Layer(LAYER_PROPS_ZEROES);
  t.ok(layer, 'Layer created');
  t.end();
});

// test('Layer#constructor with bad or missing props', t => {
//   t.throws(
//     () => new Layer({...LAYER_PROPS, zoom: undefined}),
//     /Property zoom undefined in layer testLayer/,
//     'Expected invalid prop to throw an error'
//   );

//   t.end();
// });

(0, _tapeCatch2.default)('Layer#getNumInstances', function (t) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = dataVariants[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var dataVariant = _step.value;

      var layer = new _.Layer(_extends({}, LAYER_PROPS, {
        data: dataVariant.data
      }));
      t.equal(layer.getNumInstances(), dataVariant.size);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  t.end();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90ZXN0L2xpYi9sYXllci5zcGVjLmpzIl0sIm5hbWVzIjpbImRhdGFWYXJpYW50cyIsImRhdGEiLCJzaXplIiwiTEFZRVJfUFJPUFMiLCJpZCIsIkxBWUVSX1BST1BTX1pFUk9FUyIsImxheWVyIiwidCIsIm9rIiwiZW5kIiwiZGF0YVZhcmlhbnQiLCJlcXVhbCIsImdldE51bUluc3RhbmNlcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxJQUFNQSxlQUFlLENBQ25CLEVBQUNDLE1BQU0sQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsQ0FBUCxFQUF3QkMsTUFBTSxDQUE5QjtBQUNBO0FBQ0E7QUFIbUIsQ0FBckI7O0FBTUEsSUFBTUMsY0FBYztBQUNsQkMsTUFBSSxXQURjO0FBRWxCSCxRQUFNO0FBRlksQ0FBcEI7QUFJQSxJQUFNSSxxQkFBcUI7QUFDekJELE1BQUksV0FEcUI7QUFFekJILFFBQU07QUFGbUIsQ0FBM0I7O0FBS0EseUJBQUssbUJBQUwsRUFBMEIsYUFBSztBQUM3QixNQUFNSyxRQUFRLFlBQVVILFdBQVYsQ0FBZDtBQUNBSSxJQUFFQyxFQUFGLENBQUtGLEtBQUwsRUFBWSxlQUFaO0FBQ0FDLElBQUVFLEdBQUY7QUFDRCxDQUpEOztBQU1BLHlCQUFLLCtCQUFMLEVBQXNDLGFBQUs7QUFDekMsTUFBTUgsUUFBUSxZQUFVRCxrQkFBVixDQUFkO0FBQ0FFLElBQUVDLEVBQUYsQ0FBS0YsS0FBTCxFQUFZLGVBQVo7QUFDQUMsSUFBRUUsR0FBRjtBQUNELENBSkQ7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQUssdUJBQUwsRUFBOEIsYUFBSztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNqQyx5QkFBMEJULFlBQTFCLDhIQUF3QztBQUFBLFVBQTdCVSxXQUE2Qjs7QUFDdEMsVUFBTUosUUFBUSx5QkFDVEgsV0FEUztBQUVaRixjQUFNUyxZQUFZVDtBQUZOLFNBQWQ7QUFJQU0sUUFBRUksS0FBRixDQUFRTCxNQUFNTSxlQUFOLEVBQVIsRUFBaUNGLFlBQVlSLElBQTdDO0FBQ0Q7QUFQZ0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFRakNLLElBQUVFLEdBQUY7QUFDRCxDQVREIiwiZmlsZSI6ImxheWVyLnNwZWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdGVzdCBmcm9tICd0YXBlLWNhdGNoJztcbmltcG9ydCAnbHVtYS5nbC9oZWFkbGVzcyc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLic7XG5cbmNvbnN0IGRhdGFWYXJpYW50cyA9IFtcbiAge2RhdGE6IFsnYScsICdiJywgJ2MnXSwgc2l6ZTogM31cbiAgLy8gIHtkYXRhOiBuZXcgTWFwKCdhJywgJ2InLCAnYycpLCBzaXplOiAzfSxcbiAgLy8gIHtkYXRhOiB7YTogJ2EnLCBiOiAnYicsIGM6ICdjJ30sIHNpemU6IDN9XG5dO1xuXG5jb25zdCBMQVlFUl9QUk9QUyA9IHtcbiAgaWQ6ICd0ZXN0TGF5ZXInLFxuICBkYXRhOiBbXVxufTtcbmNvbnN0IExBWUVSX1BST1BTX1pFUk9FUyA9IHtcbiAgaWQ6ICd0ZXN0TGF5ZXInLFxuICBkYXRhOiBbXVxufTtcblxudGVzdCgnTGF5ZXIjY29uc3RydWN0b3InLCB0ID0+IHtcbiAgY29uc3QgbGF5ZXIgPSBuZXcgTGF5ZXIoTEFZRVJfUFJPUFMpO1xuICB0Lm9rKGxheWVyLCAnTGF5ZXIgY3JlYXRlZCcpO1xuICB0LmVuZCgpO1xufSk7XG5cbnRlc3QoJ0xheWVyI2NvbnN0cnVjdG9yIHdpdGggemVyb2VzJywgdCA9PiB7XG4gIGNvbnN0IGxheWVyID0gbmV3IExheWVyKExBWUVSX1BST1BTX1pFUk9FUyk7XG4gIHQub2sobGF5ZXIsICdMYXllciBjcmVhdGVkJyk7XG4gIHQuZW5kKCk7XG59KTtcblxuLy8gdGVzdCgnTGF5ZXIjY29uc3RydWN0b3Igd2l0aCBiYWQgb3IgbWlzc2luZyBwcm9wcycsIHQgPT4ge1xuLy8gICB0LnRocm93cyhcbi8vICAgICAoKSA9PiBuZXcgTGF5ZXIoey4uLkxBWUVSX1BST1BTLCB6b29tOiB1bmRlZmluZWR9KSxcbi8vICAgICAvUHJvcGVydHkgem9vbSB1bmRlZmluZWQgaW4gbGF5ZXIgdGVzdExheWVyLyxcbi8vICAgICAnRXhwZWN0ZWQgaW52YWxpZCBwcm9wIHRvIHRocm93IGFuIGVycm9yJ1xuLy8gICApO1xuXG4vLyAgIHQuZW5kKCk7XG4vLyB9KTtcblxudGVzdCgnTGF5ZXIjZ2V0TnVtSW5zdGFuY2VzJywgdCA9PiB7XG4gIGZvciAoY29uc3QgZGF0YVZhcmlhbnQgb2YgZGF0YVZhcmlhbnRzKSB7XG4gICAgY29uc3QgbGF5ZXIgPSBuZXcgTGF5ZXIoe1xuICAgICAgLi4uTEFZRVJfUFJPUFMsXG4gICAgICBkYXRhOiBkYXRhVmFyaWFudC5kYXRhXG4gICAgfSk7XG4gICAgdC5lcXVhbChsYXllci5nZXROdW1JbnN0YW5jZXMoKSwgZGF0YVZhcmlhbnQuc2l6ZSk7XG4gIH1cbiAgdC5lbmQoKTtcbn0pO1xuIl19