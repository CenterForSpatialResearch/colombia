'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.checkRendererVendor = checkRendererVendor;
exports.getPlatformShaderDefines = getPlatformShaderDefines;
exports.assembleShaders = assembleShaders;

var _luma = require('luma.gl');

var _shaderChunks = require('./shader-chunks');

var _shaderChunks2 = _interopRequireDefault(_shaderChunks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// Load shader chunks
// import SHADER_CHUNKS from '../../dist/shaderlib/shader-chunks';


function checkRendererVendor(debugInfo, gpuVendor) {
  var vendor = debugInfo.vendor,
      renderer = debugInfo.renderer;

  var result = void 0;
  switch (gpuVendor) {
    case 'nvidia':
      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);
      break;
    case 'intel':
      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);
      break;
    case 'amd':
      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);
      break;
    default:
      result = false;
  }
  return result;
}

function getPlatformShaderDefines(gl) {
  var platformDefines = '';
  var debugInfo = (0, _luma.glGetDebugInfo)(gl);

  if (checkRendererVendor(debugInfo, 'nvidia')) {
    platformDefines += '#define NVIDIA_GPU\n#define NVIDIA_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'intel')) {
    platformDefines += '#define INTEL_GPU\n#define INTEL_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n #define INTEL_TAN_WORKAROUND 1\n';
  } else if (checkRendererVendor(debugInfo, 'amd')) {
    platformDefines += '#define AMD_GPU\n';
  } else {
    platformDefines += '#define DEFAULT_GPU\n';
  }

  return platformDefines;
}

function assembleShader(gl, _ref) {
  var vs = _ref.vs,
      fs = _ref.fs,
      _ref$fp = _ref.fp64,
      fp64 = _ref$fp === undefined ? false : _ref$fp,
      _ref$project = _ref.project,
      project = _ref$project === undefined ? true : _ref$project,
      _ref$project2 = _ref.project64,
      project64 = _ref$project2 === undefined ? false : _ref$project2,
      opts = _objectWithoutProperties(_ref, ['vs', 'fs', 'fp64', 'project', 'project64']);

  if (project64 === true) {
    fp64 = true;
  }
  var source = getPlatformShaderDefines(gl) + '\n';
  opts = _extends({}, opts, { project: project, project64: project64, fp64: fp64 });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(_shaderChunks2.default)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var chunkName = _step.value;

      if (opts[chunkName]) {
        source += _shaderChunks2.default[chunkName].source + '\n';
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  source += vs;
  return source;
}

function assembleShaders(gl, _ref2) {
  var vs = _ref2.vs,
      fs = _ref2.fs,
      opts = _objectWithoutProperties(_ref2, ['vs', 'fs']);

  return {
    gl: gl,
    vs: assembleShader(gl, _extends({}, opts, { vs: vs })),
    fs: fs
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFkZXItdXRpbHMvYXNzZW1ibGUtc2hhZGVycy5qcyJdLCJuYW1lcyI6WyJjaGVja1JlbmRlcmVyVmVuZG9yIiwiZ2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzIiwiYXNzZW1ibGVTaGFkZXJzIiwiZGVidWdJbmZvIiwiZ3B1VmVuZG9yIiwidmVuZG9yIiwicmVuZGVyZXIiLCJyZXN1bHQiLCJtYXRjaCIsImdsIiwicGxhdGZvcm1EZWZpbmVzIiwiYXNzZW1ibGVTaGFkZXIiLCJ2cyIsImZzIiwiZnA2NCIsInByb2plY3QiLCJwcm9qZWN0NjQiLCJvcHRzIiwic291cmNlIiwiT2JqZWN0Iiwia2V5cyIsImNodW5rTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFNZ0JBLG1CLEdBQUFBLG1CO1FBcUJBQyx3QixHQUFBQSx3QjtRQW9EQUMsZSxHQUFBQSxlOztBQS9FaEI7O0FBSUE7Ozs7Ozs7O0FBRkE7QUFDQTs7O0FBR08sU0FBU0YsbUJBQVQsQ0FBNkJHLFNBQTdCLEVBQXdDQyxTQUF4QyxFQUFtRDtBQUFBLE1BQ2pEQyxNQURpRCxHQUM3QkYsU0FENkIsQ0FDakRFLE1BRGlEO0FBQUEsTUFDekNDLFFBRHlDLEdBQzdCSCxTQUQ2QixDQUN6Q0csUUFEeUM7O0FBRXhELE1BQUlDLGVBQUo7QUFDQSxVQUFRSCxTQUFSO0FBQ0EsU0FBSyxRQUFMO0FBQ0VHLGVBQVNGLE9BQU9HLEtBQVAsQ0FBYSxTQUFiLEtBQTJCRixTQUFTRSxLQUFULENBQWUsU0FBZixDQUFwQztBQUNBO0FBQ0YsU0FBSyxPQUFMO0FBQ0VELGVBQVNGLE9BQU9HLEtBQVAsQ0FBYSxRQUFiLEtBQTBCRixTQUFTRSxLQUFULENBQWUsUUFBZixDQUFuQztBQUNBO0FBQ0YsU0FBSyxLQUFMO0FBQ0VELGVBQ0VGLE9BQU9HLEtBQVAsQ0FBYSxNQUFiLEtBQXdCRixTQUFTRSxLQUFULENBQWUsTUFBZixDQUF4QixJQUNBSCxPQUFPRyxLQUFQLENBQWEsTUFBYixDQURBLElBQ3dCRixTQUFTRSxLQUFULENBQWUsTUFBZixDQUYxQjtBQUdBO0FBQ0Y7QUFDRUQsZUFBUyxLQUFUO0FBYkY7QUFlQSxTQUFPQSxNQUFQO0FBQ0Q7O0FBRU0sU0FBU04sd0JBQVQsQ0FBa0NRLEVBQWxDLEVBQXNDO0FBQzNDLE1BQUlDLGtCQUFrQixFQUF0QjtBQUNBLE1BQU1QLFlBQVksMEJBQWVNLEVBQWYsQ0FBbEI7O0FBRUEsTUFBSVQsb0JBQW9CRyxTQUFwQixFQUErQixRQUEvQixDQUFKLEVBQThDO0FBQzVDTztBQUtELEdBTkQsTUFNTyxJQUFJVixvQkFBb0JHLFNBQXBCLEVBQStCLE9BQS9CLENBQUosRUFBNkM7QUFDbERPO0FBTUQsR0FQTSxNQU9BLElBQUlWLG9CQUFvQkcsU0FBcEIsRUFBK0IsS0FBL0IsQ0FBSixFQUEyQztBQUNoRE87QUFHRCxHQUpNLE1BSUE7QUFDTEE7QUFHRDs7QUFFRCxTQUFPQSxlQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsY0FBVCxDQUF3QkYsRUFBeEIsUUFPRztBQUFBLE1BTkRHLEVBTUMsUUFOREEsRUFNQztBQUFBLE1BTERDLEVBS0MsUUFMREEsRUFLQztBQUFBLHFCQUpEQyxJQUlDO0FBQUEsTUFKREEsSUFJQywyQkFKTSxLQUlOO0FBQUEsMEJBSERDLE9BR0M7QUFBQSxNQUhEQSxPQUdDLGdDQUhTLElBR1Q7QUFBQSwyQkFGREMsU0FFQztBQUFBLE1BRkRBLFNBRUMsaUNBRlcsS0FFWDtBQUFBLE1BREVDLElBQ0Y7O0FBQ0QsTUFBSUQsY0FBYyxJQUFsQixFQUF3QjtBQUN0QkYsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFJSSxTQUFZakIseUJBQXlCUSxFQUF6QixDQUFaLE9BQUo7QUFDQVEsc0JBQVdBLElBQVgsSUFBaUJGLGdCQUFqQixFQUEwQkMsb0JBQTFCLEVBQXFDRixVQUFyQztBQUxDO0FBQUE7QUFBQTs7QUFBQTtBQU1ELHlCQUF3QkssT0FBT0MsSUFBUCx3QkFBeEIsOEhBQW9EO0FBQUEsVUFBekNDLFNBQXlDOztBQUNsRCxVQUFJSixLQUFLSSxTQUFMLENBQUosRUFBcUI7QUFDbkJILGtCQUFhLHVCQUFjRyxTQUFkLEVBQXlCSCxNQUF0QztBQUNEO0FBQ0Y7QUFWQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVdEQSxZQUFVTixFQUFWO0FBQ0EsU0FBT00sTUFBUDtBQUNEOztBQUVNLFNBQVNoQixlQUFULENBQXlCTyxFQUF6QixTQUlKO0FBQUEsTUFIREcsRUFHQyxTQUhEQSxFQUdDO0FBQUEsTUFGREMsRUFFQyxTQUZEQSxFQUVDO0FBQUEsTUFERUksSUFDRjs7QUFDRCxTQUFPO0FBQ0xSLFVBREs7QUFFTEcsUUFBSUQsZUFBZUYsRUFBZixlQUF1QlEsSUFBdkIsSUFBNkJMLE1BQTdCLElBRkM7QUFHTEM7QUFISyxHQUFQO0FBS0QiLCJmaWxlIjoiYXNzZW1ibGUtc2hhZGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2xHZXREZWJ1Z0luZm99IGZyb20gJ2x1bWEuZ2wnO1xuXG4vLyBMb2FkIHNoYWRlciBjaHVua3Ncbi8vIGltcG9ydCBTSEFERVJfQ0hVTktTIGZyb20gJy4uLy4uL2Rpc3Qvc2hhZGVybGliL3NoYWRlci1jaHVua3MnO1xuaW1wb3J0IFNIQURFUl9DSFVOS1MgZnJvbSAnLi9zaGFkZXItY2h1bmtzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCBncHVWZW5kb3IpIHtcbiAgY29uc3Qge3ZlbmRvciwgcmVuZGVyZXJ9ID0gZGVidWdJbmZvO1xuICBsZXQgcmVzdWx0O1xuICBzd2l0Y2ggKGdwdVZlbmRvcikge1xuICBjYXNlICdudmlkaWEnOlxuICAgIHJlc3VsdCA9IHZlbmRvci5tYXRjaCgvTlZJRElBL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9OVklESUEvaSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2ludGVsJzpcbiAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL0lOVEVML2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9JTlRFTC9pKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYW1kJzpcbiAgICByZXN1bHQgPVxuICAgICAgdmVuZG9yLm1hdGNoKC9BTUQvaSkgfHwgcmVuZGVyZXIubWF0Y2goL0FNRC9pKSB8fFxuICAgICAgdmVuZG9yLm1hdGNoKC9BVEkvaSkgfHwgcmVuZGVyZXIubWF0Y2goL0FUSS9pKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICByZXN1bHQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzKGdsKSB7XG4gIGxldCBwbGF0Zm9ybURlZmluZXMgPSAnJztcbiAgY29uc3QgZGVidWdJbmZvID0gZ2xHZXREZWJ1Z0luZm8oZ2wpO1xuXG4gIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ252aWRpYScpKSB7XG4gICAgcGxhdGZvcm1EZWZpbmVzICs9IGBcXFxuI2RlZmluZSBOVklESUFfR1BVXG4jZGVmaW5lIE5WSURJQV9GUDY0X1dPUktBUk9VTkQgMVxuI2RlZmluZSBOVklESUFfRVFVQVRJT05fV09SS0FST1VORCAxXG5gO1xuICB9IGVsc2UgaWYgKGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCAnaW50ZWwnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgSU5URUxfR1BVXG4jZGVmaW5lIElOVEVMX0ZQNjRfV09SS0FST1VORCAxXG4jZGVmaW5lIE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EIDFcXG4gXFxcbiNkZWZpbmUgSU5URUxfVEFOX1dPUktBUk9VTkQgMVxuYDtcbiAgfSBlbHNlIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ2FtZCcpKSB7XG4gICAgcGxhdGZvcm1EZWZpbmVzICs9IGBcXFxuI2RlZmluZSBBTURfR1BVXG5gO1xuICB9IGVsc2Uge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgREVGQVVMVF9HUFVcbmA7XG4gIH1cblxuICByZXR1cm4gcGxhdGZvcm1EZWZpbmVzO1xufVxuXG5mdW5jdGlvbiBhc3NlbWJsZVNoYWRlcihnbCwge1xuICB2cyxcbiAgZnMsXG4gIGZwNjQgPSBmYWxzZSxcbiAgcHJvamVjdCA9IHRydWUsXG4gIHByb2plY3Q2NCA9IGZhbHNlLFxuICAuLi5vcHRzXG59KSB7XG4gIGlmIChwcm9qZWN0NjQgPT09IHRydWUpIHtcbiAgICBmcDY0ID0gdHJ1ZTtcbiAgfVxuICBsZXQgc291cmNlID0gYCR7Z2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzKGdsKX1cXG5gO1xuICBvcHRzID0gey4uLm9wdHMsIHByb2plY3QsIHByb2plY3Q2NCwgZnA2NH07XG4gIGZvciAoY29uc3QgY2h1bmtOYW1lIG9mIE9iamVjdC5rZXlzKFNIQURFUl9DSFVOS1MpKSB7XG4gICAgaWYgKG9wdHNbY2h1bmtOYW1lXSkge1xuICAgICAgc291cmNlICs9IGAke1NIQURFUl9DSFVOS1NbY2h1bmtOYW1lXS5zb3VyY2V9XFxuYDtcbiAgICB9XG4gIH1cbiAgc291cmNlICs9IHZzO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXJzKGdsLCB7XG4gIHZzLFxuICBmcyxcbiAgLi4ub3B0c1xufSkge1xuICByZXR1cm4ge1xuICAgIGdsLFxuICAgIHZzOiBhc3NlbWJsZVNoYWRlcihnbCwgey4uLm9wdHMsIHZzfSksXG4gICAgZnNcbiAgfTtcbn1cbiJdfQ==