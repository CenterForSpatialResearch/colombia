'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.COORDINATE_SYSTEM = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class; //
//
// NOTE - viewport is now imported from viewport-mercator-project
// This file is no longer used and will soon be removed
//
//

// View and Projection Matrix calculations for mapbox-js style
// map view properties
//
// ATTRIBUTION:
// Projection matrix creation are intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl.
// See: transform.js in https://github.com/mapbox/mapbox-gl-js

// gl-matrix is a large dependency for a small module.
// However since it is used by mapbox etc, it should already be present
// in most target application bundles.


var _glMatrix = require('gl-matrix');

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

// CONSTANTS

var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE / (2 * PI);

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

// EXPORTS

var COORDINATE_SYSTEM = exports.COORDINATE_SYSTEM = {
  // Positions are interpreted as [lng,lat,elevation], distances as meters
  LNGLAT: 1.0,
  // Positions are interpreted as meter offsets, distances as meters
  METERS: 2.0,
  // Positions and distances are not transformed
  IDENTITY: 0.0
};

var Viewport = (_class = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        mercatorEnabled = _ref.mercatorEnabled;

    _classCallCheck(this, Viewport);

    // Viewport - support undefined arguments
    /* eslint-disable max-len */
    this.width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    this.height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    this.zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    this.latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    this.longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    this.bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    this.pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    this.altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;
    this.mercatorEnabled = mercatorEnabled !== undefined ? mercatorEnabled : true;
    /* eslint-enable max-len */

    // Silently allow apps to send in 0,0
    this.width = this.width || 1;
    this.height = this.height || 1;

    this._initialize();

    // Object.seal(this);
    // Object.freeze(this);
  }
  /* eslint-enable complexity */

  /**
   * Projects latitude and longitude to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */


  _createClass(Viewport, [{
    key: 'project',
    value: function project(lngLatZ) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;

      var _ref3 = this.mercatorEnabled || this.mercator ? this.projectFlat(lngLatZ) : lngLatZ,
          _ref4 = _slicedToArray(_ref3, 2),
          X = _ref4[0],
          Y = _ref4[1];

      var v = [X, Y, lngLatZ[2] || 0, 1];

      // vec4.sub(v, v, [this.centerX, this.centerY, 0, 0]);
      _glMatrix.vec4.transformMat4(v, v, this.pixelProjectionMatrix);
      // Divide by w
      var scale = 1 / v[3];
      _glMatrix.vec4.multiply(v, v, [scale, scale, scale, scale]);
      var x = v[0],
          y = v[1],
          z = v[2];
      // const y2 = topLeft ? this.height - 1 - y : y;

      var y2 = topLeft ? this.height - y : y;
      return lngLatZ.length === 2 ? [x, y2] : [x, y2, z];
    }

    /**
     * Unproject pixel coordinates on screen onto [lon, lat] on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$topLeft = _ref5.topLeft,
          topLeft = _ref5$topLeft === undefined ? true : _ref5$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          _xyz$ = _xyz[0],
          x = _xyz$ === undefined ? 0 : _xyz$,
          _xyz$2 = _xyz[1],
          y = _xyz$2 === undefined ? 0 : _xyz$2,
          _xyz$3 = _xyz[2],
          z = _xyz$3 === undefined ? 0 : _xyz$3;
      // const y2 = topLeft ? this.height - 1 - y : y;


      var y2 = topLeft ? this.height - y : y;
      var v = [x, y2, z, 1];
      _glMatrix.vec4.transformMat4(v, v, this.pixelUnprojectionMatrix);
      var scale = 1 / v[3];
      _glMatrix.vec4.multiply(v, v, [scale, scale, scale, scale]);

      var _unprojectFlat = this.unprojectFlat(v),
          _unprojectFlat2 = _slicedToArray(_unprojectFlat, 2),
          x0 = _unprojectFlat2[0],
          y0 = _unprojectFlat2[1];

      var z0 = v[2];

      return xyz.length === 2 ? [x0, y0] : [x0, y0, z0];
    }

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     *
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref6) {
      var _ref7 = _slicedToArray(_ref6, 2),
          lng = _ref7[0],
          lat = _ref7[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      scale = scale * WORLD_SCALE;
      var lambda2 = lng * DEGREES_TO_RADIANS;
      var phi2 = lat * DEGREES_TO_RADIANS;
      var x = scale * (lambda2 + PI);
      var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));
      return [x, y];
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(_ref8) {
      var _ref9 = _slicedToArray(_ref8, 2),
          x = _ref9[0],
          y = _ref9[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      scale = scale * WORLD_SCALE;
      var lambda2 = x / scale - PI;
      var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale)) - PI_4);
      return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
    }
  }, {
    key: 'getProjections',
    value: function getProjections() {
      return {
        pixelProjectionMatrix: this.pixelProjectionMatrix,
        pixelUnprojectionMatrix: this.pixelUnprojectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix
      };
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return {
        pixelsPerMeter: this.pixelsPerMeter,
        metersPerPixel: this.metersPerPixel
      };
    }

    // INTERNAL METHODS

    /* eslint-disable max-statements */

  }, {
    key: '_initialize',
    value: function _initialize() {
      // Scale
      this.scale = Math.pow(2, this.zoom);
      this.worldSize = TILE_SIZE * this.scale;
      this.tileZoom = Math.floor(this.zoom);
      this.zoomFraction = this.zoom - Math.floor(this.zoom);

      // Bearing
      this.bearingRadians = this.bearing / 180 * Math.PI;
      this.bearingRotationMatrix = _glMatrix.mat2.create();
      _glMatrix.mat2.rotate(this.bearingRotationMatrix, this.bearingRotationMatrix, this.bearing);

      // Pitch
      this.originalPitch = this.pitch;
      this.pitch = Math.min(60, this.pitch);
      this.pitchRadians = this.pitch / 180 * Math.PI;

      // Altitude
      this.originalAltitude = this.altitude;
      this.altitude = Math.max(0.75, this.altitude);

      // Center x, y
      this.center = this.projectFlat([this.longitude, this.latitude]);
      this.centerX = this.center[0];
      this.centerY = this.center[1];

      // Find the distance from the center point to the center top
      // in altitude units using law of sines.
      this.halfFov = Math.atan(0.5 / this.altitude);
      this.topHalfSurfaceDistance = Math.sin(this.halfFov) * this.altitude / Math.sin(Math.PI / 2 - this.pitchRadians - this.halfFov);

      // Calculate z value of the farthest fragment that should be rendered.
      this.farZ = Math.cos(Math.PI / 2 - this.pitchRadians) * this.topHalfSurfaceDistance + this.altitude;

      // Calculate matrices and scales needed for projection
      this._calculateDistanceScales();
      this._calculateTransformationMatrices();
      this._calculateWebGLMatrices();
    }
    /* eslint-enable max-statements */

    /**
     * Calculate distance scales in meters around current lat/lon, both for
     * degrees and pixels.
     * In mercator projection mode, the distance scales vary significantly
     * with latitude.
     */

  }, {
    key: '_calculateDistanceScales',
    value: function _calculateDistanceScales() {
      // Approximately 111km per degree at equator
      var METERS_PER_DEGREE = 111000;
      var latitude = this.latitude,
          longitude = this.longitude;


      var latCosine = Math.cos(latitude * Math.PI / 180);

      var metersPerDegree = METERS_PER_DEGREE * latCosine;

      // Calculate number of pixels occupied by one degree longitude
      // around current lat/lon
      var pixelsPerDegreeX = _glMatrix.vec2.distance(this.projectFlat([longitude + 0.5, latitude]), this.projectFlat([longitude - 0.5, latitude]));
      // Calculate number of pixels occupied by one degree latitude
      // around current lat/lon
      var pixelsPerDegreeY = _glMatrix.vec2.distance(this.projectFlat([longitude, latitude + 0.5]), this.projectFlat([longitude, latitude - 0.5]));

      var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
      var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
      var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;

      // const scale = 0.95;
      // const pixelsPerMeter = [
      //   pixelsPerMeterX * scale, pixelsPerMeterY * scale, pixelsPerMeterZ * scale
      // ];
      var altPixelsPerMeter = this.worldSize / (4e7 * latCosine);
      var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
      var metersPerPixel = [1 / pixelsPerMeterX, 1 / pixelsPerMeterY, 1 / pixelsPerMeterZ];

      // Main results, used for scaling offsets
      this.pixelsPerMeter = pixelsPerMeter;
      // Additional results
      this.metersPerPixel = metersPerPixel;
      // metersPerDegree,
      // degreesPerMeter: 1 / metersPerDegree
    }

    // Note: As usual, matrix operation orders should be read in reverse
    // since vectors will be multiplied in from the right during transformation
    /* eslint-disable max-statements */

  }, {
    key: '_calculateTransformationMatrices',
    value: function _calculateTransformationMatrices() {
      // PROJECTION MATRIX: PROJECTS FROM CAMERA SPACE TO CLIPSPACE
      /* eslint-disable no-inline-comments */
      this.projectionMatrix = _glMatrix.mat4.perspective(this._createMat4(), 2 * Math.atan(this.height / 2 / this.altitude), // fov in radians
      this.width / this.height, // aspect ratio
      0.2, // near plane
      this.farZ * 2 // far plane
      );
      /* eslint-enable no-inline-comments */

      // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
      var vm = this._createMat4();

      // Move camera to altitude
      _glMatrix.mat4.translate(vm, vm, [0, 0, -this.altitude]);

      // After the rotateX, z values are in pixel units. Convert them to
      // altitude units. 1 altitude unit = the screen height.
      _glMatrix.mat4.scale(vm, vm, [1, -1, 1 / this.height]);

      // Rotate by bearing, and then by pitch (which tilts the view)
      _glMatrix.mat4.rotateX(vm, vm, this.pitchRadians);
      _glMatrix.mat4.rotateZ(vm, vm, -this.bearingRadians);

      this.viewMatrix = this._createMat4();
      _glMatrix.mat4.translate(this.viewMatrix, vm, [-this.centerX, -this.centerY, 0]);

      var vpm = this._createMat4();
      _glMatrix.mat4.multiply(vpm, vpm, this.projectionMatrix);
      _glMatrix.mat4.multiply(vpm, vpm, this.viewMatrix);

      this.viewProjectionMatrix = vpm;

      // PIXEL PROJECTION MATRIX
      var m = this._createMat4();

      // Scale with viewport window's width and height in pixels
      _glMatrix.mat4.scale(m, m, [this.width, this.height, 1]);
      // Convert to (0, 1)
      _glMatrix.mat4.translate(m, m, [0.5, 0.5, 0]);
      _glMatrix.mat4.scale(m, m, [0.5, 0.5, 0]);
      // Project to clip space (-1, 1)
      _glMatrix.mat4.multiply(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      var mInverse = this._createMat4();
      _glMatrix.mat4.invert(mInverse, m);
      this.pixelUnprojectionMatrix = mInverse;
    }
    /* eslint-enable max-statements */

    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     *
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */

  }, {
    key: '_calculatePixelProjectionMatrices',
    value: function _calculatePixelProjectionMatrices() {
      var m = this._createMat4();

      // Scale with viewport window's width and height in pixels
      _glMatrix.mat4.scale(m, m, [this.width, this.height, 1]);
      // Convert to (0, 1)
      _glMatrix.mat4.translate(m, m, [0.5, 0.5, 0]);
      _glMatrix.mat4.scale(m, m, [0.5, 0.5, 0]);
      // Project to clip space (-1, 1)
      _glMatrix.mat4.multiply(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      var mInverse = this._createMat4();
      _glMatrix.mat4.invert(mInverse, m);
      this.pixelUnprojectionMatrix = mInverse;
    }

    // Helper, avoids low-precision 32 bit matrices from mat4.create();

  }, {
    key: '_createMat4',
    value: function _createMat4() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
  }]);

  return Viewport;
}(), (_applyDecoratedDescriptor(_class.prototype, 'project', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'project'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'unproject', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'unproject'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'projectFlat', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'projectFlat'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'unprojectFlat', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'unprojectFlat'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'getProjections', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getProjections'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'getDistanceScales', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getDistanceScales'), _class.prototype)), _class);
exports.default = Viewport;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92aWV3cG9ydC9vbGQtdmlld3BvcnQuanMiXSwibmFtZXMiOlsiUEkiLCJNYXRoIiwiUElfNCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlJBRElBTlNfVE9fREVHUkVFUyIsIlRJTEVfU0laRSIsIldPUkxEX1NDQUxFIiwiREVGQVVMVF9NQVBfU1RBVEUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJhbHRpdHVkZSIsIkNPT1JESU5BVEVfU1lTVEVNIiwiTE5HTEFUIiwiTUVURVJTIiwiSURFTlRJVFkiLCJWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwibWVyY2F0b3JFbmFibGVkIiwidW5kZWZpbmVkIiwiX2luaXRpYWxpemUiLCJsbmdMYXRaIiwidG9wTGVmdCIsIm1lcmNhdG9yIiwicHJvamVjdEZsYXQiLCJYIiwiWSIsInYiLCJ0cmFuc2Zvcm1NYXQ0IiwicGl4ZWxQcm9qZWN0aW9uTWF0cml4Iiwic2NhbGUiLCJtdWx0aXBseSIsIngiLCJ5IiwieiIsInkyIiwibGVuZ3RoIiwieHl6IiwicGl4ZWxVbnByb2plY3Rpb25NYXRyaXgiLCJ1bnByb2plY3RGbGF0IiwieDAiLCJ5MCIsInowIiwibG5nIiwibGF0IiwibGFtYmRhMiIsInBoaTIiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsInBpeGVsc1Blck1ldGVyIiwibWV0ZXJzUGVyUGl4ZWwiLCJwb3ciLCJ3b3JsZFNpemUiLCJ0aWxlWm9vbSIsImZsb29yIiwiem9vbUZyYWN0aW9uIiwiYmVhcmluZ1JhZGlhbnMiLCJiZWFyaW5nUm90YXRpb25NYXRyaXgiLCJjcmVhdGUiLCJyb3RhdGUiLCJvcmlnaW5hbFBpdGNoIiwibWluIiwicGl0Y2hSYWRpYW5zIiwib3JpZ2luYWxBbHRpdHVkZSIsIm1heCIsImNlbnRlciIsImNlbnRlclgiLCJjZW50ZXJZIiwiaGFsZkZvdiIsInRvcEhhbGZTdXJmYWNlRGlzdGFuY2UiLCJzaW4iLCJmYXJaIiwiY29zIiwiX2NhbGN1bGF0ZURpc3RhbmNlU2NhbGVzIiwiX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uTWF0cmljZXMiLCJfY2FsY3VsYXRlV2ViR0xNYXRyaWNlcyIsIk1FVEVSU19QRVJfREVHUkVFIiwibGF0Q29zaW5lIiwibWV0ZXJzUGVyRGVncmVlIiwicGl4ZWxzUGVyRGVncmVlWCIsImRpc3RhbmNlIiwicGl4ZWxzUGVyRGVncmVlWSIsInBpeGVsc1Blck1ldGVyWCIsInBpeGVsc1Blck1ldGVyWSIsInBpeGVsc1Blck1ldGVyWiIsImFsdFBpeGVsc1Blck1ldGVyIiwicGVyc3BlY3RpdmUiLCJfY3JlYXRlTWF0NCIsInZtIiwidHJhbnNsYXRlIiwicm90YXRlWCIsInJvdGF0ZVoiLCJ2cG0iLCJtIiwibUludmVyc2UiLCJpbnZlcnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzJCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFFQSxJQUFNQSxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0EsSUFBTUMsY0FBY0QsYUFBYSxJQUFJTCxFQUFqQixDQUFwQjs7QUFFQSxJQUFNTyxvQkFBb0I7QUFDeEJDLFlBQVUsRUFEYztBQUV4QkMsYUFBVyxDQUFDLEdBRlk7QUFHeEJDLFFBQU0sRUFIa0I7QUFJeEJDLFNBQU8sQ0FKaUI7QUFLeEJDLFdBQVMsQ0FMZTtBQU14QkMsWUFBVTtBQU5jLENBQTFCOztB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QjtBQUNBLHFCQUFLUSxNQUFMLENBQVlELFFBQVosRUFBc0JELENBQXRCO0FBQ0EsV0FBSzVELHVCQUFMLEdBQStCNkQsUUFBL0I7QUFDRDs7QUFFRDs7OztrQ0FDYztBQUNaLGFBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUFQO0FBQ0Q7Ozs7O2tCQTVXa0JwRixRIiwiZmlsZSI6Im9sZC12aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy8gTk9URSAtIHZpZXdwb3J0IGlzIG5vdyBpbXBvcnRlZCBmcm9tIHZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3Rcbi8vIFRoaXMgZmlsZSBpcyBubyBsb25nZXIgdXNlZCBhbmQgd2lsbCBzb29uIGJlIHJlbW92ZWRcbi8vXG4vL1xuXG4vLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuLy9cbi8vIEFUVFJJQlVUSU9OOlxuLy8gUHJvamVjdGlvbiBtYXRyaXggY3JlYXRpb24gYXJlIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLlxuLy8gU2VlOiB0cmFuc2Zvcm0uanMgaW4gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanNcblxuLy8gZ2wtbWF0cml4IGlzIGEgbGFyZ2UgZGVwZW5kZW5jeSBmb3IgYSBzbWFsbCBtb2R1bGUuXG4vLyBIb3dldmVyIHNpbmNlIGl0IGlzIHVzZWQgYnkgbWFwYm94IGV0YywgaXQgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudFxuLy8gaW4gbW9zdCB0YXJnZXQgYXBwbGljYXRpb24gYnVuZGxlcy5cbmltcG9ydCB7bWF0MiwgbWF0NCwgdmVjMiwgdmVjNH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBhdXRvYmluZCBmcm9tICdhdXRvYmluZC1kZWNvcmF0b3InO1xuXG4vLyBDT05TVEFOVFNcblxuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBXT1JMRF9TQ0FMRSA9IFRJTEVfU0laRSAvICgyICogUEkpO1xuXG5jb25zdCBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuLy8gRVhQT1JUU1xuXG5leHBvcnQgY29uc3QgQ09PUkRJTkFURV9TWVNURU0gPSB7XG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgW2xuZyxsYXQsZWxldmF0aW9uXSwgZGlzdGFuY2VzIGFzIG1ldGVyc1xuICBMTkdMQVQ6IDEuMCxcbiAgLy8gUG9zaXRpb25zIGFyZSBpbnRlcnByZXRlZCBhcyBtZXRlciBvZmZzZXRzLCBkaXN0YW5jZXMgYXMgbWV0ZXJzXG4gIE1FVEVSUzogMi4wLFxuICAvLyBQb3NpdGlvbnMgYW5kIGRpc3RhbmNlcyBhcmUgbm90IHRyYW5zZm9ybWVkXG4gIElERU5USVRZOiAwLjBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogTWFuYWdlcyBjb29yZGluYXRlIHN5c3RlbSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGRlY2suZ2wuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG5cbiAgICogTm90ZXM6XG4gICAqICAtIE9ubHkgb25lIG9mIGNlbnRlciBvciBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIGJlIHNwZWNpZmllZFxuICAgKiAgLSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIHdoZW4gXCJtZXJjYXRvclwiIGlzIHRydWVcbiAgICogIC0gQWx0aXR1ZGUgaGFzIGEgZGVmYXVsdCB2YWx1ZSB0aGF0IG1hdGNoZXMgYXNzdW1wdGlvbnMgaW4gbWFwYm94LWdsXG4gICAqICAtIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGZvcmNlZCB0byAxIGlmIHN1cHBsaWVkIGFzIDAsIHRvIGF2b2lkXG4gICAqICAgIGRpdmlzaW9uIGJ5IHplcm8uIFRoaXMgaXMgaW50ZW5kZWQgdG8gcmVkdWNlIHRoZSBidXJkZW4gb2YgYXBwcyB0b1xuICAgKiAgICB0byBjaGVjayB2YWx1ZXMgYmVmb3JlIGluc3RhbnRpYXRpbmcgYSBWaWV3cG9ydC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIE1hcCBzdGF0ZVxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsYXRpdHVkZSxcbiAgICBsb25naXR1ZGUsXG4gICAgem9vbSxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nLFxuICAgIGFsdGl0dWRlLFxuICAgIG1lcmNhdG9yRW5hYmxlZFxuICB9ID0ge30pIHtcbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IERFRkFVTFRfTUFQX1NUQVRFLmhlaWdodDtcbiAgICB0aGlzLnpvb20gPSB6b29tICE9PSB1bmRlZmluZWQgPyB6b29tIDogREVGQVVMVF9NQVBfU1RBVEUuem9vbTtcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxvbmdpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxvbmdpdHVkZTtcbiAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nICE9PSB1bmRlZmluZWQgPyBiZWFyaW5nIDogREVGQVVMVF9NQVBfU1RBVEUuYmVhcmluZztcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlICE9PSB1bmRlZmluZWQgPyBhbHRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmFsdGl0dWRlO1xuICAgIHRoaXMubWVyY2F0b3JFbmFibGVkID0gbWVyY2F0b3JFbmFibGVkICE9PSB1bmRlZmluZWQgPyBtZXJjYXRvckVuYWJsZWQgOiB0cnVlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMFxuICAgIHRoaXMud2lkdGggPSB0aGlzLndpZHRoIHx8IDE7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmhlaWdodCB8fCAxO1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuXG4gICAgLy8gT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgLy8gT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICAvKipcbiAgICogUHJvamVjdHMgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSB0byBwaXhlbCBjb29yZGluYXRlcyBpbiB3aW5kb3dcbiAgICogdXNpbmcgdmlld3BvcnQgcHJvamVjdGlvbiBwYXJhbWV0ZXJzXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIHRvIFt4LCB5XVxuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlLCBaXSA9PiBbeCwgeSwgel1cbiAgICogTm90ZTogQnkgZGVmYXVsdCwgcmV0dXJucyB0b3AtbGVmdCBjb29yZGluYXRlcyBmb3IgY2FudmFzL1NWRyB0eXBlIHJlbmRlclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXRaIC0gW2xuZywgbGF0XSBvciBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy50b3BMZWZ0PXRydWUgLSBXaGV0aGVyIHByb2plY3RlZCBjb29yZHMgYXJlIHRvcCBsZWZ0XG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFt4LCB5XSBvciBbeCwgeSwgel0gaW4gdG9wIGxlZnQgY29vcmRzXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgcHJvamVjdChsbmdMYXRaLCB7dG9wTGVmdCA9IHRydWV9ID0ge30pIHtcbiAgICBjb25zdCBbWCwgWV0gPSB0aGlzLm1lcmNhdG9yRW5hYmxlZCB8fCB0aGlzLm1lcmNhdG9yID9cbiAgICAgIHRoaXMucHJvamVjdEZsYXQobG5nTGF0WikgOiBsbmdMYXRaO1xuICAgIGNvbnN0IHYgPSBbWCwgWSwgbG5nTGF0WlsyXSB8fCAwLCAxXTtcblxuICAgIC8vIHZlYzQuc3ViKHYsIHYsIFt0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgMCwgMF0pO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NCh2LCB2LCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgLy8gRGl2aWRlIGJ5IHdcbiAgICBjb25zdCBzY2FsZSA9IDEgLyB2WzNdO1xuICAgIHZlYzQubXVsdGlwbHkodiwgdiwgW3NjYWxlLCBzY2FsZSwgc2NhbGUsIHNjYWxlXSk7XG4gICAgY29uc3QgW3gsIHksIHpdID0gdjtcbiAgICAvLyBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIDEgLSB5IDogeTtcbiAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHkgOiB5O1xuICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFt4LCB5Ml0gOiBbeCwgeTIsIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCBwaXhlbCBjb29yZGluYXRlcyBvbiBzY3JlZW4gb250byBbbG9uLCBsYXRdIG9uIG1hcC5cbiAgICogLSBbeCwgeV0gPT4gW2xuZywgbGF0XVxuICAgKiAtIFt4LCB5LCB6XSA9PiBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFtsbmcsIGxhdCwgWl0gb3IgW1gsIFksIFpdXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgdW5wcm9qZWN0KHh5eiwge3RvcExlZnQgPSB0cnVlfSA9IHt9KSB7XG4gICAgY29uc3QgW3ggPSAwLCB5ID0gMCwgeiA9IDBdID0geHl6O1xuICAgIC8vIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0gMSAtIHkgOiB5O1xuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG4gICAgY29uc3QgdiA9IFt4LCB5MiwgeiwgMV07XG4gICAgdmVjNC50cmFuc2Zvcm1NYXQ0KHYsIHYsIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgpO1xuICAgIGNvbnN0IHNjYWxlID0gMSAvIHZbM107XG4gICAgdmVjNC5tdWx0aXBseSh2LCB2LCBbc2NhbGUsIHNjYWxlLCBzY2FsZSwgc2NhbGVdKTtcbiAgICBjb25zdCBbeDAsIHkwXSA9IHRoaXMudW5wcm9qZWN0RmxhdCh2KTtcbiAgICBjb25zdCBbLCAsIHowXSA9IHY7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeDAsIHkwXSA6IFt4MCwgeTAsIHowXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICAgKiBwZXJzcGVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICovXG4gIEBhdXRvYmluZFxuICBwcm9qZWN0RmxhdChbbG5nLCBsYXRdLCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gICAgY29uc3QgbGFtYmRhMiA9IGxuZyAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgICBjb25zdCBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICAgIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpO1xuICAgIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gICAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gICAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAgICovXG4gIEBhdXRvYmluZFxuICB1bnByb2plY3RGbGF0KFt4LCB5XSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICAgIGNvbnN0IGxhbWJkYTIgPSB4IC8gc2NhbGUgLSBQSTtcbiAgICBjb25zdCBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoUEkgLSB5IC8gc2NhbGUpKSAtIFBJXzQpO1xuICAgIHJldHVybiBbbGFtYmRhMiAqIFJBRElBTlNfVE9fREVHUkVFUywgcGhpMiAqIFJBRElBTlNfVE9fREVHUkVFU107XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgZ2V0UHJvamVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpeGVsUHJvamVjdGlvbk1hdHJpeDogdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsXG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeDogdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4OiB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld01hdHJpeDogdGhpcy52aWV3TWF0cml4LFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogdGhpcy5wcm9qZWN0aW9uTWF0cml4XG4gICAgfTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBnZXREaXN0YW5jZVNjYWxlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGl4ZWxzUGVyTWV0ZXI6IHRoaXMucGl4ZWxzUGVyTWV0ZXIsXG4gICAgICBtZXRlcnNQZXJQaXhlbDogdGhpcy5tZXRlcnNQZXJQaXhlbFxuICAgIH07XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgLy8gU2NhbGVcbiAgICB0aGlzLnNjYWxlID0gTWF0aC5wb3coMiwgdGhpcy56b29tKTtcbiAgICB0aGlzLndvcmxkU2l6ZSA9IFRJTEVfU0laRSAqIHRoaXMuc2NhbGU7XG4gICAgdGhpcy50aWxlWm9vbSA9IE1hdGguZmxvb3IodGhpcy56b29tKTtcbiAgICB0aGlzLnpvb21GcmFjdGlvbiA9IHRoaXMuem9vbSAtIE1hdGguZmxvb3IodGhpcy56b29tKTtcblxuICAgIC8vIEJlYXJpbmdcbiAgICB0aGlzLmJlYXJpbmdSYWRpYW5zID0gdGhpcy5iZWFyaW5nIC8gMTgwICogTWF0aC5QSTtcbiAgICB0aGlzLmJlYXJpbmdSb3RhdGlvbk1hdHJpeCA9IG1hdDIuY3JlYXRlKCk7XG4gICAgbWF0Mi5yb3RhdGUoXG4gICAgICB0aGlzLmJlYXJpbmdSb3RhdGlvbk1hdHJpeCwgdGhpcy5iZWFyaW5nUm90YXRpb25NYXRyaXgsIHRoaXMuYmVhcmluZ1xuICAgICk7XG5cbiAgICAvLyBQaXRjaFxuICAgIHRoaXMub3JpZ2luYWxQaXRjaCA9IHRoaXMucGl0Y2g7XG4gICAgdGhpcy5waXRjaCA9IE1hdGgubWluKDYwLCB0aGlzLnBpdGNoKTtcbiAgICB0aGlzLnBpdGNoUmFkaWFucyA9IHRoaXMucGl0Y2ggLyAxODAgKiBNYXRoLlBJO1xuXG4gICAgLy8gQWx0aXR1ZGVcbiAgICB0aGlzLm9yaWdpbmFsQWx0aXR1ZGUgPSB0aGlzLmFsdGl0dWRlO1xuICAgIHRoaXMuYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCB0aGlzLmFsdGl0dWRlKTtcblxuICAgIC8vIENlbnRlciB4LCB5XG4gICAgdGhpcy5jZW50ZXIgPSB0aGlzLnByb2plY3RGbGF0KFt0aGlzLmxvbmdpdHVkZSwgdGhpcy5sYXRpdHVkZV0pO1xuICAgIHRoaXMuY2VudGVyWCA9IHRoaXMuY2VudGVyWzBdO1xuICAgIHRoaXMuY2VudGVyWSA9IHRoaXMuY2VudGVyWzFdO1xuXG4gICAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wXG4gICAgLy8gaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICAgIHRoaXMuaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyB0aGlzLmFsdGl0dWRlKTtcbiAgICB0aGlzLnRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPVxuICAgICAgTWF0aC5zaW4odGhpcy5oYWxmRm92KSAqIHRoaXMuYWx0aXR1ZGUgL1xuICAgICAgTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSB0aGlzLnBpdGNoUmFkaWFucyAtIHRoaXMuaGFsZkZvdik7XG5cbiAgICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgdGhpcy5mYXJaID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgLSB0aGlzLnBpdGNoUmFkaWFucykgKlxuICAgICAgdGhpcy50b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgdGhpcy5hbHRpdHVkZTtcblxuICAgIC8vIENhbGN1bGF0ZSBtYXRyaWNlcyBhbmQgc2NhbGVzIG5lZWRlZCBmb3IgcHJvamVjdGlvblxuICAgIHRoaXMuX2NhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb25NYXRyaWNlcygpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZVdlYkdMTWF0cmljZXMoKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gICAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAgICogSW4gbWVyY2F0b3IgcHJvamVjdGlvbiBtb2RlLCB0aGUgZGlzdGFuY2Ugc2NhbGVzIHZhcnkgc2lnbmlmaWNhbnRseVxuICAgKiB3aXRoIGxhdGl0dWRlLlxuICAgKi9cbiAgX2NhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKCkge1xuICAgIC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG4gICAgY29uc3QgTUVURVJTX1BFUl9ERUdSRUUgPSAxMTEwMDA7XG4gICAgY29uc3Qge2xhdGl0dWRlLCBsb25naXR1ZGV9ID0gdGhpcztcblxuICAgIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgICBjb25zdCBtZXRlcnNQZXJEZWdyZWUgPSBNRVRFUlNfUEVSX0RFR1JFRSAqIGxhdENvc2luZTtcblxuICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbG9uZ2l0dWRlXG4gICAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyLmRpc3RhbmNlKFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlICsgMC41LCBsYXRpdHVkZV0pLFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlIC0gMC41LCBsYXRpdHVkZV0pXG4gICAgKTtcbiAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxhdGl0dWRlXG4gICAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSB2ZWMyLmRpc3RhbmNlKFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSArIDAuNV0pLFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSAtIDAuNV0pXG4gICAgKTtcblxuICAgIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gICAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJZID0gcGl4ZWxzUGVyRGVncmVlWSAvIG1ldGVyc1BlckRlZ3JlZTtcbiAgICBjb25zdCBwaXhlbHNQZXJNZXRlclogPSAocGl4ZWxzUGVyTWV0ZXJYICsgcGl4ZWxzUGVyTWV0ZXJZKSAvIDI7XG5cbiAgICAvLyBjb25zdCBzY2FsZSA9IDAuOTU7XG4gICAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbXG4gICAgLy8gICBwaXhlbHNQZXJNZXRlclggKiBzY2FsZSwgcGl4ZWxzUGVyTWV0ZXJZICogc2NhbGUsIHBpeGVsc1Blck1ldGVyWiAqIHNjYWxlXG4gICAgLy8gXTtcbiAgICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlciA9IHRoaXMud29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gICAgY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbXG4gICAgICBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyXG4gICAgXTtcbiAgICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFtcbiAgICAgIDEgLyBwaXhlbHNQZXJNZXRlclgsIDEgLyBwaXhlbHNQZXJNZXRlclksIDEgLyBwaXhlbHNQZXJNZXRlclpcbiAgICBdO1xuXG4gICAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBzY2FsaW5nIG9mZnNldHNcbiAgICB0aGlzLnBpeGVsc1Blck1ldGVyID0gcGl4ZWxzUGVyTWV0ZXI7XG4gICAgLy8gQWRkaXRpb25hbCByZXN1bHRzXG4gICAgdGhpcy5tZXRlcnNQZXJQaXhlbCA9IG1ldGVyc1BlclBpeGVsO1xuICAgIC8vIG1ldGVyc1BlckRlZ3JlZSxcbiAgICAvLyBkZWdyZWVzUGVyTWV0ZXI6IDEgLyBtZXRlcnNQZXJEZWdyZWVcbiAgfVxuXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGluIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfY2FsY3VsYXRlVHJhbnNmb3JtYXRpb25NYXRyaWNlcygpIHtcbiAgICAvLyBQUk9KRUNUSU9OIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBDQU1FUkEgU1BBQ0UgVE8gQ0xJUFNQQUNFXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8taW5saW5lLWNvbW1lbnRzICovXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5wZXJzcGVjdGl2ZShcbiAgICAgIHRoaXMuX2NyZWF0ZU1hdDQoKSxcbiAgICAgIDIgKiBNYXRoLmF0YW4oKHRoaXMuaGVpZ2h0IC8gMikgLyB0aGlzLmFsdGl0dWRlKSwgLy8gZm92IGluIHJhZGlhbnNcbiAgICAgIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgICAwLjIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lYXIgcGxhbmVcbiAgICAgIHRoaXMuZmFyWiAqIDIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFyIHBsYW5lXG4gICAgKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWlubGluZS1jb21tZW50cyAqL1xuXG4gICAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIEZST00gVklSVFVBTCBQSVhFTFMgVE8gQ0FNRVJBIFNQQUNFXG4gICAgY29uc3Qgdm0gPSB0aGlzLl9jcmVhdGVNYXQ0KCk7XG5cbiAgICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZVxuICAgIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC10aGlzLmFsdGl0dWRlXSk7XG5cbiAgICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgICAvLyBhbHRpdHVkZSB1bml0cy4gMSBhbHRpdHVkZSB1bml0ID0gdGhlIHNjcmVlbiBoZWlnaHQuXG4gICAgbWF0NC5zY2FsZSh2bSwgdm0sIFsxLCAtMSwgMSAvIHRoaXMuaGVpZ2h0XSk7XG5cbiAgICAvLyBSb3RhdGUgYnkgYmVhcmluZywgYW5kIHRoZW4gYnkgcGl0Y2ggKHdoaWNoIHRpbHRzIHRoZSB2aWV3KVxuICAgIG1hdDQucm90YXRlWCh2bSwgdm0sIHRoaXMucGl0Y2hSYWRpYW5zKTtcbiAgICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCAtdGhpcy5iZWFyaW5nUmFkaWFucyk7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB0aGlzLl9jcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC50cmFuc2xhdGUodGhpcy52aWV3TWF0cml4LCB2bSwgWy10aGlzLmNlbnRlclgsIC10aGlzLmNlbnRlclksIDBdKTtcblxuICAgIGNvbnN0IHZwbSA9IHRoaXMuX2NyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHRoaXMudmlld01hdHJpeCk7XG5cbiAgICB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdnBtO1xuXG4gICAgLy8gUElYRUwgUFJPSkVDVElPTiBNQVRSSVhcbiAgICBjb25zdCBtID0gdGhpcy5fY3JlYXRlTWF0NCgpO1xuXG4gICAgLy8gU2NhbGUgd2l0aCB2aWV3cG9ydCB3aW5kb3cncyB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVsc1xuICAgIG1hdDQuc2NhbGUobSwgbSwgW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAxXSk7XG4gICAgLy8gQ29udmVydCB0byAoMCwgMSlcbiAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMC41LCAwLjUsIDBdKTtcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFswLjUsIDAuNSwgMF0pO1xuICAgIC8vIFByb2plY3QgdG8gY2xpcCBzcGFjZSAoLTEsIDEpXG4gICAgbWF0NC5tdWx0aXBseShtLCBtLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4KTtcbiAgICB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG07XG5cbiAgICBjb25zdCBtSW52ZXJzZSA9IHRoaXMuX2NyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0LmludmVydChtSW52ZXJzZSwgbSk7XG4gICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1JbnZlcnNlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKipcbiAgICogQnVpbGRzIG1hdHJpY2VzIHRoYXQgY29udmVydHMgcHJlcHJvamVjdGVkIGxuZ0xhdHMgdG8gc2NyZWVuIHBpeGVsc1xuICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICpcbiAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAqIE5vdGU6IFN0YXJ0cyB3aXRoIHRoZSBHTCBwcm9qZWN0aW9uIG1hdHJpeCBhbmQgYWRkcyBzdGVwcyB0byB0aGVcbiAgICogICAgICAgc2NhbGUgYW5kIHRyYW5zbGF0ZSB0aGF0IG1hdHJpeCBvbnRvIHRoZSB3aW5kb3cuXG4gICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgKiAgICAgICBhbmQgZG9lcyBub3QgbmVlZCB0aGlzIHN0ZXAuXG4gICAqL1xuICBfY2FsY3VsYXRlUGl4ZWxQcm9qZWN0aW9uTWF0cmljZXMoKSB7XG4gICAgY29uc3QgbSA9IHRoaXMuX2NyZWF0ZU1hdDQoKTtcblxuICAgIC8vIFNjYWxlIHdpdGggdmlld3BvcnQgd2luZG93J3Mgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHNcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMV0pO1xuICAgIC8vIENvbnZlcnQgdG8gKDAsIDEpXG4gICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzAuNSwgMC41LCAwXSk7XG4gICAgbWF0NC5zY2FsZShtLCBtLCBbMC41LCAwLjUsIDBdKTtcbiAgICAvLyBQcm9qZWN0IHRvIGNsaXAgc3BhY2UgKC0xLCAxKVxuICAgIG1hdDQubXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuXG4gICAgY29uc3QgbUludmVyc2UgPSB0aGlzLl9jcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5pbnZlcnQobUludmVyc2UsIG0pO1xuICAgIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtSW52ZXJzZTtcbiAgfVxuXG4gIC8vIEhlbHBlciwgYXZvaWRzIGxvdy1wcmVjaXNpb24gMzIgYml0IG1hdHJpY2VzIGZyb20gbWF0NC5jcmVhdGUoKTtcbiAgX2NyZWF0ZU1hdDQoKSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgfVxufVxuIl19