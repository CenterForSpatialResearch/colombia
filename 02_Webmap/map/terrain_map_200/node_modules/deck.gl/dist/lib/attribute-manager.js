'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable guard-for-in */


var _luma = require('luma.gl');

var _utils = require('./utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function noop() {}

var AttributeManager = function () {
  /**
   * @classdesc
   * Automated attribute generation and management. Suitable when a set of
   * vertex shader attributes are generated by iteration over a data array,
   * and updates to these attributes are needed either when the data itself
   * changes, or when other data relevant to the calculations change.
   *
   * - First the application registers descriptions of its dynamic vertex
   *   attributes using AttributeManager.add().
   * - Then, when any change that affects attributes is detected by the
   *   application, the app will call AttributeManager.invalidate().
   * - Finally before it renders, it calls AttributeManager.update() to
   *   ensure that attributes are automatically rebuilt if anything has been
   *   invalidated.
   *
   * The application provided update functions describe how attributes
   * should be updated from a data array and are expected to traverse
   * that data array (or iterable) and fill in the attribute's typed array.
   *
   * Note that the attribute manager intentionally does not do advanced
   * change detection, but instead makes it easy to build such detection
   * by offering the ability to "invalidate" each attribute separately.
   *
   * Summary:
   * - keeps track of valid state for each attribute
   * - auto reallocates attributes when needed
   * - auto updates attributes with registered updater functions
   * - allows overriding with application supplied buffers
   *
   * Limitations:
   * - There are currently no provisions for only invalidating a range of
   *   indices in an attribute.
   *
   * @class
   * @param {Object} [props]
   * @param {String} [props.id] - identifier (for debugging)
   */
  function AttributeManager() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$id = _ref.id,
        id = _ref$id === undefined ? 'attribute-manager' : _ref$id,
        otherProps = _objectWithoutProperties(_ref, ['id']);

    _classCallCheck(this, AttributeManager);

    this.id = id;
    this.attributes = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;
    this.userData = {};

    this.onUpdateStart = noop;
    this.onUpdateEnd = noop;
    this.onLog = this._defaultLog;

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    // Marks an attribute for update

  }, {
    key: 'invalidate',
    value: function invalidate(attributeName) {
      var attributes = this.attributes;

      var attribute = attributes[attributeName];
      (0, _assert2.default)(attribute);
      attribute.needsUpdate = true;
      // For performance tuning
      this.onLog(1, 'invalidated attribute ' + attributeName + ' for ' + this.id);
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        this.invalidate(attributeName);
      }
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref2.data,
          numInstances = _ref2.numInstances,
          _ref2$buffers = _ref2.buffers,
          buffers = _ref2$buffers === undefined ? {} : _ref2$buffers,
          _ref2$props = _ref2.props,
          props = _ref2$props === undefined ? {} : _ref2$props,
          _ref2$context = _ref2.context,
          context = _ref2$context === undefined ? {} : _ref2$context,
          opts = _objectWithoutProperties(_ref2, ['data', 'numInstances', 'buffers', 'props', 'context']);

      // First apply any application provided buffers
      this._checkExternalBuffers(buffers, opts);
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        this.onUpdateStart(this.id);
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        this.onUpdateEnd(this.id);
      }
    }

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses luma logger.
     *
     * Note that the app may not be in control of when update is called,
     * so hooks are provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */

  }, {
    key: 'setLogFunctions',
    value: function setLogFunctions() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref3.onLog,
          onUpdateStart = _ref3.onUpdateStart,
          onUpdateEnd = _ref3.onUpdateEnd;

      this.onLog = onLog !== undefined ? onLog : this.onLog;
      this.onUpdateStart = onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;
      this.onUpdateEnd = onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref4) {
      var _ref4$clearChangedFla = _ref4.clearChangedFlags,
          clearChangedFlags = _ref4$clearChangedFla === undefined ? false : _ref4$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {Boolean} - whether a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$clearRedrawFlag = _ref5.clearRedrawFlags,
          clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;

      var redraw = this.needsRedraw;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addDynamic',
    value: function addDynamic(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PRIVATE METHODS

    // Default logger

  }, {
    key: '_defaultLog',
    value: function _defaultLog(level, message) {
      _utils.log.log(level, message);
    }

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = _extends({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        // Check all fields and generate helpful error messages
        this._validate(attributeName, attribute);

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = _extends({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          isIndexed: false,

          // Reserved for application
          userData: {}

        }, attribute, {

          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          size: attribute.size,
          value: attribute.value || null

        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Add to both attributes list (for registration with model)
        this.attributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);
    }
  }, {
    key: '_validate',
    value: function _validate(attributeName, attribute) {
      (0, _assert2.default)(typeof attribute.size === 'number', 'Attribute definition for ' + attributeName + ' missing size');

      // Check the updater
      (0, _assert2.default)(typeof attribute.update === 'function' || attribute.noAlloc, 'Attribute updater for ' + attributeName + ' missing update method');
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var bufferMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var attributes = this.attributes;

      for (var attributeName in bufferMap) {
        var attribute = attributes[attributeName];
        if (!attribute && !opts.ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = bufferMap[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes,
          numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          if (!(buffer instanceof Float32Array)) {
            throw new Error('Attribute properties must be of type Float32Array');
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref6) {
      var numInstances = _ref6.numInstances;
      var attributes = this.attributes;

      (0, _assert2.default)(numInstances !== undefined);

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && attribute.update) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref7) {
      var numInstances = _ref7.numInstances,
          data = _ref7.data,
          props = _ref7.props,
          context = _ref7.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = (0, _luma.glArrayFromType)(attribute.type || _luma.GL.FLOAT);
          attribute.value = new ArrayType(attribute.size * allocCount);
          this.onLog(2, this.id + ':' + attributeName + ' allocated ' + allocCount);
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }

        // Call updater function if needed
        if (attribute.needsUpdate) {
          var update = attribute.update;

          if (update) {
            this.onLog(2, this.id + ':' + attributeName + ' updating ' + numInstances);
            update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
          } else {
            this.onLog(2, this.id + ':' + attributeName + ' missing update function');
          }
          attribute.needsUpdate = false;
          attribute.changed = true;
          this.needsRedraw = true;
        }
      }

      this.allocedInstances = allocCount;
    }
    /* eslint-enable max-statements */

  }]);

  return AttributeManager;
}();

exports.default = AttributeManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXR0cmlidXRlLW1hbmFnZXIuanMiXSwibmFtZXMiOlsibm9vcCIsIkF0dHJpYnV0ZU1hbmFnZXIiLCJpZCIsIm90aGVyUHJvcHMiLCJhdHRyaWJ1dGVzIiwiYWxsb2NlZEluc3RhbmNlcyIsIm5lZWRzUmVkcmF3IiwidXNlckRhdGEiLCJvblVwZGF0ZVN0YXJ0Iiwib25VcGRhdGVFbmQiLCJvbkxvZyIsIl9kZWZhdWx0TG9nIiwiT2JqZWN0Iiwic2VhbCIsInVwZGF0ZXJzIiwiX2FkZCIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGUiLCJuZWVkc1VwZGF0ZSIsImludmFsaWRhdGUiLCJkYXRhIiwibnVtSW5zdGFuY2VzIiwiYnVmZmVycyIsInByb3BzIiwiY29udGV4dCIsIm9wdHMiLCJfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMiLCJfc2V0RXh0ZXJuYWxCdWZmZXJzIiwiX2FuYWx5emVCdWZmZXJzIiwiX3VwZGF0ZUJ1ZmZlcnMiLCJ1bmRlZmluZWQiLCJjbGVhckNoYW5nZWRGbGFncyIsImNoYW5nZWRBdHRyaWJ1dGVzIiwiY2hhbmdlZCIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJpbnN0YW5jZWQiLCJsZXZlbCIsIm1lc3NhZ2UiLCJsb2ciLCJfZXh0cmFQcm9wcyIsIm5ld0F0dHJpYnV0ZXMiLCJfdmFsaWRhdGUiLCJhdHRyaWJ1dGVEYXRhIiwidGFyZ2V0IiwiaXNJbmRleGVkIiwiaXNFeHRlcm5hbEJ1ZmZlciIsIm5lZWRzQWxsb2MiLCJzaXplIiwidmFsdWUiLCJhc3NpZ24iLCJ1cGRhdGUiLCJub0FsbG9jIiwiYnVmZmVyTWFwIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJFcnJvciIsImJ1ZmZlciIsIkZsb2F0MzJBcnJheSIsImF1dG8iLCJsZW5ndGgiLCJhbGxvY0NvdW50IiwiTWF0aCIsIm1heCIsIkFycmF5VHlwZSIsInR5cGUiLCJGTE9BVCIsImNhbGwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztxakJBQUE7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBQ0EsU0FBU0EsSUFBVCxHQUFnQixDQUFFOztJQUVHQyxnQjtBQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQSw4QkFHUTtBQUFBLG1GQUFKLEVBQUk7QUFBQSx1QkFGTkMsRUFFTTtBQUFBLFFBRk5BLEVBRU0sMkJBRkQsbUJBRUM7QUFBQSxRQURIQyxVQUNHOztBQUFBOztBQUNOLFNBQUtELEVBQUwsR0FBVUEsRUFBVjtBQUNBLFNBQUtFLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLQyxnQkFBTCxHQUF3QixDQUFDLENBQXpCO0FBQ0EsU0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsRUFBaEI7O0FBRUEsU0FBS0MsYUFBTCxHQUFxQlIsSUFBckI7QUFDQSxTQUFLUyxXQUFMLEdBQW1CVCxJQUFuQjtBQUNBLFNBQUtVLEtBQUwsR0FBYSxLQUFLQyxXQUFsQjs7QUFFQTtBQUNBQyxXQUFPQyxJQUFQLENBQVksSUFBWjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBb0JJVCxVLEVBQTJCO0FBQUEsVUFBZlUsUUFBZSx1RUFBSixFQUFJOztBQUM3QixXQUFLQyxJQUFMLENBQVVYLFVBQVYsRUFBc0JVLFFBQXRCO0FBQ0Q7O0FBRUQ7Ozs7K0JBQ1dFLGEsRUFBZTtBQUFBLFVBQ2pCWixVQURpQixHQUNILElBREcsQ0FDakJBLFVBRGlCOztBQUV4QixVQUFNYSxZQUFZYixXQUFXWSxhQUFYLENBQWxCO0FBQ0EsNEJBQU9DLFNBQVA7QUFDQUEsZ0JBQVVDLFdBQVYsR0FBd0IsSUFBeEI7QUFDQTtBQUNBLFdBQUtSLEtBQUwsQ0FBVyxDQUFYLDZCQUF1Q00sYUFBdkMsYUFBNEQsS0FBS2QsRUFBakU7QUFDRDs7O29DQUVlO0FBQUEsVUFDUEUsVUFETyxHQUNPLElBRFAsQ0FDUEEsVUFETzs7QUFFZCxXQUFLLElBQU1ZLGFBQVgsSUFBNEJaLFVBQTVCLEVBQXdDO0FBQ3RDLGFBQUtlLFVBQUwsQ0FBZ0JILGFBQWhCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBcUJRO0FBQUEsc0ZBQUosRUFBSTtBQUFBLFVBTk5JLElBTU0sU0FOTkEsSUFNTTtBQUFBLFVBTE5DLFlBS00sU0FMTkEsWUFLTTtBQUFBLGdDQUpOQyxPQUlNO0FBQUEsVUFKTkEsT0FJTSxpQ0FKSSxFQUlKO0FBQUEsOEJBSE5DLEtBR007QUFBQSxVQUhOQSxLQUdNLCtCQUhFLEVBR0Y7QUFBQSxnQ0FGTkMsT0FFTTtBQUFBLFVBRk5BLE9BRU0saUNBRkksRUFFSjtBQUFBLFVBREhDLElBQ0c7O0FBQ047QUFDQSxXQUFLQyxxQkFBTCxDQUEyQkosT0FBM0IsRUFBb0NHLElBQXBDO0FBQ0EsV0FBS0UsbUJBQUwsQ0FBeUJMLE9BQXpCOztBQUVBO0FBQ0EsVUFBSSxLQUFLTSxlQUFMLENBQXFCLEVBQUNQLDBCQUFELEVBQXJCLENBQUosRUFBMEM7QUFDeEMsYUFBS2IsYUFBTCxDQUFtQixLQUFLTixFQUF4QjtBQUNBLGFBQUsyQixjQUFMLENBQW9CLEVBQUNSLDBCQUFELEVBQWVELFVBQWYsRUFBcUJHLFlBQXJCLEVBQTRCQyxnQkFBNUIsRUFBcEI7QUFDQSxhQUFLZixXQUFMLENBQWlCLEtBQUtQLEVBQXRCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O3NDQWdCUTtBQUFBLHNGQUFKLEVBQUk7QUFBQSxVQUhOUSxLQUdNLFNBSE5BLEtBR007QUFBQSxVQUZORixhQUVNLFNBRk5BLGFBRU07QUFBQSxVQUROQyxXQUNNLFNBRE5BLFdBQ007O0FBQ04sV0FBS0MsS0FBTCxHQUFhQSxVQUFVb0IsU0FBVixHQUFzQnBCLEtBQXRCLEdBQThCLEtBQUtBLEtBQWhEO0FBQ0EsV0FBS0YsYUFBTCxHQUNFQSxrQkFBa0JzQixTQUFsQixHQUE4QnRCLGFBQTlCLEdBQThDLEtBQUtBLGFBRHJEO0FBRUEsV0FBS0MsV0FBTCxHQUNFQSxnQkFBZ0JxQixTQUFoQixHQUE0QnJCLFdBQTVCLEdBQTBDLEtBQUtBLFdBRGpEO0FBRUQ7O0FBRUQ7Ozs7Ozs7O29DQUtnQjtBQUNkLGFBQU8sS0FBS0wsVUFBWjtBQUNEOztBQUVEOzs7Ozs7OztnREFLa0Q7QUFBQSx3Q0FBNUIyQixpQkFBNEI7QUFBQSxVQUE1QkEsaUJBQTRCLHlDQUFSLEtBQVE7QUFBQSxVQUN6QzNCLFVBRHlDLEdBQzNCLElBRDJCLENBQ3pDQSxVQUR5Qzs7QUFFaEQsVUFBTTRCLG9CQUFvQixFQUExQjtBQUNBLFdBQUssSUFBTWhCLGFBQVgsSUFBNEJaLFVBQTVCLEVBQXdDO0FBQ3RDLFlBQU1hLFlBQVliLFdBQVdZLGFBQVgsQ0FBbEI7QUFDQSxZQUFJQyxVQUFVZ0IsT0FBZCxFQUF1QjtBQUNyQmhCLG9CQUFVZ0IsT0FBVixHQUFvQmhCLFVBQVVnQixPQUFWLElBQXFCLENBQUNGLGlCQUExQztBQUNBQyw0QkFBa0JoQixhQUFsQixJQUFtQ0MsU0FBbkM7QUFDRDtBQUNGO0FBQ0QsYUFBT2UsaUJBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O3FDQVNnRDtBQUFBLHNGQUFKLEVBQUk7QUFBQSx3Q0FBaENFLGdCQUFnQztBQUFBLFVBQWhDQSxnQkFBZ0MseUNBQWIsS0FBYTs7QUFDOUMsVUFBSUMsU0FBUyxLQUFLN0IsV0FBbEI7QUFDQTZCLGVBQVNBLFVBQVUsS0FBSzdCLFdBQXhCO0FBQ0EsV0FBS0EsV0FBTCxHQUFtQixLQUFLQSxXQUFMLElBQW9CLENBQUM0QixnQkFBeEM7QUFDQSxhQUFPQyxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3FDQUs4QjtBQUFBLFVBQWZBLE1BQWUsdUVBQU4sSUFBTTs7QUFDNUIsV0FBSzdCLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7OytCQU1XRixVLEVBQTJCO0FBQUEsVUFBZlUsUUFBZSx1RUFBSixFQUFJOztBQUNwQyxXQUFLQyxJQUFMLENBQVVYLFVBQVYsRUFBc0JVLFFBQXRCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztpQ0FNYVYsVSxFQUEyQjtBQUFBLFVBQWZVLFFBQWUsdUVBQUosRUFBSTs7QUFDdEMsV0FBS0MsSUFBTCxDQUFVWCxVQUFWLEVBQXNCVSxRQUF0QixFQUFnQyxFQUFDc0IsV0FBVyxDQUFaLEVBQWhDO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Z0NBQ1lDLEssRUFBT0MsTyxFQUFTO0FBQzFCLGlCQUFJQyxHQUFKLENBQVFGLEtBQVIsRUFBZUMsT0FBZjtBQUNEOztBQUVEOzs7O3lCQUNLbEMsVSxFQUE2QztBQUFBLFVBQWpDVSxRQUFpQyx1RUFBdEIsRUFBc0I7O0FBQUEsVUFBbEIwQixXQUFrQix1RUFBSixFQUFJOztBQUVoRCxVQUFNQyxnQkFBZ0IsRUFBdEI7O0FBRUEsV0FBSyxJQUFNekIsYUFBWCxJQUE0QlosVUFBNUIsRUFBd0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsWUFBSVksaUJBQWlCRixRQUFyQixFQUErQjtBQUM3QlYscUJBQVdZLGFBQVgsaUJBQ0taLFdBQVdZLGFBQVgsQ0FETCxFQUVLRixTQUFTRSxhQUFULENBRkw7QUFJRDs7QUFFRCxZQUFNQyxZQUFZYixXQUFXWSxhQUFYLENBQWxCOztBQUVBO0FBQ0EsYUFBSzBCLFNBQUwsQ0FBZTFCLGFBQWYsRUFBOEJDLFNBQTlCOztBQUVBO0FBQ0EsWUFBTTBCO0FBQ0o7QUFDQUMsa0JBQVFkLFNBRko7QUFHSmUscUJBQVcsS0FIUDs7QUFLSjtBQUNBdEMsb0JBQVU7O0FBTk4sV0FTRFUsU0FUQzs7QUFXSjtBQUNBNkIsNEJBQWtCLEtBWmQ7QUFhSkMsc0JBQVksS0FiUjtBQWNKN0IsdUJBQWEsS0FkVDtBQWVKZSxtQkFBUyxLQWZMOztBQWlCSjtBQUNBZSxnQkFBTS9CLFVBQVUrQixJQWxCWjtBQW1CSkMsaUJBQU9oQyxVQUFVZ0MsS0FBVixJQUFtQjs7QUFuQnRCLFdBcUJEVCxXQXJCQyxDQUFOO0FBdUJBO0FBQ0E1QixlQUFPQyxJQUFQLENBQVk4QixhQUFaOztBQUVBO0FBQ0EsYUFBS3ZDLFVBQUwsQ0FBZ0JZLGFBQWhCLElBQWlDMkIsYUFBakM7QUFDRDs7QUFFRC9CLGFBQU9zQyxNQUFQLENBQWMsS0FBSzlDLFVBQW5CLEVBQStCcUMsYUFBL0I7QUFDRDs7OzhCQUVTekIsYSxFQUFlQyxTLEVBQVc7QUFDbEMsNEJBQU8sT0FBT0EsVUFBVStCLElBQWpCLEtBQTBCLFFBQWpDLGdDQUM4QmhDLGFBRDlCOztBQUdBO0FBQ0EsNEJBQU8sT0FBT0MsVUFBVWtDLE1BQWpCLEtBQTRCLFVBQTVCLElBQTBDbEMsVUFBVW1DLE9BQTNELDZCQUMyQnBDLGFBRDNCO0FBRUQ7O0FBRUQ7QUFDQTs7Ozs0Q0FDaUQ7QUFBQSxVQUEzQnFDLFNBQTJCLHVFQUFmLEVBQWU7QUFBQSxVQUFYNUIsSUFBVyx1RUFBSixFQUFJO0FBQUEsVUFDeENyQixVQUR3QyxHQUMxQixJQUQwQixDQUN4Q0EsVUFEd0M7O0FBRS9DLFdBQUssSUFBTVksYUFBWCxJQUE0QnFDLFNBQTVCLEVBQXVDO0FBQ3JDLFlBQU1wQyxZQUFZYixXQUFXWSxhQUFYLENBQWxCO0FBQ0EsWUFBSSxDQUFDQyxTQUFELElBQWMsQ0FBQ1EsS0FBSzZCLHVCQUF4QixFQUFpRDtBQUMvQyxnQkFBTSxJQUFJQyxLQUFKLDZCQUFvQ3ZDLGFBQXBDLENBQU47QUFDRDtBQUNEO0FBQ0E7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7d0NBQ29CcUMsUyxFQUFXO0FBQUEsVUFDdEJqRCxVQURzQixHQUNNLElBRE4sQ0FDdEJBLFVBRHNCO0FBQUEsVUFDVmlCLFlBRFUsR0FDTSxJQUROLENBQ1ZBLFlBRFU7O0FBRzdCOztBQUNBLFdBQUssSUFBTUwsYUFBWCxJQUE0QlosVUFBNUIsRUFBd0M7QUFDdEMsWUFBTWEsWUFBWWIsV0FBV1ksYUFBWCxDQUFsQjtBQUNBLFlBQU13QyxTQUFTSCxVQUFVckMsYUFBVixDQUFmO0FBQ0FDLGtCQUFVNkIsZ0JBQVYsR0FBNkIsS0FBN0I7QUFDQSxZQUFJVSxNQUFKLEVBQVk7QUFDVixjQUFJLEVBQUVBLGtCQUFrQkMsWUFBcEIsQ0FBSixFQUF1QztBQUNyQyxrQkFBTSxJQUFJRixLQUFKLENBQVUsbURBQVYsQ0FBTjtBQUNEO0FBQ0QsY0FBSXRDLFVBQVV5QyxJQUFWLElBQWtCRixPQUFPRyxNQUFQLElBQWlCdEMsZUFBZUosVUFBVStCLElBQWhFLEVBQXNFO0FBQ3BFLGtCQUFNLElBQUlPLEtBQUosQ0FBVSxpREFBVixDQUFOO0FBQ0Q7O0FBRUR0QyxvQkFBVTZCLGdCQUFWLEdBQTZCLElBQTdCO0FBQ0E3QixvQkFBVUMsV0FBVixHQUF3QixLQUF4QjtBQUNBLGNBQUlELFVBQVVnQyxLQUFWLEtBQW9CTyxNQUF4QixFQUFnQztBQUM5QnZDLHNCQUFVZ0MsS0FBVixHQUFrQk8sTUFBbEI7QUFDQXZDLHNCQUFVZ0IsT0FBVixHQUFvQixJQUFwQjtBQUNBLGlCQUFLM0IsV0FBTCxHQUFtQixJQUFuQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Q7O0FBRUE7Ozs7Ozs7MkNBSWdDO0FBQUEsVUFBZmUsWUFBZSxTQUFmQSxZQUFlO0FBQUEsVUFDdkJqQixVQUR1QixHQUNULElBRFMsQ0FDdkJBLFVBRHVCOztBQUU5Qiw0QkFBT2lCLGlCQUFpQlMsU0FBeEI7O0FBRUE7QUFDQSxVQUFJWixjQUFjLEtBQWxCOztBQUVBLFdBQUssSUFBTUYsYUFBWCxJQUE0QlosVUFBNUIsRUFBd0M7QUFDdEMsWUFBTWEsWUFBWWIsV0FBV1ksYUFBWCxDQUFsQjtBQUNBLFlBQUksQ0FBQ0MsVUFBVTZCLGdCQUFmLEVBQWlDO0FBQy9CO0FBQ0EsY0FBTUMsYUFDSjlCLFVBQVVnQyxLQUFWLEtBQW9CLElBQXBCLElBQ0FoQyxVQUFVZ0MsS0FBVixDQUFnQlUsTUFBaEIsR0FBeUIxQyxVQUFVK0IsSUFBbkMsR0FBMEMzQixZQUY1QztBQUdBLGNBQUkwQixjQUFjOUIsVUFBVWtDLE1BQTVCLEVBQW9DO0FBQ2xDbEMsc0JBQVU4QixVQUFWLEdBQXVCLElBQXZCO0FBQ0E3QiwwQkFBYyxJQUFkO0FBQ0Q7QUFDRCxjQUFJRCxVQUFVQyxXQUFkLEVBQTJCO0FBQ3pCQSwwQkFBYyxJQUFkO0FBQ0Q7QUFDRjtBQUNGOztBQUVELGFBQU9BLFdBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7MENBQ3FEO0FBQUEsVUFBckNHLFlBQXFDLFNBQXJDQSxZQUFxQztBQUFBLFVBQXZCRCxJQUF1QixTQUF2QkEsSUFBdUI7QUFBQSxVQUFqQkcsS0FBaUIsU0FBakJBLEtBQWlCO0FBQUEsVUFBVkMsT0FBVSxTQUFWQSxPQUFVO0FBQUEsVUFDNUNwQixVQUQ0QyxHQUM5QixJQUQ4QixDQUM1Q0EsVUFENEM7O0FBR25EOztBQUNBLFVBQU13RCxhQUFhQyxLQUFLQyxHQUFMLENBQVN6QyxZQUFULEVBQXVCLENBQXZCLENBQW5COztBQUVBLFdBQUssSUFBTUwsYUFBWCxJQUE0QlosVUFBNUIsRUFBd0M7QUFDdEMsWUFBTWEsWUFBWWIsV0FBV1ksYUFBWCxDQUFsQjs7QUFFQTtBQUNBLFlBQUlDLFVBQVU4QixVQUFkLEVBQTBCO0FBQ3hCLGNBQU1nQixZQUFZLDJCQUFnQjlDLFVBQVUrQyxJQUFWLElBQWtCLFNBQUdDLEtBQXJDLENBQWxCO0FBQ0FoRCxvQkFBVWdDLEtBQVYsR0FBa0IsSUFBSWMsU0FBSixDQUFjOUMsVUFBVStCLElBQVYsR0FBaUJZLFVBQS9CLENBQWxCO0FBQ0EsZUFBS2xELEtBQUwsQ0FBVyxDQUFYLEVBQWlCLEtBQUtSLEVBQXRCLFNBQTRCYyxhQUE1QixtQkFBdUQ0QyxVQUF2RDtBQUNBM0Msb0JBQVU4QixVQUFWLEdBQXVCLEtBQXZCO0FBQ0E5QixvQkFBVUMsV0FBVixHQUF3QixJQUF4QjtBQUNEOztBQUVEO0FBQ0EsWUFBSUQsVUFBVUMsV0FBZCxFQUEyQjtBQUFBLGNBQ2xCaUMsTUFEa0IsR0FDUmxDLFNBRFEsQ0FDbEJrQyxNQURrQjs7QUFFekIsY0FBSUEsTUFBSixFQUFZO0FBQ1YsaUJBQUt6QyxLQUFMLENBQVcsQ0FBWCxFQUFpQixLQUFLUixFQUF0QixTQUE0QmMsYUFBNUIsa0JBQXNESyxZQUF0RDtBQUNBOEIsbUJBQU9lLElBQVAsQ0FBWTFDLE9BQVosRUFBcUJQLFNBQXJCLEVBQWdDLEVBQUNHLFVBQUQsRUFBT0csWUFBUCxFQUFjRiwwQkFBZCxFQUFoQztBQUNELFdBSEQsTUFHTztBQUNMLGlCQUFLWCxLQUFMLENBQVcsQ0FBWCxFQUFpQixLQUFLUixFQUF0QixTQUE0QmMsYUFBNUI7QUFDRDtBQUNEQyxvQkFBVUMsV0FBVixHQUF3QixLQUF4QjtBQUNBRCxvQkFBVWdCLE9BQVYsR0FBb0IsSUFBcEI7QUFDQSxlQUFLM0IsV0FBTCxHQUFtQixJQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBS0QsZ0JBQUwsR0FBd0J1RCxVQUF4QjtBQUNEO0FBQ0Q7Ozs7Ozs7a0JBM2FtQjNELGdCIiwiZmlsZSI6ImF0dHJpYnV0ZS1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG5pbXBvcnQge0dMLCBnbEFycmF5RnJvbVR5cGV9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJpYnV0ZU1hbmFnZXIge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBBdXRvbWF0ZWQgYXR0cmlidXRlIGdlbmVyYXRpb24gYW5kIG1hbmFnZW1lbnQuIFN1aXRhYmxlIHdoZW4gYSBzZXQgb2ZcbiAgICogdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVzIGFyZSBnZW5lcmF0ZWQgYnkgaXRlcmF0aW9uIG92ZXIgYSBkYXRhIGFycmF5LFxuICAgKiBhbmQgdXBkYXRlcyB0byB0aGVzZSBhdHRyaWJ1dGVzIGFyZSBuZWVkZWQgZWl0aGVyIHdoZW4gdGhlIGRhdGEgaXRzZWxmXG4gICAqIGNoYW5nZXMsIG9yIHdoZW4gb3RoZXIgZGF0YSByZWxldmFudCB0byB0aGUgY2FsY3VsYXRpb25zIGNoYW5nZS5cbiAgICpcbiAgICogLSBGaXJzdCB0aGUgYXBwbGljYXRpb24gcmVnaXN0ZXJzIGRlc2NyaXB0aW9ucyBvZiBpdHMgZHluYW1pYyB2ZXJ0ZXhcbiAgICogICBhdHRyaWJ1dGVzIHVzaW5nIEF0dHJpYnV0ZU1hbmFnZXIuYWRkKCkuXG4gICAqIC0gVGhlbiwgd2hlbiBhbnkgY2hhbmdlIHRoYXQgYWZmZWN0cyBhdHRyaWJ1dGVzIGlzIGRldGVjdGVkIGJ5IHRoZVxuICAgKiAgIGFwcGxpY2F0aW9uLCB0aGUgYXBwIHdpbGwgY2FsbCBBdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoKS5cbiAgICogLSBGaW5hbGx5IGJlZm9yZSBpdCByZW5kZXJzLCBpdCBjYWxscyBBdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSgpIHRvXG4gICAqICAgZW5zdXJlIHRoYXQgYXR0cmlidXRlcyBhcmUgYXV0b21hdGljYWxseSByZWJ1aWx0IGlmIGFueXRoaW5nIGhhcyBiZWVuXG4gICAqICAgaW52YWxpZGF0ZWQuXG4gICAqXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBwcm92aWRlZCB1cGRhdGUgZnVuY3Rpb25zIGRlc2NyaWJlIGhvdyBhdHRyaWJ1dGVzXG4gICAqIHNob3VsZCBiZSB1cGRhdGVkIGZyb20gYSBkYXRhIGFycmF5IGFuZCBhcmUgZXhwZWN0ZWQgdG8gdHJhdmVyc2VcbiAgICogdGhhdCBkYXRhIGFycmF5IChvciBpdGVyYWJsZSkgYW5kIGZpbGwgaW4gdGhlIGF0dHJpYnV0ZSdzIHR5cGVkIGFycmF5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGF0dHJpYnV0ZSBtYW5hZ2VyIGludGVudGlvbmFsbHkgZG9lcyBub3QgZG8gYWR2YW5jZWRcbiAgICogY2hhbmdlIGRldGVjdGlvbiwgYnV0IGluc3RlYWQgbWFrZXMgaXQgZWFzeSB0byBidWlsZCBzdWNoIGRldGVjdGlvblxuICAgKiBieSBvZmZlcmluZyB0aGUgYWJpbGl0eSB0byBcImludmFsaWRhdGVcIiBlYWNoIGF0dHJpYnV0ZSBzZXBhcmF0ZWx5LlxuICAgKlxuICAgKiBTdW1tYXJ5OlxuICAgKiAtIGtlZXBzIHRyYWNrIG9mIHZhbGlkIHN0YXRlIGZvciBlYWNoIGF0dHJpYnV0ZVxuICAgKiAtIGF1dG8gcmVhbGxvY2F0ZXMgYXR0cmlidXRlcyB3aGVuIG5lZWRlZFxuICAgKiAtIGF1dG8gdXBkYXRlcyBhdHRyaWJ1dGVzIHdpdGggcmVnaXN0ZXJlZCB1cGRhdGVyIGZ1bmN0aW9uc1xuICAgKiAtIGFsbG93cyBvdmVycmlkaW5nIHdpdGggYXBwbGljYXRpb24gc3VwcGxpZWQgYnVmZmVyc1xuICAgKlxuICAgKiBMaW1pdGF0aW9uczpcbiAgICogLSBUaGVyZSBhcmUgY3VycmVudGx5IG5vIHByb3Zpc2lvbnMgZm9yIG9ubHkgaW52YWxpZGF0aW5nIGEgcmFuZ2Ugb2ZcbiAgICogICBpbmRpY2VzIGluIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcHMuaWRdIC0gaWRlbnRpZmllciAoZm9yIGRlYnVnZ2luZylcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpZCA9ICdhdHRyaWJ1dGUtbWFuYWdlcicsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0ge30pIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5hbGxvY2VkSW5zdGFuY2VzID0gLTE7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuXG4gICAgdGhpcy5vblVwZGF0ZVN0YXJ0ID0gbm9vcDtcbiAgICB0aGlzLm9uVXBkYXRlRW5kID0gbm9vcDtcbiAgICB0aGlzLm9uTG9nID0gdGhpcy5fZGVmYXVsdExvZztcblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgc2FuaXR5LCBwcmV2ZW50IHVuaW5pdGlhbGl6ZWQgbWVtYmVyc1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhIG1hcCBvZiBhdHRyaWJ1dGUgZGVzY3JpcHRvciBvYmplY3RzXG4gICAqIC0ga2V5cyBhcmUgYXR0cmlidXRlIG5hbWVzXG4gICAqIC0gdmFsdWVzIGFyZSBvYmplY3RzIHdpdGggYXR0cmlidXRlIGZpZWxkc1xuICAgKlxuICAgKiBhdHRyaWJ1dGUuc2l6ZSAtIG51bWJlciBvZiBlbGVtZW50cyBwZXIgb2JqZWN0XG4gICAqIGF0dHJpYnV0ZS51cGRhdGVyIC0gbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAqIGF0dHJpYnV0ZS5pbnN0YW5jZWQ9MCAtIGlzIHRoaXMgaXMgYW4gaW5zdGFuY2VkIGF0dHJpYnV0ZSAoYS5rLmEuIGRpdmlzb3IpXG4gICAqIGF0dHJpYnV0ZS5ub0FsbG9jPWZhbHNlIC0gaWYgdGhpcyBhdHRyaWJ1dGUgc2hvdWxkIG5vdCBiZSBhbGxvY2F0ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgKiAgIHBvc2l0aW9uczoge3NpemU6IDIsIHVwZGF0ZTogY2FsY3VsYXRlUG9zaXRpb25zfVxuICAgKiAgIGNvbG9yczoge3NpemU6IDMsIHVwZGF0ZTogY2FsY3VsYXRlQ29sb3JzfVxuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMpO1xuICB9XG5cbiAgLy8gTWFya3MgYW4gYXR0cmlidXRlIGZvciB1cGRhdGVcbiAgaW52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgIGFzc2VydChhdHRyaWJ1dGUpO1xuICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlIHR1bmluZ1xuICAgIHRoaXMub25Mb2coMSwgYGludmFsaWRhdGVkIGF0dHJpYnV0ZSAke2F0dHJpYnV0ZU5hbWV9IGZvciAke3RoaXMuaWR9YCk7XG4gIH1cblxuICBpbnZhbGlkYXRlQWxsKCkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGFsbCBhdHRyaWJ1dGUgYnVmZmVycyBhcmUgdXBkYXRlZCBmcm9tIHByb3BzIG9yIGRhdGEuXG4gICAqXG4gICAqIE5vdGU6IEFueSBwcmVhbGxvY2F0ZWQgYnVmZmVycyBpbiBcImJ1ZmZlcnNcIiBtYXRjaGluZyByZWdpc3RlcmVkIGF0dHJpYnV0ZVxuICAgKiBuYW1lcyB3aWxsIGJlIHVzZWQuIE5vIHVwZGF0ZSB3aWxsIGhhcHBlbiBpbiB0aGlzIGNhc2UuXG4gICAqIE5vdGU6IENhbGxzIG9uVXBkYXRlU3RhcnQgYW5kIG9uVXBkYXRlRW5kIGxvZyBjYWxsYmFja3MgYmVmb3JlIGFuZCBhZnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgLSBkYXRhIChpdGVyYWJsZSBvYmplY3QpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3BzIC0gcGFzc2VkIHRvIHVwZGF0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAqL1xuICB1cGRhdGUoe1xuICAgIGRhdGEsXG4gICAgbnVtSW5zdGFuY2VzLFxuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBwcm9wcyA9IHt9LFxuICAgIGNvbnRleHQgPSB7fSxcbiAgICAuLi5vcHRzXG4gIH0gPSB7fSkge1xuICAgIC8vIEZpcnN0IGFwcGx5IGFueSBhcHBsaWNhdGlvbiBwcm92aWRlZCBidWZmZXJzXG4gICAgdGhpcy5fY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVycywgb3B0cyk7XG4gICAgdGhpcy5fc2V0RXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlcnMpO1xuXG4gICAgLy8gT25seSBpbml0aWF0ZSBhbGxvYy91cGRhdGUgKGFuZCBsb2dnaW5nKSBpZiBhY3R1YWxseSBuZWVkZWRcbiAgICBpZiAodGhpcy5fYW5hbHl6ZUJ1ZmZlcnMoe251bUluc3RhbmNlc30pKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlU3RhcnQodGhpcy5pZCk7XG4gICAgICB0aGlzLl91cGRhdGVCdWZmZXJzKHtudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSk7XG4gICAgICB0aGlzLm9uVXBkYXRlRW5kKHRoaXMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGxvZyBmdW5jdGlvbnMgdG8gaGVscCB0cmFjZSBvciB0aW1lIGF0dHJpYnV0ZSB1cGRhdGVzLlxuICAgKiBEZWZhdWx0IGxvZ2dpbmcgdXNlcyBsdW1hIGxvZ2dlci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBhcHAgbWF5IG5vdCBiZSBpbiBjb250cm9sIG9mIHdoZW4gdXBkYXRlIGlzIGNhbGxlZCxcbiAgICogc28gaG9va3MgYXJlIHByb3ZpZGVkIGZvciB1cGRhdGUgc3RhcnQgYW5kIGVuZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25Mb2c9XSAtIGNhbGxlZCB0byBwcmludFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVTdGFydD1dIC0gY2FsbGVkIGJlZm9yZSB1cGRhdGUoKSBzdGFydHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uVXBkYXRlRW5kPV0gLSBjYWxsZWQgYWZ0ZXIgdXBkYXRlKCkgZW5kc1xuICAgKi9cbiAgc2V0TG9nRnVuY3Rpb25zKHtcbiAgICBvbkxvZyxcbiAgICBvblVwZGF0ZVN0YXJ0LFxuICAgIG9uVXBkYXRlRW5kXG4gIH0gPSB7fSkge1xuICAgIHRoaXMub25Mb2cgPSBvbkxvZyAhPT0gdW5kZWZpbmVkID8gb25Mb2cgOiB0aGlzLm9uTG9nO1xuICAgIHRoaXMub25VcGRhdGVTdGFydCA9XG4gICAgICBvblVwZGF0ZVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBvblVwZGF0ZVN0YXJ0IDogdGhpcy5vblVwZGF0ZVN0YXJ0O1xuICAgIHRoaXMub25VcGRhdGVFbmQgPVxuICAgICAgb25VcGRhdGVFbmQgIT09IHVuZGVmaW5lZCA/IG9uVXBkYXRlRW5kIDogdGhpcy5vblVwZGF0ZUVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICogTm90ZTogRm9ybWF0IG1hdGNoZXMgbHVtYS5nbCBNb2RlbC9Qcm9ncmFtLnNldEF0dHJpYnV0ZXMoKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBkZXNjcmlwdG9yc1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY2hhbmdlZCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICogVGhpcyBpbmRpY2F0ZXMgd2hpY2ggV2ViR0xCdWdnZXJzIG5lZWQgdG8gYmUgdXBkYXRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBkZXNjcmlwdG9yc1xuICAgKi9cbiAgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe2NsZWFyQ2hhbmdlZEZsYWdzID0gZmFsc2V9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5jaGFuZ2VkKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gYXR0cmlidXRlLmNoYW5nZWQgJiYgIWNsZWFyQ2hhbmdlZEZsYWdzO1xuICAgICAgICBjaGFuZ2VkQXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWRBdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlZHJhdyBmbGFnLCBvcHRpb25hbGx5IGNsZWFyaW5nIGl0LlxuICAgKiBSZWRyYXcgZmxhZyB3aWxsIGJlIHNldCBpZiBhbnkgYXR0cmlidXRlcyBhdHRyaWJ1dGVzIGNoYW5nZWQgc2luY2VcbiAgICogZmxhZyB3YXMgbGFzdCBjbGVhcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5jbGVhclJlZHJhd0ZsYWdzPWZhbHNlXSAtIHdoZXRoZXIgdG8gY2xlYXIgdGhlIGZsYWdcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSB3aGV0aGVyIGEgcmVkcmF3IGlzIG5lZWRlZC5cbiAgICovXG4gIGdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICBsZXQgcmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdztcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5uZWVkc1JlZHJhdztcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlZHJhdyBmbGFnLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdz10cnVlXG4gICAqIEByZXR1cm4ge0F0dHJpYnV0ZU1hbmFnZXJ9IC0gZm9yIGNoYWluaW5nXG4gICAqL1xuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUsIHVzZSBhZGQoKSBpbnN0ZWFkXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBtYXAgKHNlZSBhYm92ZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAqL1xuICBhZGREeW5hbWljKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LCB1c2UgYWRkKCkgaW5zdGVhZFxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkSW5zdGFuY2VkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMsIHtpbnN0YW5jZWQ6IDF9KTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIERlZmF1bHQgbG9nZ2VyXG4gIF9kZWZhdWx0TG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgbG9nLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICAvLyBVc2VkIHRvIHJlZ2lzdGVyIGFuIGF0dHJpYnV0ZVxuICBfYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30sIF9leHRyYVByb3BzID0ge30pIHtcblxuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAvLyBzdXBwb3J0IGZvciBzZXBhcmF0ZSB1cGRhdGUgZnVuY3Rpb24gbWFwXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IGNvcHkgYW55IGF0dHJpYnV0ZXMgZnJvbSB0aGF0IG1hcCBpbnRvIHRoZSBtYWluIG1hcFxuICAgICAgLy8gVE9ETyAtIEF0dHJpYnV0ZSBtYXBzIGFyZSBhIGRlcHJlY2F0ZWQgZmVhdHVyZSwgcmVtb3ZlXG4gICAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiB1cGRhdGVycykge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0ge1xuICAgICAgICAgIC4uLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0sXG4gICAgICAgICAgLi4udXBkYXRlcnNbYXR0cmlidXRlTmFtZV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gQ2hlY2sgYWxsIGZpZWxkcyBhbmQgZ2VuZXJhdGUgaGVscGZ1bCBlcnJvciBtZXNzYWdlc1xuICAgICAgdGhpcy5fdmFsaWRhdGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgYXR0cmlidXRlIGRlc2NyaXB0b3IsIHdpdGggV2ViR0wgYW5kIG1ldGFkYXRhIGZpZWxkc1xuICAgICAgY29uc3QgYXR0cmlidXRlRGF0YSA9IHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgZmllbGRzIGFyZSBwcmVzZW50IGJlZm9yZSBPYmplY3Quc2VhbCgpXG4gICAgICAgIHRhcmdldDogdW5kZWZpbmVkLFxuICAgICAgICBpc0luZGV4ZWQ6IGZhbHNlLFxuXG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBhcHBsaWNhdGlvblxuICAgICAgICB1c2VyRGF0YToge30sXG5cbiAgICAgICAgLy8gTWV0YWRhdGFcbiAgICAgICAgLi4uYXR0cmlidXRlLFxuXG4gICAgICAgIC8vIFN0YXRlXG4gICAgICAgIGlzRXh0ZXJuYWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICBuZWVkc0FsbG9jOiBmYWxzZSxcbiAgICAgICAgbmVlZHNVcGRhdGU6IGZhbHNlLFxuICAgICAgICBjaGFuZ2VkOiBmYWxzZSxcblxuICAgICAgICAvLyBMdW1hIGZpZWxkc1xuICAgICAgICBzaXplOiBhdHRyaWJ1dGUuc2l6ZSxcbiAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZS52YWx1ZSB8fCBudWxsLFxuXG4gICAgICAgIC4uLl9leHRyYVByb3BzXG4gICAgICB9O1xuICAgICAgLy8gU2FuaXR5IC0gbm8gYXBwIGZpZWxkcyBvbiBvdXIgYXR0cmlidXRlcy4gVXNlIHVzZXJEYXRhIGluc3RlYWQuXG4gICAgICBPYmplY3Quc2VhbChhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQWRkIHRvIGJvdGggYXR0cmlidXRlcyBsaXN0IChmb3IgcmVnaXN0cmF0aW9uIHdpdGggbW9kZWwpXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVEYXRhO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIF92YWxpZGF0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICBhc3NlcnQodHlwZW9mIGF0dHJpYnV0ZS5zaXplID09PSAnbnVtYmVyJyxcbiAgICAgIGBBdHRyaWJ1dGUgZGVmaW5pdGlvbiBmb3IgJHthdHRyaWJ1dGVOYW1lfSBtaXNzaW5nIHNpemVgKTtcblxuICAgIC8vIENoZWNrIHRoZSB1cGRhdGVyXG4gICAgYXNzZXJ0KHR5cGVvZiBhdHRyaWJ1dGUudXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IGF0dHJpYnV0ZS5ub0FsbG9jLFxuICAgICAgYEF0dHJpYnV0ZSB1cGRhdGVyIGZvciAke2F0dHJpYnV0ZU5hbWV9IG1pc3NpbmcgdXBkYXRlIG1ldGhvZGApO1xuICB9XG5cbiAgLy8gQ2hlY2tzIHRoYXQgYW55IGF0dHJpYnV0ZSBidWZmZXJzIGluIHByb3BzIGFyZSB2YWxpZFxuICAvLyBOb3RlOiBUaGlzIGlzIGp1c3QgdG8gaGVscCBhcHAgY2F0Y2ggbWlzdGFrZXNcbiAgX2NoZWNrRXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlck1hcCA9IHt9LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBidWZmZXJNYXApIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoIWF0dHJpYnV0ZSAmJiAhb3B0cy5pZ25vcmVVbmtub3duQXR0cmlidXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIHByb3AgJHthdHRyaWJ1dGVOYW1lfWApO1xuICAgICAgfVxuICAgICAgLy8gY29uc3QgYnVmZmVyID0gYnVmZmVyTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgLy8gVE9ETyAtIGNoZWNrIGJ1ZmZlciB0eXBlXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoZSBidWZmZXJzIGZvciB0aGUgc3VwcGxpZWQgYXR0cmlidXRlc1xuICAvLyBVcGRhdGUgYXR0cmlidXRlIGJ1ZmZlcnMgZnJvbSBhbnkgYXR0cmlidXRlcyBpbiBwcm9wc1xuICAvLyBEZXRhY2ggYW55IHByZXZpb3VzbHkgc2V0IGJ1ZmZlcnMsIG1hcmtpbmcgYWxsXG4gIC8vIEF0dHJpYnV0ZXMgZm9yIGF1dG8gYWxsb2NhdGlvblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfc2V0RXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlck1hcCkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzLCBudW1JbnN0YW5jZXN9ID0gdGhpcztcblxuICAgIC8vIENvcHkgdGhlIHJlZnMgb2YgYW55IHN1cHBsaWVkIGJ1ZmZlcnMgaW4gdGhlIHByb3BzXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICBhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlciA9IGZhbHNlO1xuICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgcHJvcGVydGllcyBtdXN0IGJlIG9mIHR5cGUgRmxvYXQzMkFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5hdXRvICYmIGJ1ZmZlci5sZW5ndGggPD0gbnVtSW5zdGFuY2VzICogYXR0cmlidXRlLnNpemUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBwcm9wIGFycmF5IG11c3QgbWF0Y2ggbGVuZ3RoIGFuZCBzaXplJyk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlciA9IHRydWU7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLnZhbHVlICE9PSBidWZmZXIpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUgPSBidWZmZXI7XG4gICAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKiBDaGVja3MgdGhhdCB0eXBlZCBhcnJheXMgZm9yIGF0dHJpYnV0ZXMgYXJlIGJpZyBlbm91Z2hcbiAgICogc2V0cyBhbGxvYyBmbGFnIGlmIG5vdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIGFueSB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICovXG4gIF9hbmFseXplQnVmZmVycyh7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgYXNzZXJ0KG51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKTtcblxuICAgIC8vIFRyYWNrIHdoZXRoZXIgYW55IGFsbG9jYXRpb25zIG9yIHVwZGF0ZXMgYXJlIG5lZWRlZFxuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoIWF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyKSB7XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gcmVhbGxvY2F0ZSB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXk/XG4gICAgICAgIGNvbnN0IG5lZWRzQWxsb2MgPVxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSA8IG51bUluc3RhbmNlcztcbiAgICAgICAgaWYgKG5lZWRzQWxsb2MgJiYgYXR0cmlidXRlLnVwZGF0ZSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc0FsbG9jID0gdHJ1ZTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWVkc1VwZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBDYWxscyB1cGRhdGUgb24gYW55IGJ1ZmZlcnMgdGhhdCBuZWVkIHVwZGF0ZVxuICAgKiBUT0RPPyAtIElmIGFwcCBzdXBwbGllZCBhbGwgYXR0cmlidXRlcywgbm8gbmVlZCB0byBpdGVyYXRlIG92ZXIgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSAtIGRhdGEgKGl0ZXJhYmxlIG9iamVjdClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMubnVtSW5zdGFuY2VzIC0gY291bnQgb2YgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5idWZmZXJzID0ge30gLSBwcmUtYWxsb2NhdGVkIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcHMgLSBwYXNzZWQgdG8gdXBkYXRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udGV4dCAtIFVzZWQgYXMgXCJ0aGlzXCIgY29udGV4dCBmb3IgdXBkYXRlcnNcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF91cGRhdGVCdWZmZXJzKHtudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG5cbiAgICAvLyBBbGxvY2F0ZSBhdCBsZWFzdCBvbmUgZWxlbWVudCB0byBlbnN1cmUgYSB2YWxpZCBidWZmZXJcbiAgICBjb25zdCBhbGxvY0NvdW50ID0gTWF0aC5tYXgobnVtSW5zdGFuY2VzLCAxKTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAvLyBBbGxvY2F0ZSBhIG5ldyB0eXBlZCBhcnJheSBpZiBuZWVkZWRcbiAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNBbGxvYykge1xuICAgICAgICBjb25zdCBBcnJheVR5cGUgPSBnbEFycmF5RnJvbVR5cGUoYXR0cmlidXRlLnR5cGUgfHwgR0wuRkxPQVQpO1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgQXJyYXlUeXBlKGF0dHJpYnV0ZS5zaXplICogYWxsb2NDb3VudCk7XG4gICAgICAgIHRoaXMub25Mb2coMiwgYCR7dGhpcy5pZH06JHthdHRyaWJ1dGVOYW1lfSBhbGxvY2F0ZWQgJHthbGxvY0NvdW50fWApO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNBbGxvYyA9IGZhbHNlO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIHVwZGF0ZXIgZnVuY3Rpb24gaWYgbmVlZGVkXG4gICAgICBpZiAoYXR0cmlidXRlLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgIGNvbnN0IHt1cGRhdGV9ID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5vbkxvZygyLCBgJHt0aGlzLmlkfToke2F0dHJpYnV0ZU5hbWV9IHVwZGF0aW5nICR7bnVtSW5zdGFuY2VzfWApO1xuICAgICAgICAgIHVwZGF0ZS5jYWxsKGNvbnRleHQsIGF0dHJpYnV0ZSwge2RhdGEsIHByb3BzLCBudW1JbnN0YW5jZXN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uTG9nKDIsIGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgZnVuY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSBhbGxvY0NvdW50O1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cbn1cbiJdfQ==