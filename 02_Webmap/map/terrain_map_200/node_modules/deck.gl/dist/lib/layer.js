'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/* global window */


var _attributeManager = require('./attribute-manager');

var _attributeManager2 = _interopRequireDefault(_attributeManager);

var _luma = require('luma.gl');

var _utils = require('./utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * @param {string} props.id - layer name
 * @param {array}  props.data - array of data instances
 * @param {bool} props.opacity - opacity of the layer
 */
var DEFAULT_PROPS = {
  data: [],
  dataIterator: null,
  dataComparator: null,
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: 0.8,
  onHover: function onHover() {},
  onClick: function onClick() {},
  getValue: function getValue(x) {
    return x;
  },
  // Update triggers: a key change detection mechanism in deck.gl
  // See layer documentation
  updateTriggers: {}
};

var counter = 0;

var Layer = function () {
  /**
   * @classdesc
   * Base Layer class
   *
   * @class
   * @param {object} props - See docs above
   */
  function Layer(props) {
    _classCallCheck(this, Layer);

    props = _extends({}, DEFAULT_PROPS, props, {
      // Accept null as data - otherwise apps will need to add ugly checks
      data: props.data || [],
      id: props.id || this.constructor.layerName
    });

    this.id = props.id;
    this.count = counter++;
    this.props = props;
    this.oldProps = null;
    this.state = null;
    this.context = null;
    Object.seal(this);

    this.validateRequiredProp('id', function (x) {
      return typeof x === 'string';
    });
    this.validateRequiredProp('data');
    // TODO - allow app to supply dataIterator prop?
    if (props.data) {
      (0, _utils.addIterator)(props.data);
      if (!props.data[Symbol.iterator]) {
        _utils.log.once(0, 'data prop must have iterator');
      }
    }

    this._validateDeprecatedProps();
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.name;
      return className !== this.props.id ? '<' + className + ':\'' + this.props.id + '\'>' : '<' + className + '>';
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}
  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          oldContext = _ref.oldContext,
          context = _ref.context,
          changeFlags = _ref.changeFlags;

      return changeFlags.somethingChanged;
    }

    // Default implementation, all attributeManager will be updated

  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          oldContext = _ref2.oldContext,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;

      if (changeFlags.dataChanged && this.state.attributeManager) {
        this.state.attributeManager.invalidateAll();
      }
    }

    // Implement to generate sublayers

  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      return null;
    }

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var _ref3$uniforms = _ref3.uniforms,
          uniforms = _ref3$uniforms === undefined ? {} : _ref3$uniforms;

      if (this.state.model) {
        this.state.model.render(uniforms);
      }
    }

    // If state has a model, draw it with supplied uniforms
    /* eslint-disable max-statements */

  }, {
    key: 'pick',
    value: function pick(_ref4) {
      var info = _ref4.info,
          uniforms = _ref4.uniforms,
          pickEnableUniforms = _ref4.pickEnableUniforms,
          pickDisableUniforms = _ref4.pickDisableUniforms,
          mode = _ref4.mode;
      var gl = this.context.gl;
      var model = this.state.model;


      if (model) {
        model.setUniforms(pickEnableUniforms);
        model.render(uniforms);
        model.setUniforms(pickDisableUniforms);

        // Read color in the central pixel, to be mapped with picking colors

        var _info$devicePixel = _slicedToArray(info.devicePixel, 2),
            x = _info$devicePixel[0],
            y = _info$devicePixel[1];

        var color = new Uint8Array(4);
        gl.readPixels(x, y, 1, 1, _luma.GL.RGBA, _luma.GL.UNSIGNED_BYTE, color);

        // Index < 0 means nothing selected
        info.index = this.decodePickingColor(color);
        info.color = color;

        // TODO - selectedPickingColor should be removed?
        if (mode === 'hover') {
          var selectedPickingColor = new Float32Array(3);
          selectedPickingColor[0] = color[0];
          selectedPickingColor[1] = color[1];
          selectedPickingColor[2] = color[2];
          this.setUniforms({ selectedPickingColor: selectedPickingColor });
        }
      }
    }
    /* eslint-enable max-statements */

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      return [(i + 1) % 256, Math.floor((i + 1) / 256) % 256, Math.floor((i + 1) / 256 / 256) % 256];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      (0, _assert2.default)(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref5) {
      var numInstances = _ref5.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      var _props = props,
          data = _props.data;

      // Check if ES6 collection "count" function is available

      if (data && typeof data.count === 'function') {
        return data.count();
      }

      // Check if ES6 collection "size" attribute is set
      if (data && data.size !== undefined) {
        return data.size;
      }

      // Check if array length attribute is set
      // Note: checking this last since some ES6 collections (Immutable.js)
      // emit profuse warnings when trying to access `length` attribute
      if (data && data.length !== undefined) {
        return data.length;
      }

      throw new Error('Could not deduce numInstances');
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: 'initializeLayer',
    value: function initializeLayer(updateParams) {
      (0, _assert2.default)(this.context.gl);
      (0, _assert2.default)(!this.state);

      this.state = {};

      // Initialize state only once
      this.setState({
        attributeManager: new _attributeManager2.default({ id: this.props.id }),
        model: null,
        needsRedraw: true,
        dataChanged: true
      });

      // Add attribute manager loggers if provided
      this.state.attributeManager.setLogFunctions(this.props);

      var attributeManager = this.state.attributeManager;
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slows down non instanced layers

      attributeManager.addInstanced({
        instancePickingColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      // Call subclass lifecycle methods
      this.initializeState();
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this._updateAttributes(this.props);
      this._updateBaseUniforms();

      var model = this.state.model;

      if (model) {
        model.setInstanceCount(this.getNumInstances());
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }
    }

    // Called by layer manager when existing layer is getting new props

  }, {
    key: 'updateLayer',
    value: function updateLayer(updateParams) {
      // Check for deprecated method
      if (this.shouldUpdate) {
        _utils.log.once(0, 'deck.gl v3 shouldUpdate deprecated. Use shouldUpdateState in ' + this);
      }

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.shouldUpdateState(updateParams);
      // End lifecycle method

      if (stateNeedsUpdate) {

        // Call deprecated lifecycle method if defined
        var hasRedefinedMethod = this.willReceiveProps && this.willReceiveProps !== Layer.prototype.willReceiveProps;
        if (hasRedefinedMethod) {
          _utils.log.once(0, 'deck.gl v3 willReceiveProps deprecated. Use updateState in ' + this);
          var oldProps = updateParams.oldProps,
              props = updateParams.props,
              changeFlags = updateParams.changeFlags;

          this.setState(changeFlags);
          this.willReceiveProps(oldProps, props, changeFlags);
          this.setState({
            dataChanged: false,
            viewportChanged: false
          });
        }
        // End lifecycle method

        // Call subclass lifecycle method
        this.updateState(updateParams);
        // End lifecycle method

        // Run the attribute updaters
        this._updateAttributes(updateParams.newProps);
        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    }
    /* eslint-enable max-statements */

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: 'finalizeLayer',
    value: function finalizeLayer() {
      // Call subclass lifecycle method
      this.finalizeState();
      // End lifecycle method
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref6) {
      var _ref6$uniforms = _ref6.uniforms,
          uniforms = _ref6$uniforms === undefined ? {} : _ref6$uniforms,
          _ref6$layerIndex = _ref6.layerIndex,
          layerIndex = _ref6$layerIndex === undefined ? 0 : _ref6$layerIndex;

      (0, _assert2.default)(this.context.viewport, 'Layer missing context.viewport');
      var viewportUniforms = this.context.viewport.getUniforms(this.props);
      uniforms = _extends({}, uniforms, viewportUniforms, { layerIndex: layerIndex });
      // Call subclass lifecycle method
      this.draw({ uniforms: uniforms });
      // End lifecycle method
    }
  }, {
    key: 'pickLayer',
    value: function pickLayer(_ref7) {
      var _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms,
          opts = _objectWithoutProperties(_ref7, ['uniforms']);

      var viewportUniforms = this.context.viewport.getUniforms(this.props);
      uniforms = _extends({}, uniforms, viewportUniforms, { renderPickingBuffer: true });
      // Call subclass lifecycle method
      return this.pick(_extends({ uniforms: uniforms }, opts));
      // End lifecycle method
    }
  }, {
    key: 'diffProps',
    value: function diffProps(oldProps, newProps, context) {
      // If any props have changed, ignoring updateTriggers objects
      // (updateTriggers are expected to be a new object on every update)
      var propsChangedReason = (0, _utils.compareProps)({
        newProps: newProps,
        oldProps: oldProps,
        ignoreProps: { data: null, updateTriggers: null }
      });

      var dataChangedReason = this._diffDataProps(oldProps, newProps);

      var propsChanged = Boolean(propsChangedReason);
      var dataChanged = Boolean(dataChangedReason);
      var viewportChanged = context.viewportChanged;
      var somethingChanged = propsChanged || dataChanged || viewportChanged;

      // If data hasn't changed, check update triggers
      if (!dataChanged) {
        this._diffUpdateTriggers(oldProps, newProps);
      } else {
        _utils.log.log(1, 'dataChanged: ' + dataChanged);
      }

      return {
        propsChanged: propsChanged,
        dataChanged: dataChanged,
        viewportChanged: viewportChanged,
        somethingChanged: somethingChanged,
        reason: dataChangedReason || propsChangedReason
      };
    }

    // Checks state of attributes and model
    // TODO - is attribute manager needed? - Model should be enough.

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      var _state = this.state,
          attributeManager = _state.attributeManager,
          model = _state.model;

      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });

      return redraw;
    }

    // PRIVATE METHODS

    // The comparison of the data prop requires special handling
    // the dataComparator should be used if supplied

  }, {
    key: '_diffDataProps',
    value: function _diffDataProps(oldProps, newProps) {
      // Support optional app defined comparison of data
      var dataComparator = newProps.dataComparator;

      if (dataComparator) {
        if (!dataComparator(newProps.data, oldProps.data)) {
          return 'Data comparator detected a change';
        }
        // Otherwise, do a shallow equal on props
      } else if (newProps.data !== oldProps.data) {
        return 'A new data container was supplied';
      }

      return null;
    }

    // Checks if any update triggers have changed, and invalidate
    // attributes accordingly.
    /* eslint-disable max-statements */

  }, {
    key: '_diffUpdateTriggers',
    value: function _diffUpdateTriggers(oldProps, newProps) {
      var attributeManager = this.state.attributeManager;

      if (!attributeManager) {
        return false;
      }

      var change = false;

      for (var propName in newProps.updateTriggers) {
        var oldTriggers = oldProps.updateTriggers[propName];
        var newTriggers = newProps.updateTriggers[propName];
        var diffReason = (0, _utils.compareProps)({
          oldProps: oldTriggers,
          newProps: newTriggers
        });
        if (diffReason) {
          if (propName === 'all') {
            _utils.log.log(1, 'updateTriggers invalidating all attributes: ' + diffReason);
            attributeManager.invalidateAll();
            change = true;
          } else {
            _utils.log.log(1, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);
            attributeManager.invalidate(propName);
            change = true;
          }
        }
      }

      return change;
    }
    /* eslint-enable max-statements */

  }, {
    key: 'validateRequiredProp',
    value: function validateRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }

    // Calls attribute manager to update any WebGL attributes

  }, {
    key: '_updateAttributes',
    value: function _updateAttributes(props) {
      var _state2 = this.state,
          attributeManager = _state2.attributeManager,
          model = _state2.model;

      if (!attributeManager) {
        return;
      }

      var numInstances = this.getNumInstances(props);
      // Figure out data length
      attributeManager.update({
        numInstances: numInstances,
        bufferMap: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });
      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      this.setUniforms({
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      });
    }

    // DEPRECATED METHODS
    // shouldUpdate() {}

  }, {
    key: 'willReceiveProps',
    value: function willReceiveProps() {}

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      if (this.state.model) {
        this.state.model.setUniforms(uniformMap);
      }
      // TODO - set needsRedraw on the model?
      this.state.needsRedraw = true;
      (0, _utils.log)(3, 'layer.setUniforms', uniformMap);
    }
  }, {
    key: '_validateDeprecatedProps',
    value: function _validateDeprecatedProps() {
      if (this.props.isPickable !== undefined) {
        _utils.log.once(0, 'No isPickable prop in deckgl v3 - use pickable instead');
      }

      // TODO - inject viewport from overlay instead of creating for each layer?
      var hasViewportProps =
      // this.props.width !== undefined ||
      // this.props.height !== undefined ||
      this.props.latitude !== undefined || this.props.longitude !== undefined || this.props.zoom !== undefined || this.props.pitch !== undefined || this.props.bearing !== undefined;
      if (hasViewportProps) {
        /* eslint-disable no-console */
        // /* global console */
        _utils.log.once(0, 'deck.gl v3 no longer needs viewport props in Layer ' + this);
      }
    }
  }]);

  return Layer;
}();

exports.default = Layer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXIuanMiXSwibmFtZXMiOlsiREVGQVVMVF9QUk9QUyIsImRhdGEiLCJkYXRhSXRlcmF0b3IiLCJkYXRhQ29tcGFyYXRvciIsIm51bUluc3RhbmNlcyIsInVuZGVmaW5lZCIsInZpc2libGUiLCJwaWNrYWJsZSIsIm9wYWNpdHkiLCJvbkhvdmVyIiwib25DbGljayIsImdldFZhbHVlIiwieCIsInVwZGF0ZVRyaWdnZXJzIiwiY291bnRlciIsIkxheWVyIiwicHJvcHMiLCJpZCIsImNvbnN0cnVjdG9yIiwibGF5ZXJOYW1lIiwiY291bnQiLCJvbGRQcm9wcyIsInN0YXRlIiwiY29udGV4dCIsIk9iamVjdCIsInNlYWwiLCJ2YWxpZGF0ZVJlcXVpcmVkUHJvcCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib25jZSIsIl92YWxpZGF0ZURlcHJlY2F0ZWRQcm9wcyIsImNsYXNzTmFtZSIsIm5hbWUiLCJFcnJvciIsIm9sZENvbnRleHQiLCJjaGFuZ2VGbGFncyIsInNvbWV0aGluZ0NoYW5nZWQiLCJkYXRhQ2hhbmdlZCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJpbnZhbGlkYXRlQWxsIiwidW5pZm9ybXMiLCJtb2RlbCIsInJlbmRlciIsImluZm8iLCJwaWNrRW5hYmxlVW5pZm9ybXMiLCJwaWNrRGlzYWJsZVVuaWZvcm1zIiwibW9kZSIsImdsIiwic2V0VW5pZm9ybXMiLCJkZXZpY2VQaXhlbCIsInkiLCJjb2xvciIsIlVpbnQ4QXJyYXkiLCJyZWFkUGl4ZWxzIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJpbmRleCIsImRlY29kZVBpY2tpbmdDb2xvciIsInNlbGVjdGVkUGlja2luZ0NvbG9yIiwiRmxvYXQzMkFycmF5IiwidXBkYXRlT2JqZWN0IiwiYXNzaWduIiwibmVlZHNSZWRyYXciLCJyZWRyYXciLCJsbmdMYXQiLCJ2aWV3cG9ydCIsIkFycmF5IiwiaXNBcnJheSIsInByb2plY3QiLCJ4eSIsInVucHJvamVjdCIsInByb2plY3RGbGF0IiwidW5wcm9qZWN0RmxhdCIsInNjcmVlblBpeGVscyIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJpIiwiTWF0aCIsImZsb29yIiwiaTEiLCJpMiIsImkzIiwiYXR0cmlidXRlIiwidmFsdWUiLCJzaXplIiwicGlja2luZ0NvbG9yIiwiZW5jb2RlUGlja2luZ0NvbG9yIiwib2JqZWN0IiwibGVuZ3RoIiwidXBkYXRlUGFyYW1zIiwic2V0U3RhdGUiLCJzZXRMb2dGdW5jdGlvbnMiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJ0eXBlIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5zdGFuY2VQaWNraW5nQ29sb3JzIiwiaW5pdGlhbGl6ZVN0YXRlIiwidXBkYXRlU3RhdGUiLCJfdXBkYXRlQXR0cmlidXRlcyIsIl91cGRhdGVCYXNlVW5pZm9ybXMiLCJzZXRJbnN0YW5jZUNvdW50IiwiZ2V0TnVtSW5zdGFuY2VzIiwicHJvZ3JhbSIsImdlb21ldHJ5Iiwic2V0QXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZXMiLCJzaG91bGRVcGRhdGUiLCJzdGF0ZU5lZWRzVXBkYXRlIiwic2hvdWxkVXBkYXRlU3RhdGUiLCJoYXNSZWRlZmluZWRNZXRob2QiLCJ3aWxsUmVjZWl2ZVByb3BzIiwicHJvdG90eXBlIiwidmlld3BvcnRDaGFuZ2VkIiwibmV3UHJvcHMiLCJmaW5hbGl6ZVN0YXRlIiwibGF5ZXJJbmRleCIsInZpZXdwb3J0VW5pZm9ybXMiLCJnZXRVbmlmb3JtcyIsImRyYXciLCJvcHRzIiwicmVuZGVyUGlja2luZ0J1ZmZlciIsInBpY2siLCJwcm9wc0NoYW5nZWRSZWFzb24iLCJpZ25vcmVQcm9wcyIsImRhdGFDaGFuZ2VkUmVhc29uIiwiX2RpZmZEYXRhUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJCb29sZWFuIiwiX2RpZmZVcGRhdGVUcmlnZ2VycyIsImxvZyIsInJlYXNvbiIsImNsZWFyUmVkcmF3RmxhZ3MiLCJnZXROZWVkc1JlZHJhdyIsImNoYW5nZSIsInByb3BOYW1lIiwib2xkVHJpZ2dlcnMiLCJuZXdUcmlnZ2VycyIsImRpZmZSZWFzb24iLCJpbnZhbGlkYXRlIiwicHJvcGVydHlOYW1lIiwiY29uZGl0aW9uIiwiYnVmZmVyTWFwIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImdldENoYW5nZWRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJwb3ciLCJPTkUiLCJ1bmlmb3JtTWFwIiwiaXNQaWNrYWJsZSIsImhhc1ZpZXdwb3J0UHJvcHMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0EsSUFBTUEsZ0JBQWdCO0FBQ3BCQyxRQUFNLEVBRGM7QUFFcEJDLGdCQUFjLElBRk07QUFHcEJDLGtCQUFnQixJQUhJO0FBSXBCQyxnQkFBY0MsU0FKTTtBQUtwQkMsV0FBUyxJQUxXO0FBTXBCQyxZQUFVLEtBTlU7QUFPcEJDLFdBQVMsR0FQVztBQVFwQkMsV0FBUyxtQkFBTSxDQUFFLENBUkc7QUFTcEJDLFdBQVMsbUJBQU0sQ0FBRSxDQVRHO0FBVXBCQyxZQUFVO0FBQUEsV0FBS0MsQ0FBTDtBQUFBLEdBVlU7QUFXcEI7QUFDQTtBQUNBQyxrQkFBZ0I7QUFiSSxDQUF0Qjs7QUFnQkEsSUFBSUMsVUFBVSxDQUFkOztJQUVxQkMsSztBQUNuQjs7Ozs7OztBQU9BLGlCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQ2pCQSx5QkFDS2hCLGFBREwsRUFFS2dCLEtBRkw7QUFHRTtBQUNBZixZQUFNZSxNQUFNZixJQUFOLElBQWMsRUFKdEI7QUFLRWdCLFVBQUlELE1BQU1DLEVB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QUtoRyxXQUFMLENBQWlCO0FBQ2Y7QUFDQXhDLGlCQUFTcUUsS0FBS3NFLEdBQUwsQ0FBUyxLQUFLbkksS0FBTCxDQUFXUixPQUFwQixFQUE2QixJQUFJLEdBQWpDLENBRk07QUFHZjRJLGFBQUs7QUFIVSxPQUFqQjtBQUtEOztBQUVEO0FBQ0E7Ozs7dUNBRW1CLENBQ2xCOztBQUVEOzs7O2dDQUNZQyxVLEVBQVk7QUFDdEIsVUFBSSxLQUFLL0gsS0FBTCxDQUFXbUIsS0FBZixFQUFzQjtBQUNwQixhQUFLbkIsS0FBTCxDQUFXbUIsS0FBWCxDQUFpQk8sV0FBakIsQ0FBNkJxRyxVQUE3QjtBQUNEO0FBQ0Q7QUFDQSxXQUFLL0gsS0FBTCxDQUFXd0MsV0FBWCxHQUF5QixJQUF6QjtBQUNBLHNCQUFJLENBQUosRUFBTyxtQkFBUCxFQUE0QnVGLFVBQTVCO0FBQ0Q7OzsrQ0FFMEI7QUFDekIsVUFBSSxLQUFLckksS0FBTCxDQUFXc0ksVUFBWCxLQUEwQmpKLFNBQTlCLEVBQXlDO0FBQ3ZDLG1CQUFJd0IsSUFBSixDQUFTLENBQVQsRUFBWSx3REFBWjtBQUNEOztBQUVEO0FBQ0EsVUFBTTBIO0FBQ0o7QUFDQTtBQUNBLFdBQUt2SSxLQUFMLENBQVd3SSxRQUFYLEtBQXdCbkosU0FBeEIsSUFDQSxLQUFLVyxLQUFMLENBQVd5SSxTQUFYLEtBQXlCcEosU0FEekIsSUFFQSxLQUFLVyxLQUFMLENBQVcwSSxJQUFYLEtBQW9CckosU0FGcEIsSUFHQSxLQUFLVyxLQUFMLENBQVcySSxLQUFYLEtBQXFCdEosU0FIckIsSUFJQSxLQUFLVyxLQUFMLENBQVc0SSxPQUFYLEtBQXVCdkosU0FQekI7QUFRQSxVQUFJa0osZ0JBQUosRUFBc0I7QUFDcEI7QUFDQTtBQUNBLG1CQUFJMUgsSUFBSixDQUFTLENBQVQsMERBQ3dELElBRHhEO0FBRUQ7QUFDRjs7Ozs7O2tCQXhrQmtCZCxLIiwiZmlsZSI6ImxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBBdHRyaWJ1dGVNYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlLW1hbmFnZXInO1xuaW1wb3J0IHtHTH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2FkZEl0ZXJhdG9yLCBjb21wYXJlUHJvcHMsIGxvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8qXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuaWQgLSBsYXllciBuYW1lXG4gKiBAcGFyYW0ge2FycmF5fSAgcHJvcHMuZGF0YSAtIGFycmF5IG9mIGRhdGEgaW5zdGFuY2VzXG4gKiBAcGFyYW0ge2Jvb2x9IHByb3BzLm9wYWNpdHkgLSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICovXG5jb25zdCBERUZBVUxUX1BST1BTID0ge1xuICBkYXRhOiBbXSxcbiAgZGF0YUl0ZXJhdG9yOiBudWxsLFxuICBkYXRhQ29tcGFyYXRvcjogbnVsbCxcbiAgbnVtSW5zdGFuY2VzOiB1bmRlZmluZWQsXG4gIHZpc2libGU6IHRydWUsXG4gIHBpY2thYmxlOiBmYWxzZSxcbiAgb3BhY2l0eTogMC44LFxuICBvbkhvdmVyOiAoKSA9PiB7fSxcbiAgb25DbGljazogKCkgPT4ge30sXG4gIGdldFZhbHVlOiB4ID0+IHgsXG4gIC8vIFVwZGF0ZSB0cmlnZ2VyczogYSBrZXkgY2hhbmdlIGRldGVjdGlvbiBtZWNoYW5pc20gaW4gZGVjay5nbFxuICAvLyBTZWUgbGF5ZXIgZG9jdW1lbnRhdGlvblxuICB1cGRhdGVUcmlnZ2Vyczoge31cbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBCYXNlIExheWVyIGNsYXNzXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBTZWUgZG9jcyBhYm92ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBwcm9wcyA9IHtcbiAgICAgIC4uLkRFRkFVTFRfUFJPUFMsXG4gICAgICAuLi5wcm9wcyxcbiAgICAgIC8vIEFjY2VwdCBudWxsIGFzIGRhdGEgLSBvdGhlcndpc2UgYXBwcyB3aWxsIG5lZWQgdG8gYWRkIHVnbHkgY2hlY2tzXG4gICAgICBkYXRhOiBwcm9wcy5kYXRhIHx8IFtdLFxuICAgICAgaWQ6IHByb3BzLmlkIHx8IHRoaXMuY29uc3RydWN0b3IubGF5ZXJOYW1lXG4gICAgfTtcblxuICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICB0aGlzLmNvdW50ID0gY291bnRlcisrO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLm9sZFByb3BzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuXG4gICAgdGhpcy52YWxpZGF0ZVJlcXVpcmVkUHJvcCgnaWQnLCB4ID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJyk7XG4gICAgdGhpcy52YWxpZGF0ZVJlcXVpcmVkUHJvcCgnZGF0YScpO1xuICAgIC8vIFRPRE8gLSBhbGxvdyBhcHAgdG8gc3VwcGx5IGRhdGFJdGVyYXRvciBwcm9wP1xuICAgIGlmIChwcm9wcy5kYXRhKSB7XG4gICAgICBhZGRJdGVyYXRvcihwcm9wcy5kYXRhKTtcbiAgICAgIGlmICghcHJvcHMuZGF0YVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsICdkYXRhIHByb3AgbXVzdCBoYXZlIGl0ZXJhdG9yJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsaWRhdGVEZXByZWNhdGVkUHJvcHMoKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gKGNsYXNzTmFtZSAhPT0gdGhpcy5wcm9wcy5pZCkgP1xuICAgICAgYDwke2NsYXNzTmFtZX06JyR7dGhpcy5wcm9wcy5pZH0nPmAgOiBgPCR7Y2xhc3NOYW1lfT5gO1xuICB9XG5cbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTElGRUNZQ0xFIE1FVEhPRFMsIG92ZXJyaWRkZW4gYnkgdGhlIGxheWVyIHN1YmNsYXNzZXNcblxuICAvLyBDYWxsZWQgb25jZSB0byBzZXQgdXAgdGhlIGluaXRpYWwgc3RhdGVcbiAgLy8gQXBwIGNhbiBjcmVhdGUgV2ViR0wgcmVzb3VyY2VzXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyICR7dGhpc30gaGFzIG5vdCBkZWZpbmVkIGluaXRpYWxpemVTdGF0ZWApO1xuICB9XG5cbiAgLy8gQ2FsbGVkIG9uY2Ugd2hlbiBsYXllciBpcyBubyBsb25nZXIgbWF0Y2hlZCBhbmQgc3RhdGUgd2lsbCBiZSBkaXNjYXJkZWRcbiAgLy8gQXBwIGNhbiBkZXN0cm95IFdlYkdMIHJlc291cmNlc1xuICBmaW5hbGl6ZVN0YXRlKCkge1xuICB9XG5cbiAgc2hvdWxkVXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgcmV0dXJuIGNoYW5nZUZsYWdzLnNvbWV0aGluZ0NoYW5nZWQ7XG4gIH1cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLCBhbGwgYXR0cmlidXRlTWFuYWdlciB3aWxsIGJlIHVwZGF0ZWRcbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkICYmIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbXBsZW1lbnQgdG8gZ2VuZXJhdGUgc3VibGF5ZXJzXG4gIHJlbmRlckxheWVycygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHN0YXRlIGhhcyBhIG1vZGVsLCBkcmF3IGl0IHdpdGggc3VwcGxpZWQgdW5pZm9ybXNcbiAgZHJhdyh7dW5pZm9ybXMgPSB7fX0pIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHN0YXRlIGhhcyBhIG1vZGVsLCBkcmF3IGl0IHdpdGggc3VwcGxpZWQgdW5pZm9ybXNcbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgcGljayh7aW5mbywgdW5pZm9ybXMsIHBpY2tFbmFibGVVbmlmb3JtcywgcGlja0Rpc2FibGVVbmlmb3JtcywgbW9kZX0pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHttb2RlbH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5zZXRVbmlmb3JtcyhwaWNrRW5hYmxlVW5pZm9ybXMpO1xuICAgICAgbW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICAgIG1vZGVsLnNldFVuaWZvcm1zKHBpY2tEaXNhYmxlVW5pZm9ybXMpO1xuXG4gICAgICAvLyBSZWFkIGNvbG9yIGluIHRoZSBjZW50cmFsIHBpeGVsLCB0byBiZSBtYXBwZWQgd2l0aCBwaWNraW5nIGNvbG9yc1xuICAgICAgY29uc3QgW3gsIHldID0gaW5mby5kZXZpY2VQaXhlbDtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIDEsIDEsIEdMLlJHQkEsIEdMLlVOU0lHTkVEX0JZVEUsIGNvbG9yKTtcblxuICAgICAgLy8gSW5kZXggPCAwIG1lYW5zIG5vdGhpbmcgc2VsZWN0ZWRcbiAgICAgIGluZm8uaW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihjb2xvcik7XG4gICAgICBpbmZvLmNvbG9yID0gY29sb3I7XG5cbiAgICAgIC8vIFRPRE8gLSBzZWxlY3RlZFBpY2tpbmdDb2xvciBzaG91bGQgYmUgcmVtb3ZlZD9cbiAgICAgIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUGlja2luZ0NvbG9yID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMF0gPSBjb2xvclswXTtcbiAgICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMV0gPSBjb2xvclsxXTtcbiAgICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMl0gPSBjb2xvclsyXTtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7c2VsZWN0ZWRQaWNraW5nQ29sb3J9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8vIEVORCBMSUZFQ1lDTEUgTUVUSE9EU1xuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8vIFB1YmxpYyBBUElcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRTdGF0ZSh1cGRhdGVPYmplY3QpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHVwZGF0ZU9iamVjdCk7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cblxuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSByZWRyYXc7XG4gICAgfVxuICB9XG5cbiAgLy8gUFJPSkVDVElPTiBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGEgcG9pbnQgd2l0aCBjdXJyZW50IG1hcCBzdGF0ZSAobGF0LCBsb24sIHpvb20sIHBpdGNoLCBiZWFyaW5nKVxuICAgKlxuICAgKiBOb3RlOiBQb3NpdGlvbiBjb252ZXJzaW9uIGlzIGRvbmUgaW4gc2hhZGVyLCBzbyBpbiBtYW55IGNhc2VzIHRoZXJlIGlzIG5vIG5lZWRcbiAgICogZm9yIHRoaXMgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBsbmdMYXQgLSBsb25nIGFuZCBsYXQgdmFsdWVzXG4gICAqIEByZXR1cm4ge0FycmF5fFR5cGVkQXJyYXl9IC0geCwgeSBjb29yZGluYXRlc1xuICAgKi9cbiAgcHJvamVjdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3QoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICB9XG5cbiAgcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdEZsYXQobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3RGbGF0KHh5KTtcbiAgfVxuXG4gIHNjcmVlblRvRGV2aWNlUGl4ZWxzKHNjcmVlblBpeGVscykge1xuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgcmV0dXJuIHNjcmVlblBpeGVscyAqIGRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBhIGJsYWNrIGNvbG9yXG4gICAqL1xuICBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge2ludH0gaSAtIGluZGV4IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgY29sb3JcbiAgICovXG4gIGVuY29kZVBpY2tpbmdDb2xvcihpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIChpICsgMSkgJSAyNTYsXG4gICAgICBNYXRoLmZsb29yKChpICsgMSkgLyAyNTYpICUgMjU2LFxuICAgICAgTWF0aC5mbG9vcigoaSArIDEpIC8gMjU2IC8gMjU2KSAlIDI1NlxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbG9yIC0gY29sb3IgYXJyYXkgdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBwaWNraW5nIGNvbG9yXG4gICAqL1xuICBkZWNvZGVQaWNraW5nQ29sb3IoY29sb3IpIHtcbiAgICBhc3NlcnQoY29sb3IgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBjb25zdCBbaTEsIGkyLCBpM10gPSBjb2xvcjtcbiAgICAvLyAxIHdhcyBhZGRlZCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGNvbnN0IGluZGV4ID0gaTEgKyBpMiAqIDI1NiArIGkzICogNjU1MzYgLSAxO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUsIHtudW1JbnN0YW5jZXN9KSB7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICAvLyBhZGQgMSB0byBpbmRleCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5zdGFuY2VzOyBpKyspIHtcbiAgICAgIGNvbnN0IHBpY2tpbmdDb2xvciA9IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKGkpO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHBpY2tpbmdDb2xvclswXTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMV0gPSBwaWNraW5nQ29sb3JbMV07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gcGlja2luZ0NvbG9yWzJdO1xuICAgIH1cbiAgfVxuXG4gIC8vIERBVEEgQUNDRVNTIEFQSVxuICAvLyBEYXRhIGNhbiB1c2UgaXRlcmF0b3JzIGFuZCBtYXkgbm90IGJlIHJhbmRvbSBhY2Nlc3NcblxuICAvLyBVc2UgaXRlcmF0aW9uICh0aGUgb25seSByZXF1aXJlZCBjYXBhYmlsaXR5IG9uIGRhdGEpIHRvIGdldCBmaXJzdCBlbGVtZW50XG4gIGdldEZpcnN0T2JqZWN0KCkge1xuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMucHJvcHM7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gRGVkdWNlcyBudW1lciBvZiBpbnN0YW5jZXMuIEludGVudGlvbiBpcyB0byBzdXBwb3J0OlxuICAvLyAtIEV4cGxpY2l0IHNldHRpbmcgb2YgbnVtSW5zdGFuY2VzXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgc2l6ZSBtZW1iZXJcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgQ2xhc3NpYyBBcnJheXMgdmlhIHRoZSBidWlsdC1pbiBsZW5ndGggYXR0cmlidXRlXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gdmlhIGFycmF5c1xuICBnZXROdW1JbnN0YW5jZXMocHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgbGF5ZXIgaGFzIHNldCBpdHMgb3duIHZhbHVlXG4gICAgaWYgKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFwcCBoYXMgcHJvdmlkZWQgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBpZiAocHJvcHMubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgY29uc3Qge2RhdGF9ID0gcHJvcHM7XG5cbiAgICAvLyBDaGVjayBpZiBFUzYgY29sbGVjdGlvbiBcImNvdW50XCIgZnVuY3Rpb24gaXMgYXZhaWxhYmxlXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEuY291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBkYXRhLmNvdW50KCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgRVM2IGNvbGxlY3Rpb24gXCJzaXplXCIgYXR0cmlidXRlIGlzIHNldFxuICAgIGlmIChkYXRhICYmIGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFycmF5IGxlbmd0aCBhdHRyaWJ1dGUgaXMgc2V0XG4gICAgLy8gTm90ZTogY2hlY2tpbmcgdGhpcyBsYXN0IHNpbmNlIHNvbWUgRVM2IGNvbGxlY3Rpb25zIChJbW11dGFibGUuanMpXG4gICAgLy8gZW1pdCBwcm9mdXNlIHdhcm5pbmdzIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyBgbGVuZ3RoYCBhdHRyaWJ1dGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGVkdWNlIG51bUluc3RhbmNlcycpO1xuICB9XG5cbiAgLy8gTEFZRVIgTUFOQUdFUiBBUElcbiAgLy8gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IHRoZSBkZWNrLmdsIExheWVyTWFuYWdlciBjbGFzc1xuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHdoZW4gYSBuZXcgbGF5ZXIgaXMgZm91bmRcbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgaW5pdGlhbGl6ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQuZ2wpO1xuICAgIGFzc2VydCghdGhpcy5zdGF0ZSk7XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG5cbiAgICAvLyBJbml0aWFsaXplIHN0YXRlIG9ubHkgb25jZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYXR0cmlidXRlTWFuYWdlcjogbmV3IEF0dHJpYnV0ZU1hbmFnZXIoe2lkOiB0aGlzLnByb3BzLmlkfSksXG4gICAgICBtb2RlbDogbnVsbCxcbiAgICAgIG5lZWRzUmVkcmF3OiB0cnVlLFxuICAgICAgZGF0YUNoYW5nZWQ6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIEFkZCBhdHRyaWJ1dGUgbWFuYWdlciBsb2dnZXJzIGlmIHByb3ZpZGVkXG4gICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLnNldExvZ0Z1bmN0aW9ucyh0aGlzLnByb3BzKTtcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgLy8gQWxsIGluc3RhbmNlZCBsYXllcnMgZ2V0IGluc3RhbmNlUGlja2luZ0NvbG9ycyBhdHRyaWJ1dGUgYnkgZGVmYXVsdFxuICAgIC8vIFRoZWlyIHNoYWRlcnMgY2FuIHVzZSBpdCB0byByZW5kZXIgYSBwaWNraW5nIHNjZW5lXG4gICAgLy8gVE9ETyAtIHRoaXMgc2xvd3MgZG93biBub24gaW5zdGFuY2VkIGxheWVyc1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yczoge1xuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICBzaXplOiAzLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQaWNraW5nQ29sb3JzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG4gICAgdGhpcy5pbml0aWFsaXplU3RhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgLy8gRW5kIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG5cbiAgICAvLyBBZGQgYW55IHN1YmNsYXNzIGF0dHJpYnV0ZXNcbiAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuXG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgbW9kZWwuaWQgPSB0aGlzLnByb3BzLmlkO1xuICAgICAgbW9kZWwucHJvZ3JhbS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LXByb2dyYW1gO1xuICAgICAgbW9kZWwuZ2VvbWV0cnkuaWQgPSBgJHt0aGlzLnByb3BzLmlkfS1nZW9tZXRyeWA7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZU1hbmFnZXIuZ2V0QXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGV4aXN0aW5nIGxheWVyIGlzIGdldHRpbmcgbmV3IHByb3BzXG4gIHVwZGF0ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIC8vIENoZWNrIGZvciBkZXByZWNhdGVkIG1ldGhvZFxuICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgbG9nLm9uY2UoMCxcbiAgICAgICAgYGRlY2suZ2wgdjMgc2hvdWxkVXBkYXRlIGRlcHJlY2F0ZWQuIFVzZSBzaG91bGRVcGRhdGVTdGF0ZSBpbiAke3RoaXN9YCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgY29uc3Qgc3RhdGVOZWVkc1VwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgaWYgKHN0YXRlTmVlZHNVcGRhdGUpIHtcblxuICAgICAgLy8gQ2FsbCBkZXByZWNhdGVkIGxpZmVjeWNsZSBtZXRob2QgaWYgZGVmaW5lZFxuICAgICAgY29uc3QgaGFzUmVkZWZpbmVkTWV0aG9kID0gdGhpcy53aWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIHRoaXMud2lsbFJlY2VpdmVQcm9wcyAhPT0gTGF5ZXIucHJvdG90eXBlLndpbGxSZWNlaXZlUHJvcHM7XG4gICAgICBpZiAoaGFzUmVkZWZpbmVkTWV0aG9kKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgdjMgd2lsbFJlY2VpdmVQcm9wcyBkZXByZWNhdGVkLiBVc2UgdXBkYXRlU3RhdGUgaW4gJHt0aGlzfWApO1xuICAgICAgICBjb25zdCB7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30gPSB1cGRhdGVQYXJhbXM7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY2hhbmdlRmxhZ3MpO1xuICAgICAgICB0aGlzLndpbGxSZWNlaXZlUHJvcHMob2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFncyk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgICB2aWV3cG9ydENoYW5nZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgICAvLyBSdW4gdGhlIGF0dHJpYnV0ZSB1cGRhdGVyc1xuICAgICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcyh1cGRhdGVQYXJhbXMubmV3UHJvcHMpO1xuICAgICAgdGhpcy5fdXBkYXRlQmFzZVVuaWZvcm1zKCk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLmdldE51bUluc3RhbmNlcygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8vIENhbGxlZCBieSBtYW5hZ2VyIHdoZW4gbGF5ZXIgaXMgYWJvdXQgdG8gYmUgZGlzcG9zZWRcbiAgLy8gTm90ZTogbm90IGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIG9uIGFwcGxpY2F0aW9uIHNodXRkb3duXG4gIGZpbmFsaXplTGF5ZXIoKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgdGhpcy5maW5hbGl6ZVN0YXRlKCk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgdW5pZm9ybXNcbiAgZHJhd0xheWVyKHt1bmlmb3JtcyA9IHt9LCBsYXllckluZGV4ID0gMH0pIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXIgbWlzc2luZyBjb250ZXh0LnZpZXdwb3J0Jyk7XG4gICAgY29uc3Qgdmlld3BvcnRVbmlmb3JtcyA9IHRoaXMuY29udGV4dC52aWV3cG9ydC5nZXRVbmlmb3Jtcyh0aGlzLnByb3BzKTtcbiAgICB1bmlmb3JtcyA9IHsuLi51bmlmb3JtcywgLi4udmlld3BvcnRVbmlmb3JtcywgbGF5ZXJJbmRleH07XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgdGhpcy5kcmF3KHt1bmlmb3Jtc30pO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICBwaWNrTGF5ZXIoe3VuaWZvcm1zID0ge30sIC4uLm9wdHN9KSB7XG4gICAgY29uc3Qgdmlld3BvcnRVbmlmb3JtcyA9IHRoaXMuY29udGV4dC52aWV3cG9ydC5nZXRVbmlmb3Jtcyh0aGlzLnByb3BzKTtcbiAgICB1bmlmb3JtcyA9IHsuLi51bmlmb3JtcywgLi4udmlld3BvcnRVbmlmb3JtcywgcmVuZGVyUGlja2luZ0J1ZmZlcjogdHJ1ZX07XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmV0dXJuIHRoaXMucGljayh7dW5pZm9ybXMsIC4uLm9wdHN9KTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgZGlmZlByb3BzKG9sZFByb3BzLCBuZXdQcm9wcywgY29udGV4dCkge1xuICAgIC8vIElmIGFueSBwcm9wcyBoYXZlIGNoYW5nZWQsIGlnbm9yaW5nIHVwZGF0ZVRyaWdnZXJzIG9iamVjdHNcbiAgICAvLyAodXBkYXRlVHJpZ2dlcnMgYXJlIGV4cGVjdGVkIHRvIGJlIGEgbmV3IG9iamVjdCBvbiBldmVyeSB1cGRhdGUpXG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBpZ25vcmVQcm9wczoge2RhdGE6IG51bGwsIHVwZGF0ZVRyaWdnZXJzOiBudWxsfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZGF0YUNoYW5nZWRSZWFzb24gPSB0aGlzLl9kaWZmRGF0YVByb3BzKG9sZFByb3BzLCBuZXdQcm9wcyk7XG5cbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSBCb29sZWFuKHByb3BzQ2hhbmdlZFJlYXNvbik7XG4gICAgY29uc3QgZGF0YUNoYW5nZWQgPSBCb29sZWFuKGRhdGFDaGFuZ2VkUmVhc29uKTtcbiAgICBjb25zdCB2aWV3cG9ydENoYW5nZWQgPSBjb250ZXh0LnZpZXdwb3J0Q2hhbmdlZDtcbiAgICBjb25zdCBzb21ldGhpbmdDaGFuZ2VkID1cbiAgICAgIHByb3BzQ2hhbmdlZCB8fCBkYXRhQ2hhbmdlZCB8fCB2aWV3cG9ydENoYW5nZWQ7XG5cbiAgICAvLyBJZiBkYXRhIGhhc24ndCBjaGFuZ2VkLCBjaGVjayB1cGRhdGUgdHJpZ2dlcnNcbiAgICBpZiAoIWRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9kaWZmVXBkYXRlVHJpZ2dlcnMob2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmxvZygxLCBgZGF0YUNoYW5nZWQ6ICR7ZGF0YUNoYW5nZWR9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BzQ2hhbmdlZCxcbiAgICAgIGRhdGFDaGFuZ2VkLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkLFxuICAgICAgc29tZXRoaW5nQ2hhbmdlZCxcbiAgICAgIHJlYXNvbjogZGF0YUNoYW5nZWRSZWFzb24gfHwgcHJvcHNDaGFuZ2VkUmVhc29uXG4gICAgfTtcbiAgfVxuXG4gIC8vIENoZWNrcyBzdGF0ZSBvZiBhdHRyaWJ1dGVzIGFuZCBtb2RlbFxuICAvLyBUT0RPIC0gaXMgYXR0cmlidXRlIG1hbmFnZXIgbmVlZGVkPyAtIE1vZGVsIHNob3VsZCBiZSBlbm91Z2guXG4gIGdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICAvLyB0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJ5IHRoZSByZW5kZXIgbG9vcCBhcyBzb29uIGEgdGhlIGxheWVyXG4gICAgLy8gaGFzIGJlZW4gY3JlYXRlZCwgc28gZ3VhcmQgYWdhaW5zdCB1bmluaXRpYWxpemVkIHN0YXRlXG4gICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8XG4gICAgICAoYXR0cmlidXRlTWFuYWdlciAmJiBhdHRyaWJ1dGVNYW5hZ2VyLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSkpO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fFxuICAgICAgKG1vZGVsICYmIG1vZGVsLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSkpO1xuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIFRoZSBjb21wYXJpc29uIG9mIHRoZSBkYXRhIHByb3AgcmVxdWlyZXMgc3BlY2lhbCBoYW5kbGluZ1xuICAvLyB0aGUgZGF0YUNvbXBhcmF0b3Igc2hvdWxkIGJlIHVzZWQgaWYgc3VwcGxpZWRcbiAgX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgLy8gU3VwcG9ydCBvcHRpb25hbCBhcHAgZGVmaW5lZCBjb21wYXJpc29uIG9mIGRhdGFcbiAgICBjb25zdCB7ZGF0YUNvbXBhcmF0b3J9ID0gbmV3UHJvcHM7XG4gICAgaWYgKGRhdGFDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoIWRhdGFDb21wYXJhdG9yKG5ld1Byb3BzLmRhdGEsIG9sZFByb3BzLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnRGF0YSBjb21wYXJhdG9yIGRldGVjdGVkIGEgY2hhbmdlJztcbiAgICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGRvIGEgc2hhbGxvdyBlcXVhbCBvbiBwcm9wc1xuICAgIH0gZWxzZSBpZiAobmV3UHJvcHMuZGF0YSAhPT0gb2xkUHJvcHMuZGF0YSkge1xuICAgICAgcmV0dXJuICdBIG5ldyBkYXRhIGNvbnRhaW5lciB3YXMgc3VwcGxpZWQnO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGFueSB1cGRhdGUgdHJpZ2dlcnMgaGF2ZSBjaGFuZ2VkLCBhbmQgaW52YWxpZGF0ZVxuICAvLyBhdHRyaWJ1dGVzIGFjY29yZGluZ2x5LlxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGNoYW5nZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBuZXdQcm9wcy51cGRhdGVUcmlnZ2Vycykge1xuICAgICAgY29uc3Qgb2xkVHJpZ2dlcnMgPSBvbGRQcm9wcy51cGRhdGVUcmlnZ2Vyc1twcm9wTmFtZV07XG4gICAgICBjb25zdCBuZXdUcmlnZ2VycyA9IG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXTtcbiAgICAgIGNvbnN0IGRpZmZSZWFzb24gPSBjb21wYXJlUHJvcHMoe1xuICAgICAgICBvbGRQcm9wczogb2xkVHJpZ2dlcnMsXG4gICAgICAgIG5ld1Byb3BzOiBuZXdUcmlnZ2Vyc1xuICAgICAgfSk7XG4gICAgICBpZiAoZGlmZlJlYXNvbikge1xuICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG9nLmxvZygxLFxuICAgICAgICAgICAgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhbGwgYXR0cmlidXRlczogJHtkaWZmUmVhc29ufWApO1xuICAgICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nLmxvZygxLFxuICAgICAgICAgICAgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhdHRyaWJ1dGUgJHtwcm9wTmFtZX06ICR7ZGlmZlJlYXNvbn1gKTtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUocHJvcE5hbWUpO1xuICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICB2YWxpZGF0ZVJlcXVpcmVkUHJvcChwcm9wZXJ0eU5hbWUsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wc1twcm9wZXJ0eU5hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSB1bmRlZmluZWQgaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uICYmICFjb25kaXRpb24odmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxzIGF0dHJpYnV0ZSBtYW5hZ2VyIHRvIHVwZGF0ZSBhbnkgV2ViR0wgYXR0cmlidXRlc1xuICBfdXBkYXRlQXR0cmlidXRlcyhwcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IHRoaXMuZ2V0TnVtSW5zdGFuY2VzKHByb3BzKTtcbiAgICAvLyBGaWd1cmUgb3V0IGRhdGEgbGVuZ3RoXG4gICAgYXR0cmlidXRlTWFuYWdlci51cGRhdGUoe1xuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgYnVmZmVyTWFwOiBwcm9wcyxcbiAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAvLyBEb24ndCB3b3JyeSBhYm91dCBub24tYXR0cmlidXRlIHByb3BzXG4gICAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPVxuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFnczogdHJ1ZX0pO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUJhc2VVbmlmb3JtcygpIHtcbiAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICBvcGFjaXR5OiBNYXRoLnBvdyh0aGlzLnByb3BzLm9wYWNpdHksIDEgLyAyLjIpLFxuICAgICAgT05FOiAxLjBcbiAgICB9KTtcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuICAvLyBzaG91bGRVcGRhdGUoKSB7fVxuXG4gIHdpbGxSZWNlaXZlUHJvcHMoKSB7XG4gIH1cblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybU1hcCk7XG4gICAgfVxuICAgIC8vIFRPRE8gLSBzZXQgbmVlZHNSZWRyYXcgb24gdGhlIG1vZGVsP1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIGxvZygzLCAnbGF5ZXIuc2V0VW5pZm9ybXMnLCB1bmlmb3JtTWFwKTtcbiAgfVxuXG4gIF92YWxpZGF0ZURlcHJlY2F0ZWRQcm9wcygpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5pc1BpY2thYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdObyBpc1BpY2thYmxlIHByb3AgaW4gZGVja2dsIHYzIC0gdXNlIHBpY2thYmxlIGluc3RlYWQnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gaW5qZWN0IHZpZXdwb3J0IGZyb20gb3ZlcmxheSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGZvciBlYWNoIGxheWVyP1xuICAgIGNvbnN0IGhhc1ZpZXdwb3J0UHJvcHMgPVxuICAgICAgLy8gdGhpcy5wcm9wcy53aWR0aCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAvLyB0aGlzLnByb3BzLmhlaWdodCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLnByb3BzLmxhdGl0dWRlICE9PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMucHJvcHMubG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMucHJvcHMuem9vbSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLnByb3BzLnBpdGNoICE9PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMucHJvcHMuYmVhcmluZyAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChoYXNWaWV3cG9ydFByb3BzKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAvLyAvKiBnbG9iYWwgY29uc29sZSAqL1xuICAgICAgbG9nLm9uY2UoMCxcbiAgICAgICAgYGRlY2suZ2wgdjMgbm8gbG9uZ2VyIG5lZWRzIHZpZXdwb3J0IHByb3BzIGluIExheWVyICR7dGhpc31gKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==